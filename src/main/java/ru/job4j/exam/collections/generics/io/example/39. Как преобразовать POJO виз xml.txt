39. Как преобразовать POJO в/из xml?
 Для начала нам нужно добавить зависимости на библиотеку JAXB с помощью которой мы будет делать преобразования
<dependency>
    <groupId>javax.xml.bind</groupId>
    <artifactId>jaxb-api</artifactId>
    <version>2.3.1</version>
</dependency>
<dependency>
    <groupId>javax.activation</groupId>
    <artifactId>activation</artifactId>
    <version>1.1.1</version>
</dependency>
<dependency>
    <groupId>org.glassfish.jaxb</groupId>
    <artifactId>jaxb-runtime</artifactId>
    <version>2.3.1</version>
</dependency>



POJO - это аббревиатура, которая расшифровывается как "Plain Old Java Object" (Простой Старый Объект на Java). Этот термин используется в контексте программирования на Java для обозначения обычных, стандартных классов, которые не зависят от какой-либо специфической фреймворковой или технологической платформы.

Основные характеристики POJO:

Простота: POJO классы не обладают специальными требованиями или ограничениями со стороны какой-либо фреймворковой или контейнерной платформы. Они могут быть созданы и использованы как любой другой обычный класс в Java.

Отсутствие зависимостей: POJO классы не зависят от определенных библиотек, классов или интерфейсов, за исключением стандартной библиотеки Java.

Прозрачность: POJO классы не "волшебны" и не требуют специальных конфигураций для своего использования. Они могут быть созданы, настроены и использованы по обычным Java стандартам.

POJO часто используются для представления данных, хранения состояния и поведения в объектно-ориентированных приложениях. Они могут быть переданы между различными компонентами системы, сериализованы в разные форматы (например, JSON или XML), и использованы в различных контекстах без особых ограничений.

Термин "POJO" стал особенно популярным после того, как появились различные фреймворки, такие как Spring, которые акцентировали внимание на создание чистых, независимых и легко тестируемых объектов в приложениях Java.



Для преобразования Java объектов (POJO - Plain Old Java Object) в XML и обратно в Java объекты существует несколько подходов и библиотек. Одним из распространенных способов является использование библиотеки JAXB (Java Architecture for XML Binding).

Пример преобразования POJO в XML с использованием JAXB:

Создайте класс POJO: Создайте Java класс, который представляет ваш объект и аннотируйте его аннотациями JAXB, чтобы указать, как элементы и атрибуты объекта должны быть преобразованы в XML.
Добавим аннотации JAXB, которая даст библиотеке информацию о том как парсить объект.
 *
 * @XmlRootElement(name = "boeing") - эта аннотация указывает, что класс Boeing
 * является корневым элементом XML, и имя корневого элемента будет "boeing".
 * @XmlAttribute - эти аннотации указывают, что поля
 * будут представлены в XML, по умолчанию поле парсится как тег.
 * @XmlAccessorType -  JAXB (Java Architecture for XML Binding) будет работать
 * непосредственно с полями класса, а не с его методами (геттерами и сеттерами)
 * при выполнении процессов маршалинга (сериализации) и анмаршалинга (десериализации).
 */
@XmlRootElement(name = "boeing")
@XmlAccessorType(XmlAccessType.FIELD)
public class Boeing {
    @XmlAttribute
    private boolean isPassengerPlane;
    @XmlAttribute
    private int maxSpeed;
    @XmlAttribute
    private String model;
    private Engine engine;
    private String[] availableClasses;

    /* Добавим дефолтные конструктор чтобы JAXB мог создать
     * объек класса при десериализации
     */
    public Boeing() {
    }




Процесс сериализации и десериализации в данном коде осуществляется с использованием Java Architecture for XML Binding (JAXB), который позволяет преобразовывать Java объекты в XML-представление и обратно. Давайте подробно рассмотрим каждый этап:

Сериализация:

Создается объект класса Person с определенными данными.
Создается объект JAXBContext, который предоставляет информацию о классах, которые будут сериализованы или десериализованы.
Из объекта JAXBContext создается Marshaller, который выполняет процесс сериализации.
Устанавливается свойство Marshaller.JAXB_FORMATTED_OUTPUT в значение true, чтобы результат сериализации был отформатирован.
Создается StringWriter, который будет использоваться для записи сериализованных данных в строку XML.
Метод marshal объекта Marshaller используется для сериализации объекта person в XML и записи результата в StringWriter.
Полученная XML-строка сохраняется в переменной xml.


Десериализация:

Создается объект Unmarshaller из того же JAXBContext, что и при сериализации.
Создается StringReader, который будет использоваться для чтения XML-строки из переменной xml.
Метод unmarshal объекта Unmarshaller используется для десериализации XML-данных из StringReader в объект типа Person.
Результат десериализации сохраняется в переменную result.
Вывод результатов:

В конце процесса сериализации выводится отформатированная XML-строка, представляющая объект Person.
В конце процесса десериализации выводится объект Person, восстановленный из XML.




JAXBContext (Java Architecture for XML Binding Context) - это класс в Java, предоставляемый платформой Java API для привязки XML (Java API for XML Binding, или JAXB). JAXBContext играет ключевую роль в процессе сериализации (преобразования объектов Java в XML) и десериализации (преобразования XML в объекты Java).

Основная цель JAXBContext заключается в том, чтобы предоставить информацию о классах, которые участвуют в процессе привязки XML, и поддерживать сопоставление между этими классами и структурой XML. Другими словами, он служит фабрикой, которая создает Marshaller и Unmarshaller, используемые для выполнения преобразования между Java-объектами и XML.

Классы, добавляемые в JAXBContext, должны быть аннотированы аннотациями JAXB (например, @XmlRootElement, @XmlElement, и т.д.), которые определяют, как поля класса будут отображаться в XML и какой форматирования следует придерживаться.
JAXBContext context = JAXBContext.newInstance(Person.class);
Здесь Person.class - это класс, который будет участвовать в процессе сериализации и десериализации, и JAXBContext.newInstance(Person.class) создает экземпляр JAXBContext, связанный с этим классом. Этот контекст затем используется для создания Marshaller и Unmarshaller, которые выполняют фактическую работу по преобразованию между Java и XML.


Marshaller - это класс в Java API для привязки XML (JAXB), который выполняет процесс сериализации объектов Java в формат XML. В более простых терминах, Marshaller преобразует структуры данных Java в их эквивалентное представление в формате XML.

Когда вы хотите сохранить объекты Java в виде XML-документа, вы используете Marshaller. Он выполняет следующие основные задачи:

Преобразование объектов Java в XML: Marshaller анализирует аннотации JAXB, определенные в классах, чтобы определить, какие поля объекта должны быть включены в XML-представление, и каким образом они должны быть отображены в XML-структуре.

Управление форматированием: Marshaller позволяет настроить форматирование XML-документа, такое как добавление отступов, пробелов и переносов строк для улучшения читаемости.

Обработка пространства имен: Marshaller заботится о правильном разрешении пространства имен XML, если оно определено в аннотациях или классах.

Пример использования Marshaller из вашего кода:

java
Copy code
/* Создаем сериализатор (Marshaller) */
Marshaller marshaller = context.createMarshaller();

/* Указываем, что нам нужно форматирование */
marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);

/* Сериализуем */
marshaller.marshal(person, writer);
Здесь marshaller.marshal(person, writer) выполняет сериализацию объекта person в XML и записывает результат в StringWriter. Весь процесс управляется Marshaller, который использует информацию из JAXBContext и аннотаций в классах для выполнения преобразования.


В данном коде использование блоков try с ресурсами является частью практики обработки исключений и управления ресурсами в Java, известной как "try-with-resources" (введено в Java 7). Эта конструкция автоматически управляет открытием и закрытием ресурсов, таких как StringWriter и StringReader, и обрабатывает исключения, возникающие в процессе.

Подход "try-with-resources" улучшает безопасность и чистоту кода, так как гарантирует, что ресурсы будут закрыты корректно, даже если возникнут исключения. В представленном коде блок try с ресурсами используется для следующих целей:

Сериализация:

StringWriter используется для записи сериализованных данных в строку.
Благодаря try с ресурсами, после завершения блока кода или возникновения исключения, StringWriter автоматически закрывается, освобождая ресурсы.
Десериализация:

StringReader используется для чтения XML-строки при десериализации.
Также благодаря try с ресурсами, StringReader будет закрыт после завершения блока или при возникновении исключения.
Преимущество использования try с ресурсами заключается в том, что он предотвращает утечки ресурсов и упрощает обработку исключений, что сделает код более надежным и поддерживаемым.






















