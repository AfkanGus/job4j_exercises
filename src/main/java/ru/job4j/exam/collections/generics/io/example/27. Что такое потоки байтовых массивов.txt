27. Что такое потоки байтовых массивов? Как они устроены?

ByteArrayInputStream и ByteArrayOutputStream. 
массив байтов потока ввода и вывода,позволяют читать данные из массива байтов и записывать данные в массив байтов соответственно. byte[] bytes = new byte[]{'j', 'a', 'v', 'd'}; 
ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
        int data;
        while ((data = stream.read()) != -1) {
            System.out.println((char) data);
        }
данные из массива можно не целиком. Для этого у класса ByteArrayInputStream есть следующий конструктор:
ByteArrayInputStream(byte[] buf,int offset,int length)-в этот конструктор передаются ещё параметры offset (позиция, с которой начнется считывание) и length (сколько байтов нужно считать).String str = "1234567" = 4567/

ByteArrayOutputStream.
представляет собой поток вывода, в котором данные записываются в массив байтов.
у него есть внутреннее поле  protected,куда метод write записывает данные из массива байтов.

ByteArrayOutputStream()массив байтов будет иметь изначальную ёмкость 32 байта, но при его переполнении данный массив будет автоматически расширяться. 
ByteArrayOutputStream(int size) можно сразу инициализировать массив своим начальным значением.
метод writeBytes()-запись массива байтов во внутреннее поле объекта ByteArrayOutputStream
 Он точно так же как write() записывает  указанное содержимое, только при его использовании не нужно оборачивать этот код в блок try-catch (не бросает исключение).
Данные, содержащиеся во внутреннем массиве байтов объекта типа ByteArrayOutputStream можно вывести разными путями. Первый - с помощью вывода в виде строки. Этот способ показан в примере выше.

Считанные данные внутри объекта изменить нельзя. Для чтения и изменения можно вывести (записать) эти данные в новый массив байт. Например:byte[] byteArray = outStream.toByteArray();
И еще один способ - передать записанный массив байт в другой поток. Например, записать в файл. Для этого нужно использовать метод writeTo().
явно закрывать эти потоки методом close() необязательно, что и сделано в нашем уроке, то есть мы не помещали наш код в конструкцию try-с-ресурсами, но всегда нужно иметь ввиду, что в будущем реализация программы может измениться, и может возникнуть ошибка необработанного исключения, поэтому всё же рекомендуется закрывать все открытые потоки, то есть помещать их в конструкцию try-с-ресурсами.
Символьными аналогами классов ByteArrayInputStream и ByteArrayOutputStream являются классы CharArrayReader и CharArrayWriter. Они работают аналогично классам, которые мы разбирали в этом уроке, только работают не с байтами, а с символами.