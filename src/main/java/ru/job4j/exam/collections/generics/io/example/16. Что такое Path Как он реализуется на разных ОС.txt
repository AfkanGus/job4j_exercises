16. Что такое Path? Как он реализуется на разных ОС?



 Интерфейс Path определен в пакете java.nio.file. 
интерфейс Path, поскольку он инкапсулирует путь к файлу. Как будет по­
казано далее, интерфейс Path служит связующим звеном для большинства новых
файловых средств в системе ввода-вывода NI0.2. Он описывает расположение фай­
ла в структуре каталогов.
. Так как у разных файловых систем есть свои особенности, интерфейс дает возможность реализовать собственную версию - наследника интерфейса Path в разных операционных системах. Path имеет несколько реализаций под некоторые операционные системы. При создании объекта Path, под капотом создается специальный объект, представляющий реализацию операционной системы, в которой он создается. Так как в разных ОС пути могут быть записаны по-разному, то объект, созданный в одной ОС, может не работать в другой ОС. 

в условиях кроссплатформенности:

Path path = FileSystems.getDefault().getPath("logs", "access.log");
BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8);

Метод FileSystems.getDefault().getPath("logs", "access.log") создает объект Path для файла "logs/access.log". Предполагается, что в текущей рабочей директории существует папка "logs" с файлом "access.log".

Затем мы используем класс BufferedReader из пакета java.io для чтения содержимого файла. Метод Files.newBufferedReader(path, StandardCharsets.UTF_8) создает объект BufferedReader, связанный с указанным путем path и использующий кодировку UTF-8 для чтения.
getDefault() является статическим методом класса FileSystems из пакета java.nio.file. Он возвращает экземпляр FileSystem, представляющий файловую систему по умолчанию для текущей среды выполнения.

Метод getDefault() используется для получения ссылки на файловую систему, которая является основной для операционной системы, на которой запущена программа. Это может быть файловая система, используемая по умолчанию на ОС, такая как NTFS в Windows или ext4 в Linux.

В следующей строке 

Path path = FileSystems.getDefault().getPath("logs", "access.log");
в параметры метода getPath() передаются части пути отдельными строками. При создании пути, из этих частей программой будет определен разделитель с помощью метода FileSystem.getSeparator(), и с помощью этого разделителя будет собрана строка. В данном случае будет определен разделитель той ОС, в которой выполняется программа.

Например, в ОС Windows путь из примера будет собран с помощью разделителя "\" таким образом: logs\access.log
Рассмотрим создание файлов и директорий на данном примере:
 public static void main(String[] args) throws IOException {
        Path dir = Paths.get("path/paths"); - Создать объект Path,первый способ.
Класс Paths содержит ед.метод get()который помещает путь внутрь объекта Paths
        Files.createDirectories(dir);- создаются директории на диске в корне проекта с помощью метода createDirectories() класса Files (метод создаёт директории, даже если их не существовало).
Аналогично методу mkdir() класса File(), можно создать конкретную директорию методом Files.createDirectory(), но только, если все остальные директории в пути уже существуют.
        Path path = Path.of("path/paths/path.txt");
Здесь создаётся новый файл. Второй способ заключается в том, что путь к файлу инкапсулируется с помощью метода of() класса Path. Рекомендуется использовать этот способ, так как метод Paths.get() под капотом вызывает метод Path.of(). Метод Path.of() был создан с целью визуального восприятия, что это фабричный метод, как и другие of() методы в Java, так как метод get() не совсем соответствовал его смыслу. Далее создается файл на диске в директории paths с помощью метода createFile().
        Files.createFile(path);
    }
Таким образом, объект интерфейса Path мы создаем с помощью методов get() или of(), а объект класса File() создается с помощью ключевого слова new.

Для поддержки кода, написанного с помощью класса File, существуют методы toFile() и toPath() для перевода в объекты File и Path:

java
Path path = Path.of("path/paths/path.txt");
File file = path.toFile(); 
System.out.println(file);
Path pathAgain = file.toPath(); 
System.out.println(pathAgain);

 System.out.println("Файл/директория существует?: " + Files.exists(path));
        System.out.println("Это директория?: " + Files.isDirectory(path));
        System.out.println("Это файл?: " + Files.isRegularFile(path));
        System.out.println("Имя файла: " + path.getFileName());
        System.out.println("Путь к файлу абсолютный?: " + path.isAbsolute());
        System.out.println("Родительская директория файла: " + path.getParent());
        System.out.println("Абсолютный путь к файлу: " + path.toAbsolutePath());
        System.out.println("Абсолютный путь к директории: " + dir.toAbsolutePath());
        System.out.println("Доступен для чтения?: " + Files.isReadable(path));
        System.out.println("Доступен для записи?: " + Files.isWritable(path));





для того чтобы работать с файлами выполянть с ними определенные дейсвия, нужно иметь доступ к файлам и знатьгде они находятся.
в пакете java.io есть класс File. Он описывает свойства самих файлов на диске, права доспута, время дата путь к каталогу, перемешение по каталагам.
Но есть и недостатки
- слабый функционал по количеству методов (Например, отсутствовала возможность копировать/перемещать файлы).

- мало обратной связи в виде отсутствия у многих методов полезных выбрасываемых исключений при возникновении ошибок, так как большинство методов в случае ошибки просто возвращали false без возможности продиагностировать ошибку.

- в классе File есть практически одинаковые методы, различающиеся только по типу возвращаемого значения, в которых можно было запутаться. Например, методы getAbsoluteFile() и getAbsolutePath().

- плохая поддержка метаданных. Файл может включать атрибуты безопасности, данные о владельце файла и т.д. В частности, из-за этого не во всех операционных системах работает метод renameTo()
В связи с этим в версии В версии JDK 7 система ввода-вывода NIO была значительно расширена и усо­
вершенствована. Помимо помержки оператора try с ресурсами, который обес­
печивает автоматическое управление ресурсами, усовершенствования включают
три новых пакета (java.nio.file, java.nio.file.attribute и java.
nio. f i le. spi), несколько новых классов, интерфейсов и методов, а также пря­
мую поддержку потокового ввода-вывода.
java.nio.file Померживает ввод-вывод в файлы
java.nio.file.attribute Померживает атрибуты файлов
java.nio.file.spi Померживает работу поставщиков услут для файловых
систем