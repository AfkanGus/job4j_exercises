10. Что такое буферизированный поток? 
Буферизированный поток - это стандартный поток, к которому добавлен специальный буфер в памяти, который увеличивает производительность чтения и записи. Обращение к ресурсу при чтении/записи - это очень затратный процесс, поэтому чем меньше обращений к ресурсу - тем лучше. Буферизированные потоки - это обёртки обычных потоков с буфером.
Как уже говорилось в уроке про потоки ввода-вывода, классы с InputStream/OutputStream в названии читают и пишут побайтово. То есть, например, метод read() читает всего один байт за раз. Такой способ чтения/записи очень медленный. 

Для ускорения процессов существуют буферизированные потоки. Они увеличивают производительность программы за счет считывания некоторого объема данных в буфер. Пример из реального мира: если нам нужно переложить, например, какие-то вещи из одного места в другое, мы воспользуемся пакетом, чтобы унести сразу несколько вещей, а не носить их по одной. Пакет - это и есть буфер.
Зачем нужен буфер? Манипуляции с буфером происходят быстрее, чем манипуляции напрямую с внешним ресурсом (Например, сетью или жестким диском). Буфер выгоден тем, что при записи данных на диск, данные не пишутся непосредственно на ресурс (диск), а сохраняются в буфере потока. В этом случае данные будут записаны на диск либо при закрытии потока, либо при явном вызове метода flush(), который переводит накопленные буфером данные в поток. 

Главный плюс буфера в том, что мы не обращаемся к диску за каждой единицей данных. Если нам нужно считать данные, то в буфер считается больший объем, чем нужно, и при следующем чтении оно будет производится из буфера, не обращаясь к ресурсу. Так же и при записи, например, на диск данные будут записываться сразу большими блоками.

Как уже говорилось выше, каждое обращение к внешнему ресурсу - дорогостоящая операция. Например, метод read() в нашей программе инициирует системный вызов, который обращается к операционной системе для выполнения операции чтения с ресурса. Аналогично и с методом write(). Запросы к ОС сопровождаются дополнительной тратой времени и ресурсов. Буфер помогает уменьшить количество таких обращений, соответственно, ускоряет работу программы. Считав данные в буфер, мы можем работать с его данными внутри программы, не обращаясь для этого к ОС. Новое чтение с диска или запись на диск (физический) происходит только когда все данные из буфера чтения уже прочитаны, либо буфер записи уже переполнен (либо принудительно через метод flush()). 

Буферное побайтовое чтение/запись реализовано классами BufferedInputStream и BufferedOutputStream.
Буферное посимвольное чтение/запись реализовано классами BufferedReader и BufferedWriter.

Все buffered* классы являются обёртками и не могут существовать сами по себе. При создании объектов этих классов в их конструкторы нужно передавать объекты классов-реализаций InputStream/OutputStream. Могут быть и цепочки обёрток, но в корне всегда должен быть байтовый или символьный поток.

BufferedInputStream(InputStream in)
BufferedOutputStream(OutputStream out)конструкторы этих классов мы должны передать какие-либо реализации интерфейсов InputStream и OutputStream.
 Конструктор типа
new FileOutputStream("data/output.txt")
будет перезаписывать файл при каждом вызове метода write(), то есть старые данные, которые были в файле, будут утрачены.
FileoutputStream(String name, boolean append)Чтобы метод write() добавлял данные в файл, а не перезаписывал, нужно использовать такой конструктор:В параметр append нужно передать true, чтобы новые данные добавлялись в файл, а не перезаписывали существующие данные.
Важно! В этом уроке мы узнали, что существуют не только классы, представляющие из себя сами потоки (например, FileInputStream), но и классы-обёртки для таких классов (например BufferedInputStream для FileInputStream), выполняющие какую-то полезную функцию.

Например, текстовый файл содержит текст, то есть символы. Соответственно, быстрее будет читать данные не побайтово, а посимвольно, для этого вместо байтовых потоков
Практически у всех байтовых классов *InputStream / *OuputStream существует свой символьный аналог *Reader / *Writer. Работают они аналогично друг другу. Выбор того или иного класса должен зависеть от того, в каком виде представлены данные, с которыми нужно работать.