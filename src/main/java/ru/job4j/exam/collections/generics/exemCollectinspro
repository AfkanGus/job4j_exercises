vv
Экзамен. Структуры данных и алгоритмы
1. Что такое generics?
Generics (обобщения) - это механизм в языке программирования Java, который позволяет создавать параметризованные типы данных, которые могут работать с различными типами данных.
Generics позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных без необходимости написания отдельного кода для каждого типа данных. Вместо этого, вы можете определить параметр типа (также называемый обобщенным типом), который будет заменен на конкретный тип данных при использовании кода.
Для определения параметра типа используется символ "<" и ">" в сочетании с именем параметра типа. Например, следующий код определяет параметризованный тип данных T:
Copy code
public class MyClass<T> {
    private T value;
    public MyClass(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
Здесь T - это параметр типа, который будет заменен на конкретный тип данных при создании объекта класса MyClass. Например, чтобы создать объект MyClass с типом данных Integer, мы можем использовать следующий код:
MyClass<Integer> myClass = new MyClass<Integer>(10);
В Java существует несколько типов данных, которые могут быть использованы для объявления переменных и определения типов параметров и возвращаемых значений методов. Некоторые из основных типов данных в Java включают:
Целочисленные типы:
byte: 8-битное целое число со знаком (-128 до 127)
short: 16-битное целое число со знаком (-32,768 до 32,767)
int: 32-битное целое число со знаком (-2,147,483,648 до 2,147,483,647)
long: 64-битное целое число со знаком (-9,223,372,036,854,775,808 до 9,223,372,036,854,775,807)
Вещественные типы:
float: 32-битное число с плавающей точкой (1.4e-45 до 3.4e+38)
double: 64-битное число с плавающей точкой (4.9e-324 до 1.7e+308)
Логический тип:
boolean: логическое значение true или false
Символьный тип:
char: 16-битный символ Unicode (от '\u0000' до '\uffff')
Ссылочные типы:
классы (class)
интерфейсы (interface)
перечисления (enum)
массивы (array)
и другие пользовательские типы данных, определенные разработчиком
Это лишь некоторые из основных типов данных в Java. В языке также существуют дополнительные типы данных, такие как BigInteger, BigDecimal, String и т. д., которые предоставляют расширенные возможности для работы с числами и текстовыми данными.
---------------------------------------------------------------------

Параметризованный тип (или обобщенный тип) - это тип данных, который создается с использованием параметра типа. В языке Java параметризованные типы позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

Для создания параметризованного типа в Java используется символ "<" и ">" для указания параметра типа. Например, следующий код создает параметризованный тип List, который может хранить значения типа String:
List<String> myList = new ArrayList<String>();
Здесь List - это интерфейс, который определен в Java Collections Framework, а ArrayList - это класс, который реализует интерфейс List. Мы указываем параметр типа String в угловых скобках, чтобы создать список, который может хранить только значения типа String.
---------------------------------------------------------------------------------

Generics в данном случае это запись, заключенная в скобки <>
Для решения проблемы совместимости типов разных классов.
Прим. Есть коллекция с в классе, и нужно добовать не только экземпялры этого класса в коллекцию, но и другого класса.  Без <> делать это не безопасно,-> Object, приветению типов. А в <> мы указываем тип данных в виде параметра в классах, методах,интерфейсах.  эклссемпляры которого будем использовать в классе с добавлением в коллекции.
Существует 2 типа дженериков:
Параметризированый тип - Обобщения - это параметризованные типы.  для параметризации класса С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.
public static class NumberContainer<T extends Number & Comparable>
Для того чтобы создать класс общего типа достаточно в его объявлении в <> указать перечень общих типов, которые будут использоваться для реализации класса (типов может быть несколько)
: Существует такое понятие, связанное с generics, как необработанные типы (в литературе, интернете еще можно встретить такое название как "сырые типы"). Обозначаются они также как и generics в скобках <>, в которых проставляются заглавные латинские символы, зарезервированные специально Когда мы будем использовать этот класс нам будет необходимо указать точный параметр, который будет использоваться вместо K и V. Добавим метод main() выведем в консоль создаваемые объекты с разными параметрами:
public class GenericsClass<K, V> {
    private K key;
    private V value;
    public GenericsClass(K key, V value) {
        this.key = key;
        this.value = value;
    }
GenericsClass<String, String> gen = new GenericsClass<>("First key", "First value");
    System.out.println("Вывод в консоль: " + gen);
    GenericsClass<Integer, String> second = new GenericsClass<>(12345, "Second value");
    System.out.println("Вывод в консоль: " + second);

<?> Wildcard
 используются в сигнатуре методов
2. Что такое wild cards
Wildcards (дословный перевод - "шаблоны с подстановочными знаками") в языке программирования Java представляют собой механизм, который позволяет создавать более гибкие и универсальные типы данных.
Wildcards позволяют создавать параметризованные типы, которые могут принимать аргументы любого типа, без необходимости знать конкретный тип. Это делает их очень полезными в контексте обобщенного программирования (generic programming), так как они позволяют создавать универсальные методы и классы, которые могут работать с разными типами данных.
public class Person {
    private String name;
    private int age;
    private Date birthday;
--------------------------------
public class Programmer extends Person {
    public Programmer(String name, int age, Date birthday) {
        super(name, age, birthday);
    }
--------------------------------
public class GenericUsage {
    /*
 метод печатает элементы коллекции (collection) в консоль.
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }
    /*
     создадим метод который позволит вывести в консоль все элементы коллекции
     , которая может содержать объекты Person или объекты класса Programmer:
     */
    public void printInfo(Collection<? extends Person> collection) {
        for (Iterator<? extends Person> it = collection.iterator();
             it.hasNext();
        ) {
            Person next = it.next();
            System.out.println(next);
        }
    }

    /*
     мы хотим написать метод, который помещает объекты Integer в список и выводит этот
      список в консоль. При этом наш метод должен быть более гибки
      м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
     */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }
---------------------------------------------------
Unbounded Wildcards <?>
 символом подстановки
подстановочные типы.
    3. Что такое bounded wild cards?
Bounded Wildcards: они позволяют ограничить типы данных, которые могут быть переданы в параметризованный тип. Для этого используется ключевое слово extends или super.
   Upper Bounded Wildcards <? extends Number>
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
 может содержать объекты, класс которых является Number или наследуется от Number.
 метод который нужно реализовать использует определенный тип и все его подтипы
Это ковариантность.
 Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. List<Integer> — подтип List<? extends Number>
Lower Bounded Wildcards <? super Integer>
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
может содержать объекты, класс которых Number или  у которых Number является наследником (супертип от Number)
ограниченный снизу wildcard ограничивает неизвестный тип определенным типом или супертипом этого типа.
Это контравариантность.
Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
 List<Number> является подтипом List<? super Integer>.
 мы хотим написать метод, который помещает объекты Integer в список и выводит этот
  список в консоль. При этом наш метод должен быть более гибки
  м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
 */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }

4. Что такое unbounded wild cards?
Unbounded Wildcards: они представляются символом "?". Эти wildcards позволяют передавать любой тип данных в параметризованный тип.
Unbounded Wildcards <?> позволяют создавать универсальные методы, которые могут работать с различными типами данных.
Unbounded Wildcards <?>
    /*
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }
Для того, чтобы определиться с выбором между extends и super был придуман метод PECS.
Producer Extends Consumer Super
Если метод имеет аргументы с параметризованным типом (например, Collection<T> или Predicate<T>), то в случае, если аргумент — производитель (producer), нужно использовать ? extends T, а если аргумент — потребитель (consumer), нужно использовать ? super T.
{
   /**
    * Кладёт значение в хранилище по заданному ключу.
    *
    * @param key Ключ.
    * @param value Значение.
    */
   void put(K key, V value);
   /**
    * Читает значение из хранилища по заданному ключу.
    *
    * @param key Ключ.
    * @return Значение либо null.
    */
   @Nullable V get(K key);
   /**
    * Кладёт все пары ключ-значение в хранилище.
    *
    * @param entries Набор пар ключ-значение.
    */
   void putAll(Map<K, V> entries);
   /**
    * Читает все значения из хранилища по заданным
    * ключам.
    *
    * @param keys Набор ключей.
    * @return Пары ключ-значение.
    */
   Map<K, V> getAll(Collection<K> keys);
   /**
    * Читает из хранилища все значения, удовлетворяющие
    * заданному условию (предикату).
    *
    * @param p Предикат для проверки значений.
    * @return Значения, удовлетворяющие предикату.
    */
   Collection<V> getAll(Predicate<V> p);
 метод getAll(Predicate<V> p) является Consumer, потому что он принимает предикат p, который применяется к каждому элементу хранилища для определения, удовлетворяет ли элемент условию. Метод не производит никаких значений, а только принимает их и возвращает коллекцию значений, удовлетворяющих предикату.
Остальные методы, такие как put(K key, V value), get(K key), putAll(Map<K, V> entries), и getAll(Collection<K> keys), являются Producer, потому что они создают или производят значения и помещают их в хранилище, или возвращают значения из хранилища
    5. Где хранится информация про Generics?
В Java информация о типах (Generics) стирается во время компиляции (type erasure), то есть, в скомпилированном байт-коде нет информации о типах, используемых в коде
    6. Как можно получить тип Generics?
 в Java есть механизм рефлексии, который позволяет получать информацию о типах во время выполнения программы
 в исходном коде до компиляции информация о generics может быть доступна через использование Java Reflection API. Reflection API позволяет получить информацию о типах переменных, методов, классов
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]
getClass().getGenericSuperclass() позволяет получить информацию о суперклассе объекта, а затем метод getActualTypeArguments() возвращает массив параметров типа, указанных в суперклассе в виде дженериков. Поскольку в данном случае параметр типа находится на первой позиции в массиве параметров типа суперкласса, мы можем получить его, обратившись к элементу массива [0].
Затем мы используем оператор приведения типа (Class<T>) для приведения параметра типа к классу типа T, который был указан при создании объекта этого класса.
  7. Что такое итератор?
Итератор в Java - это интерфейс, предоставляющий возможность последовательного доступа к элементам коллекции без раскрытия ее внутренней реализации. Итератор может использоваться для обхода любого типа коллекции, включая списки, множества, карты и т.д.
Интерфейс Iterator в Java содержит 3 метода:
boolean hasNext() - возвращает true, если в коллекции есть следующий элемент, иначе false.
E next() - возвращает следующий элемент в коллекции типа E.
void remove() - удаляет текущий элемент из коллекции.
Каждый итератор хранит внутреннюю переменную, указывающую на текущую позицию в коллекции. Эта переменная устанавливается в начало коллекции при создании итератора, и каждый вызов метода next() перемещает эту переменную на следующий элемент коллекции. Метод hasNext() проверяет, есть ли следующий элемент в коллекции.
Для использования итератора сначала необходимо получить экземпляр этого интерфейса от коллекции, используя метод iterator(). Затем можно использовать методы hasNext() и next() для обхода коллекции.
 fail-fast поведение, т.е. если с момента создания итератора коллекция подверглась структурному изменению, итератор должен кидать ConcurrentModificationException.
Это достигается через введение счетчика изменений - modCount. Каждая операция, которая структурно модифицирует коллекцию, должна инкрементировать этот счетчик. В свою очередь, итератор запоминает значение этого счетчика на момент своего создания (expectedModCount), а затем, на каждой итерации, сравнивает сохраненное значение с текущим значением поля modCount, если они отличаются, то генерируется исключение.
Ранее мы с Вами реализовывали и использовали Iterator, который обладает поведением fail-fast. Что это значит? Это значит, что если мы по ходу итерирования меняем коллекцию, то получаем исключение ConcurrentModificationException. Например, такой код приведет к этому исключению
java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer i : list) {
    list.add(i * i);
}
В качестве альтернативы "обычному" итератору, есть ListIterator. Он обладает fail-safe поведением, это значит, что мы можем менять коллекцию по ходу итерирования, но только с помощью самого итератора.
Подобный код по прежнему не будет работать
java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
ListIterator<Integer> i = list.listIterator();
while (i.hasNext()) {
    Integer value = i.next();
    if (value <= 5) {
        list.add(value * value);
    }
    i.next();
}
Таким образом, чтобы как-то манипулировать списком во время итерирования, нужно использовать методы ListIterator








































  8. Что такое коллекции?

Коллекции в Java - это фреймворк, предоставляющий классы и интерфейсы для управления группами объектов.Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными.
 Java Collection Framework иерархию интерфейсов находятся 2 интерфейса:

1. Collection

2. Map.
Что такое Java Collections Framework?

Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет разработчику пользоваться большим количесвом структур данных из «коробки».


Базовые понятия

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).



Collection — этот интерфейс находится в составе JDK c версии 1.2 и определяет основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (например size(), isEmpty(), add(E e) и др.). Интерфейс был слегка доработан с приходом дженериков в Java 1.5. Также, в версии Java 8, было добавлено несколько новых методов для работы с лямбдами (такие как stream(), parallelStream(), removeIf(Predicate<? super E> filter) и др.).

Важно также отметить, что эти методы были реализованы непосредственно в интерфейсе как default-методы.

Map. Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».Также как и Collection, он был дополнен дженериками в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения (getOrDefault(Object key, V defaultValue), putIfAbsent(K key, V value)).


Интерфейс Map [doc]

Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8).

LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой статье.

TreeMap — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.

WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.


Интерфейс List [doc]



Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).

Vector — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList.

Stack — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.

ArrayList — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике.

LinkedList — ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответствующие методы. На Хабре также есть статья с подробным анализом и описанием этой коллекции.


Интерфейс Set [doc]

Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».

HashSet — реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.

LinkedHashSet — отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.

TreeSet — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".


Интерфейс Queue [doc]



Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для извлечения и добавления элементов в очередь. Большинство реализаций данного интерфейса находится в пакете java.util.concurrent и подробно рассматриваются в данном обзоре.

PriorityQueue — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.

ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.


Заключение

Java Collections Framework содержит большое количество различных структур данных, доступных в JDK «из коробки», которые в большинстве случаев покрывают все потребности при реализации логики приложения. Сравнение временных характеристик основных коллекций, которые зачастую используются в разработке приложений приведено в таблице:



При необходимости, разработчик может создать собственную реализацию, расширив или переопределив существующую логику, либо создав свою собственную реализацию подходящего интерфейса с нуля. Также существует некоторое количество готовых решений, которые являются альтернативой или дополнением к Java Collections Framework. Наиболее популярными являются Google Guava и Commons Collections.

    9. Назовите базовые интерфейсы коллекций?
 иерархию интерфейсов   на вершмне Java Collection Framework находятся 2 интерфейса:

1. Collection

2. Map.

Collection – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

Map – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

Однако стоит обратить внимание, что этот интерфейс расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в так называемом улучшенном цикле for (for-each).

У интерфейса Iterable определен только один метод iterator(). Таким образом все наследники Collection (соответственно и Iterable) обязаны вернуть итератор. Итератор – это объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ к элементам любой коллекции без необходимости вникать в суть его реализации
boolean add(E e) – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.
boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась.
Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.
boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.
boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции. Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.
boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод. Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.

int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

Чтобы очистить содержимое коллекции можно использовать метод:

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Коллекцию можно преобразовать в массив, для этого можно использовать следующий метод:

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.





    10. Расскажите реализации интерфейса List?
ArrayList - это класс, который реализует интерфейс List и представляет динамический массив элементов. Он использует массив для хранения элементов и позволяет быстро получать доступ к элементам по индексу. Класс ArrayList также автоматически увеличивает размер массива при добавлении новых элементов, что делает его хорошим выбором для работы с большими списками элементов.
ArrayList: основан на массивах и обеспечивает быстрый доступ к элементам, но медленное вставление и удаление элементов в середине списка.

Класс ArrayList в Java имеет несколько конструкторов:

ArrayList(): создает пустой список.

ArrayList(Collection<? extends E> c): создает список, содержащий все элементы заданной коллекции, в порядке, в котором они встречаются в итераторе коллекции.

ArrayList(int initialCapacity): создает список с начальной емкостью initialCapacity.
Значение initialCapacity должно быть неотрицательным. Если передано отрицательное значение, будет выброшено исключение IllegalArgumentException. Если initialCapacity не указан явно, список создается с начальной емкостью по умолчанию, равной 10 элементам.


import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // создание нового ArrayList
        List<String> fruits = new ArrayList<String>();

        // добавление элементов
        fruits.add("apple");
        fruits.add("banana");
        fruits.add("orange");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + fruits.get(0));
        System.out.println("Element at index 1: " + fruits.get(1));

        // удаление элементов
        fruits.remove("banana");
        System.out.println("After removing banana: " + fruits);

        // замена элемента
        fruits.set(1, "pear");
        System.out.println("After replacing index 1 with pear: " + fruits);

        // получение размера списка
        System.out.println("Size of the list: " + fruits.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain orange? " + fruits.contains("orange"));

        // очистка списка
        fruits.clear();
        System.out.println("After clearing the list: " + fruits);
    }
}



LinkedList - это класс, который реализует интерфейс List и представляет двусвязный список элементов. Он использует узлы для хранения элементов и позволяет быстро добавлять и удалять элементы из начала и конца списка. Класс LinkedList также позволяет быстро добавлять и удалять элементы по индексу.
Односвязный список (Singly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение и ссылку на следующий узел в списке. Последний узел в списке содержит ссылку на null. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка и в конце списка, но медленно искать элементы по индексу.
Связанный список - это структура данных, состоящая из узлов, каждый из которых содержит данные и ссылку на следующий узел в списке. Таким образом, элементы списка связаны между собой ссылками, и каждый узел может быть легко найден, используя ссылку на следующий узел.

В Java, связанные списки реализованы в виде класса LinkedList, который реализует интерфейс List. Каждый элемент связанного списка представлен объектом типа Node, который содержит данные и ссылку на следующий узел. Для доступа к первому и последнему элементам списка используются ссылки на головной и последний элементы списка соответственно.

Одним из основных преимуществ связанных списков является то, что они позволяют эффективно добавлять и удалять элементы в любом месте списка, включая начало и конец. Также, при использовании связанных списков, не требуется предварительно выделять память для всего списка, что позволяет экономить ресурсы при работе с большими объемами данных. Однако, связанные списки обладают более сложной логикой работы по сравнению с массивами, их использование может привести к большему количеству операций чтения/записи в память, что может замедлить работу программы в некоторых случаях.

Двусвязный список (Doubly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение, ссылку на следующий узел в списке и ссылку на предыдущий узел в списке. Первый узел в списке имеет ссылку на null в качестве предыдущего узла, а последний узел имеет ссылку на null в качестве следующего узла. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка, в конце списка и по индексу.



Класс LinkedList имеет два конструктора:

LinkedList(): конструктор без параметров, создает пустой связный список.

LinkedList(Collection<? extends E> c): конструктор, который создает связный список из элементов коллекции c.

Оба конструктора создают объект типа LinkedList. Первый конструктор создает пустой связный список, а второй конструктор создает связный список из элементов переданной коллекции c.
Разница между односвязным списком и двусвязным списком заключается в том, что двусвязный список содержит дополнительные ссылки на предыдущий узел в списке, что делает его более гибким для некоторых операций, но требует больше памяти для хранения ссылок на предыдущие узлы.
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args) {
        // создание нового LinkedList
        List<String> names = new LinkedList<String>();

        // добавление элементов
        names.add("John");
        names.add("Alice");
        names.add("Bob");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + names.get(0));
        System.out.println("Element at index 1: " + names.get(1));

        // удаление элементов
        names.remove("Alice");
        System.out.println("After removing Alice: " + names);

        // замена элемента
        names.set(1, "Mary");
        System.out.println("After replacing index 1 with Mary: " + names);

        // получение размера списка
        System.out.println("Size of the list: " + names.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain Bob? " + names.contains("Bob"));

        // очистка списка
        names.clear();
        System.out.println("After clearing the list: " + names);
    }
}

package ru.job4j.exam.collections.generics.list;

import java.util.*;

public class ListUsage {
    @SuppressWarnings("checkstyle:MethodLength")
    public static void main(String[] args) {
       /* Для добавления новых элементов предназначены 4 метода:
        1.1. boolean add(E e) – добавляет элемент e в конец списка.*/
        List<String> rsl = new ArrayList<>();
        rsl.add("one");
        rsl.add("two");
        rsl.add("three");
/*
1.2. void add(int index, E element) – добавляет указанный элемент
(element) в указанную позицию(index) в списке.
*/
        rsl.add(0, "four");
       /* 1.3. boolean addAll(Collection<? extends E> c) – добавляет все элементы из переданной коллекции в
         конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.*/
        List<String> list = new ArrayList<>();
        list.add("four");
        list.add("five");
        rsl.addAll(2, list);
        for (String s : rsl) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("Прочитать элементы из списка можно двумя способами:\""
                + " 2.1. Использование метода get():");
        for (int i = 0; i < rsl.size(); i++) {
            System.out.println("Текущий элемент: " + rsl.get(i));
        }
        System.out.println("2.2. использовать итератор для доступа к элементам."
                +
                " Для того чтобы получить экземпляр итератора в интерфейсе List<E> определены 3 метода:\n"
                +
                "        Iterator<E> iterator() – метод возвращает объект Iterator, который содержит в\n"
                +
                "         себе все элементы исходной коллекции.");
        Iterator<String> iterator = rsl.iterator();
        while (iterator.hasNext()) {
            System.out.println("Текущий элемент: " + iterator.next());
        }
        System.out.println("ListIterator<E> listIterator() – возвращает итератор списка для элементов в этом списке.");
        ListIterator<String> listIterator = rsl.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator.next());
        }
        System.out.println("ListIterator<E> listIterator(int index) – возвращает итератор списка для элементов"
                + " в этом списке, начиная с элемента индекс которого равен index.");
        ListIterator<String> listIterator1 = rsl.listIterator(5);
        while (listIterator1.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator1.next());
        }
        /*
3. Изменение элементов в списке

E set(int index, E element) – заменяет элемент позиция которого равна index на элемент
 который мы передаем в метод (element). При этом метод возвращает старое значение элемента
  с индексом index.
         */
        List<String> rsl1 = new ArrayList<>();
        rsl1.add("one");
        rsl1.add("two");
        rsl1.add("three");
        rsl1.set(1, "two and second");
        for (String s : rsl1) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
        default void replaceAll(UnaryOperator<E> operator) – заменяет каждый элемент
         в списке результатом применения оператора (operator) к каждому элементу.
         */
        List<String> rsl2 = new ArrayList<>();
        rsl2.add("one");
        rsl2.add("two");
        rsl2.add("three");
        rsl2.replaceAll(String::toUpperCase);
        for (String s : rsl2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        4. Удаление элементов из списка
        Для выполнения данной операции в интерфейсе List<E> определены 5 методов:
         */
        List<String> rsl3 = new ArrayList<>();
        rsl3.add("one");
        rsl3.add("two");
        rsl3.add("three");
        /*
        E remove(int index) – удаляет элемент из списка по индексу index, при этом метод
         возвращает удаленный элемент.
         */
        rsl3.remove(1);
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        . boolean remove(E e) – удаляет элемент е типа E из коллекции при его
         ПЕРВОМ вхождении в список, если он есть в коллекции.
         */
        rsl3.remove("three");
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        boolean removeAll(Collection<?> col) – метод удаляет из списка все элементы,
         которые содержатся в коллекции col, если в результате работы метода исходный
          список изменился - метод возвращает true.
         */
        List<String> list2 = new ArrayList<>();
        list2.add("one");
        list2.add("three");
        list2.removeAll(list2);
        for (String s : list2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("-----");
        /*
         boolean retainAll(Collection<?> col) – метод также удаляет элементы из списка,
          за исключением тех, которые находятся в коллекции col, если в результате
           работы метода исходный список изменился - метод возвращает true.
         */
        List<String> list4 = new ArrayList<>();
        list4.add("one");
        list4.add("three");
        list4.retainAll(rsl);
        for (String s : list4) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
 default boolean removeIf(Predicate<? super E> filter) – метод удаляет все элементы из коллекции,
  которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения).
   Если в результате работы метода список изменился - метод возвращает true.
         */
        List<String> words = new ArrayList<>();
        words.add("кот");
        words.add("собака");
        words.add("слон");
        words.add("мышь");
        words.add("хомяк");
        words.removeIf(s -> s.length() <= 3);
        System.out.println(words);

    /*
    . boolean contains*(E element) – метод возвращает true, если список содержит
     переданный в метод элемент element.
     */
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        boolean b = numbers.contains(2);
        System.out.println("Список содержит элемент: " + b);
        System.out.println("------------");
        /*
        int indexOf*(E element) – метод возвращает индекс элемента element при его
         первом вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> strings = new ArrayList<>();
        strings.add("one");
        strings.add("two");
        strings.add("three");
        strings.add("four");
        strings.add("five");
        int i = strings.indexOf("two");
        System.out.println("Индекс элемента в списке: " + i);
        System.out.println("----------");
        /*
        int lastIndexOf*(E element) - метод возвращает индекс элемента element
         при его последнем вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> str = new ArrayList<>();
        str.add("two");
        str.add("three");
        str.add("one");
        int index = str.lastIndexOf("one");
        System.out.println("ндекс элемента в списке: " + index);
        System.out.println("----");
        /*
         List<E> subList(int fromIndex, int toIndex) - метод возвращает список, который содержит
          все элементы исходного списка начиная с индекса fromIndex(включительно)
           и до toIndex(значение исключается). При этом, если выполняется условие
            fromIndex == toIndex,- метод вернет пустой список.
         */
        List<String> strings2 = new ArrayList<>();
        strings2.add("one");
        strings2.add("two");
        strings2.add("three");
        strings2.add("four");
        strings2.add("five");
        List<String> newlist = strings2.subList(1, 2);
        for (String s : newlist) {
            System.out.println("екущий элемент: " + s);
        }
        System.out.println("----------");
        /*
        . default void sort(Comparator<? super E> comp) – метод осуществляет сортировку
         списка в соответствии с компаратором comp, который мы передаем в метод.
         */
        List<Integer> numbers1 = new ArrayList<>();
        numbers1.add(5);
        numbers1.add(2);
        numbers1.add(8);
        numbers1.add(1);
        numbers1.sort(Comparator.reverseOrder());
        System.out.println(numbers1);

    }
}



    11. Расскажите реализации интерфейса Set?
java.util.Set - классы реализующие этот интерфейс не могут содержать дубликаты элементов. Их также называют множества.
В коллекциях типа java.util.Set нет возможности указать индекс. Так же здесь нет возможности заменить элемент.
Вопрос, а как мы получаем данные из java.util.Set если там нет механизма извлечения данных.
Для начала давайте поймем, что же это такое и для чего нужно. Чаще всего на просторах можно встретить такую характеристику, как "множество". Это означает, что в такой коллекции собраны объекты, которые уникальны и все отличаются друг от друга (о том, как программа узнает, что объекты равны друг другу, будет рассказано немного позже). Самый простой пример из жизни - это русский или английский алфавит - в таком наборе данных не может быть двух одинаковых букв.

Set<E> является наследником интерфейса Collection<E>, при этом не добавляет новых методов в список унаследованных, только вносит в них изменения. Рассмотрим CRUD - операции, которые помогают нам использовать Set<E> для хранилища данных.

На самом деле все коллекции реализуют шаблон проектирования - итератор. Этот шаблон позволяет получить все элементы из любой коллекции.

Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:

boolean hasNext() - проверяет на наличие следующего элемента в списке.
T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
void remove() - удаляет элемент из коллекции и переводит указатель назад.

Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например для массива указатель будет индекс элемента.Главной особенностью коллекций java.util.Set является хранение только уникальных элементов.

Изменение элементов в множестве.

К сожалению, для данной структуры данных не определено методов которые напрямую позволяют изменить элементы в множестве.

Но в данном случае можно пойти на хитрость и использовать связку методов - remove() и add(). Т.е. мы сначала удаляем элемент, который надо заменить, а потом добавляем элемент, которым надо его заменить.

. Коллекции java.util.Set не будут добавлять дублирующие элементы.
Познакомимся с интерфейсом Set и его реализациями. Он расширяет интерфейс Collection и представляет собой набор уникальных элементов, т.е. в наборе значений не могут находиться одинаковые значения. Равенство элементов определяется методами equals() и hashcode(), которые определены в классе Object. Для реализаций своих моделей данных эти методы необходимо переопределять для более корректной работы.

Set не добавляет никаких методов по сравнению с Collection, только вносит изменения в унаследованные. Например метод add():

 boolean add(E e) – добавляет элемент в множество и при этом возвращает true только в том случае, если такого элемента еще нет в наборе данных. Если уже такой элемент имеется в коллекции - метод вернет false и набор данных при этом не изменится. Равенство объектов определяется по методу equals()

boolean addAll(Collection<? extends E> c) - добавляет все элементы из переданной коллекции в множество, если они еще не присутствуют в данном множестве. Если передаваемая коллекция также является множеством, то применение данного метода является эффективным способом объединения двух множеств.
int size() - метод возвращает количество элементов в коллекции.
Set<E> of(E ... elements) - метод возвращает множество, в которое помещены список элементов elements типа E.
4. Удаление элементов из множества.
 boolean remove(E e) - удаляет указанный элемент из множества, если он присутствует в нем. Метод возвращает true, если в результате вызова метода набор данных изменился, т.е. если в результате он был удален.
boolean removeAll(Collection<?> c) - удаляет из множества все элементы, которые содержатся в переданной в метод коллекции. Метод возвращает true, если в результате работы метода исходное множество изменилось.

boolean retainAll(Collection<?> c) - в результате работы метода во множестве сохраняются только те элементы, которые содержатся в передаваемой в метод коллекции. Если в результате работы метода исходное множество было изменено - метод вернет true.
default boolean removeIf(Predicate<? super E> filter) - метод удаляет все элементы из коллекции, которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения). Если в результате работы метода множество изменилось - метод возвращает true.
strings.removeIf(s -> s.startsWith("t"));
System.out.println("Вывод в консоль после удаления...");
for (String s : strings) {
    System.out.println("Текущий элемент: " + s);
}т.е. в данном случае мы удалили все строки, которые начинаются на букву t.
boolean contains(E e) – метод возвращает true, если множество содержит переданный в метод элемент e. Сравнение объектов выполняется с помощью метода equals()
int size() - метод возвращает целочисленное значение, и говорит нам о том, сколько элементов содержит наше множество.
default Stream<E> stream() - метод возвращает последовательный поток Stream, источником которой является наше множество. Далее этот поток мы обрабатываем методами которые определены в интерфейсе Stream.
strings.stream()
        .filter(s -> s.length() < 5)
        .forEach(st -> System.out.println("Текущий элемент: " + st));Используем этот метод, отфильтруем его, и выведем каждый элемент в консоль:


Интерфейс Set не имеет собственных конструкторов, так как это всего лишь интерфейс, определяющий набор методов, которые должны быть реализованы в классах-коллекциях, реализующих этот интерфейс.

Но у классов-реализаций интерфейса Set есть свои конструкторы. Например, у класса HashSet есть следующие конструкторы:

HashSet(): создает пустой HashSet с начальной емкостью по умолчанию (16) и коэффициентом загрузки по умолчанию (0.75).

HashSet(int initialCapacity): создает пустой HashSet с указанной начальной емкостью и коэффициентом загрузки по умолчанию (0.75).

HashSet(int initialCapacity, float loadFactor): создает пустой HashSet с указанной начальной емкостью и коэффициентом загрузки.

HashSet(Collection<? extends E> c): создает новый HashSet с элементами из указанной коллекции.

   Коэффициент загрузки (load factor) - это параметр, который используется в хеш-таблицах для определения того, насколько заполнена таблица, прежде чем ее размер увеличится автоматически.

В контексте HashMap и HashSet, коэффициент загрузки определяет, насколько заполнен должен быть массив хранения элементов, прежде чем размер массива увеличится. Например, если коэффициент загрузки установлен на 0.75, это означает, что массив должен быть заполнен не более чем на 75% до того, как размер массива увеличится.

Таким образом, значение 0.75 для коэффициента загрузки по умолчанию означает, что массив хранения элементов в HashMap или HashSet будет увеличен автоматически, когда заполненность достигнет 75%.



Интерфейс Set<E> имеет три реализации: HashSet, LinkedHashSet и TreeSet.

1. HashSet.

Это коллекция, которая не позволяет хранить одинаковые объекты(как и любой Set). HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом ключами в таблице будут значения которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - "заглушки" в виде экземпляров класса Object.

Хэш-таблица хранит информацию, используя механизм хеширования, в котором содержимое ключа используется для определения уникального значения - хеш-код. Хеш-код используется в качестве индекса, с которым ассоциируются данные, которые доступны по ключу. Преобразование ключа в хеш-код и обратно выполняется автоматически - об этом будет рассказано позже при рассмотрении HashMap. Хеширование выгодно тем, что оно обеспечивает константное время выполнения методов contains(), add(), remove().

Для того, чтобы использовать HashSet для хранения объектов, описанных классами собственной реализации, необходимо переопределить методы hashcode() и equals(), иначе два логически одинаковых объекта будут считать разными.

Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования не позволяет сделать в итоге отсортированный набор данных.

Для создания объекта HashSet в классе определены 4 конструктора:

HashSet() - создается пустое множество - при этом инкапсулированный объект HashMap имеет по умолчанию начальную емкость 16 элементов и коэффициент загрузки 0.75.

HashSet(int initialCapacity) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость, переданную в конструктор, и коэффициент загрузки по умолчанию - 0.75.

HashSet(int initialCapacity, float loadFactor) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость и коэффициент загрузки, которые передаются в конструктор.

HashSet(Collection<? extends E> c) - будет создано множество, в которое будет помещены элементы передаваемой коллекции.

HashSet в Java - это реализация интерфейса Set, основанная на хеш-таблице. Он используется для хранения набора уникальных элементов без упорядочения.

Хеш-таблица - это структура данных, которая используется для реализации словарей, множеств и других ассоциативных массивов. Она основывается на функции хеширования, которая преобразует ключи в хеш-коды, которые затем используются для поиска и добавления элементов в таблицу.

Хеш-таблица состоит из массива бакетов, в которых хранятся элементы. Каждый бакет имеет индекс и соответствующий ему список элементов. При добавлении элемента в хеш-таблицу, функция хеширования вычисляет хеш-код ключа и определяет индекс бакета, куда будет помещен элемент. Если в этом бакете уже есть элементы, то новый элемент добавляется в конец списка.

В HashSet каждый элемент хранится в виде ключа, без каких-либо значений. HashSet использует хеш-таблицу для хранения элементов, что позволяет быстро выполнять операции поиска, добавления и удаления элементов. При добавлении элемента в HashSet вычисляется его хеш-код, который определяет индекс бакета, в который будет помещен элемент. Если в этом бакете уже есть элементы, то новый элемент добавляется в конец списка.

HashSet позволяет хранить только уникальные элементы. Если в HashSet попытаться добавить уже существующий элемент, то операция добавления будет проигнорирована. Это достигается благодаря использованию хеш-кодов, которые позволяют быстро проверять, есть ли элемент в хеш-таблице.


В контексте Set, бакет (bucket) - это ячейка или список внутри таблицы хеш-кодов, который содержит элементы Set, имеющие одинаковый хеш-код.

Когда элемент добавляется в HashSet, сначала вычисляется его хеш-код с помощью метода hashCode(), а затем он помещается в соответствующий бакет в таблице хеш-кодов. Если в бакете уже есть элементы, то новый элемент будет добавлен в конец списка в этом бакете.

При поиске элемента в HashSet, сначала вычисляется его хеш-код, затем ищется соответствующий бакет в таблице хеш-кодов, и элементы в этом бакете проверяются на равенство с искомым элементом при помощи метода equals(). Если элемент найден, то возвращается соответствующий объект, если нет - возвращается null.

Количество бакетов в таблице хеш-кодов HashSet зависит от размера Set и выбранной реализации. При увеличении количества элементов в Set, HashSet может перестраивать таблицу хеш-кодов, чтобы увеличить количество бакетов и улучшить производительность поиска.

Хеш-код (hash code) - это числовое значение, которое определяется на основе содержимого объекта и используется для его идентификации. В коллекциях, таких как HashSet, хеш-код используется для распределения объектов по "бакетам" (buckets). Бакеты представляют собой группы объектов, хранящихся в коллекции. Когда вы добавляете новый объект в HashSet, его хеш-код вычисляется и используется для определения бакета, в который он будет помещен.

Хеш-код вычисляется с помощью специальной функции, которая преобразует содержимое объекта в числовое значение. Хорошая хеш-функция должна минимизировать вероятность коллизий - ситуации, когда два разных объекта имеют одинаковый хеш-код. Если такое происходит, они будут помещены в один бакет и будут сравниваться с помощью метода equals, чтобы определить, являются ли они одинаковыми или разными.
Для сравнения объектов  в Set использовать метод:

public static boolean equals(Object a,
 Object b)Возвращает true, если аргументы равны друг другу, и false в противном случае. Следовательно, если оба аргумента равны нулю, возвращается значение true. В противном случае, если первый аргумент не равен null, равенство определяется вызовом метода equals первого аргумента со вторым аргументом этого метода. В противном случае возвращается false.

public static boolean deepEquals(Object a,
 Object b)Он используется для сравнения двух объектов на равенство. В случае, если сравниваемые объекты являются массивами, метод выполняет глубокое сравнение, то есть сравнивает не только ссылки на массивы, но и содержимое элементов массивов.

Метод принимает два объекта в качестве параметров и возвращает true, если они равны и false в противном случае. Если хотя бы один из параметров равен null, метод вернет true.Например, если мы хотим сравнить два массива a и b на равенство, мы можем вызвать метод deepEquals следующим образом:
boolean result = Objects.deepEquals(a, b);
Если a и b равны по содержимому, то метод вернет true, иначе - false.
В Set интерфейсе метод hashCode() возвращает хеш-код множества, то есть целочисленное значение, которое является индексом внутренней хеш-таблицы.

Реализация метода hashCode() в разных реализациях Set интерфейса может отличаться. Но в общем случае, если два множества равны (определяется методом equals()), то их хеш-коды должны быть равными.

Однако не гарантируется, что если хеш-коды двух множеств равны, то множества также будут равны. Это может произойти из-за коллизий хеш-функции, когда разным объектам присваивается одинаковый хеш-код.
hashCode - это метод, который возвращает целочисленное значение, которое используется для идентификации объекта в HashMap, HashSet и других структурах данных, которые используют хеш-таблицы. Хеш-таблица - это структура данных, которая использует хеш-функцию для преобразования ключа объекта в индекс массива, где хранится сам объект.

Когда объект добавляется в HashSet, он помещается в соответствующий "бакет" (ячейку хеш-таблицы) на основе его хеш-кода. Если в этом бакете уже есть другие объекты, то выполняется сравнение объектов методом equals. Если equals возвращает true, то объект не добавляется, так как в Set не могут быть дубликаты. Если equals возвращает false, то объект добавляется в этот бакет.

Кроме того, метод hashCode используется для поиска объектов в HashSet. При вызове метода contains или remove с объектом в HashSet, сначала вычисляется хеш-код этого объекта, затем производится поиск в соответствующем бакете. Если объект не найден, то он не был ранее добавлен в HashSet. Если объект найден, то выполняется сравнение объектов методом equals.

Важно понимать, что разные объекты могут иметь одинаковый хеш-код, поэтому метод equals всегда должен быть реализован вместе с методом hashCode.





2. LinkedHashSet

Класс LinkedHashSet расширяет класс HashSet, при этом он не добавляет никаких новых методов. Но в отличие от HashSet, LinkedHashSet поддерживает связанный список элементов множества в том порядке, в котором они были добавлены в множество. Это значит, что когда будет выполняться перебор элементов, которые помещены в объект класса LinkedHashSet, с применением итератора - элементы будут извлечены в том порядке, в каком они были добавлены (HashSet, к сожалению, такого не гарантирует).

Чтобы создать объект класса LinkedHashSet можно использовать аналогичные конструкторы, что и у HashSet.
LinkedHashSet в Java является подклассом HashSet, который наследует все его свойства, но также сохраняет порядок элементов в коллекции, а именно порядок добавления элементов. Таким образом, LinkedHashSet объединяет в себе быстрый доступ к элементам за счет хеш-таблицы и сохранение порядка вставки элементов.

Это может быть полезным в тех случаях, когда важен порядок элементов в коллекции, например, при обработке данных в определенном порядке.

В LinkedHashSet используется двухсторонний связный список для поддержания порядка элементов. В процессе добавления элементов в LinkedHashSet, элементы добавляются в хеш-таблицу, а затем ссылки на них добавляются в конец списка. При удалении элемента из LinkedHashSet, он удаляется из хеш-таблицы, а затем ссылки на этот элемент удаляются из списка.

LinkedHashSet является реализацией интерфейса Set и наследуется от класса HashSet. Конструкторы LinkedHashSet аналогичны конструкторам HashSet, за исключением того, что LinkedHashSet поддерживает порядок вставки элементов, в то время как HashSet не гарантирует порядок хранения элементов.

Конструкторы LinkedHashSet:

LinkedHashSet(): создает пустой экземпляр LinkedHashSet с начальной емкостью 16 и коэффициентом загрузки по умолчанию 0.75.
LinkedHashSet(int initialCapacity): создает пустой экземпляр LinkedHashSet с указанной начальной емкостью и коэффициентом загрузки по умолчанию 0.75.
LinkedHashSet(int initialCapacity, float loadFactor): создает пустой экземпляр LinkedHashSet с указанной начальной емкостью и указанным коэффициентом загрузки.
LinkedHashSet(Collection<? extends E> c): создает экземпляр LinkedHashSet, содержащий элементы указанной коллекции, в порядке их добавления. Начальная емкость устанавливается равной максимальному значению изначальной емкости и количества элементов в коллекции, а коэффициент загрузки по умолчанию - 0,75.

3. TreeSet

Класс TreeSet представляет собой структуру данных в виде дерева, в котором все объекты хранятся в отсортированном по возрастанию порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно черное дерево для хранения элементов.

Создать объект класса TreeSet можно с помощью следующих конструкторов:

TreeSet() - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Collection<? extends E> c) - создается древовидное множество, которое будет содержать элементы из передаваемой коллекции, элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Comparator<? super E> comparator) - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с передаваемым в конструктор компаратором.
TreeSet - это реализация интерфейса Set, которая использует структуру данных Tree для хранения элементов в отсортированном порядке.

Как и в случае с HashSet, элементы в TreeSet не допускаются повторяться. Но в отличие от HashSet, элементы TreeSet автоматически сортируются по возрастанию или убыванию их значений, в зависимости от реализации Comparator.

При добавлении нового элемента в TreeSet происходит его вставка в структуру данных Tree в соответствии с его порядком. При удалении элемента, структура Tree автоматически перестраивается, чтобы сохранить порядок.

Операции добавления, удаления и поиска в TreeSet имеют асимптотическую сложность O(log n), что делает эту структуру данных хорошим выбором для приложений, где необходимо часто выполнять эти операции в большом множестве данных.

TreeSet - это класс, который реализует интерфейс Set и представляет собой отсортированный по возрастанию набор уникальных элементов. Вот некоторые методы, которые есть в TreeSet:

add(E e): добавляет элемент в TreeSet, если его там еще нет. Если элемент уже есть, то ничего не делает. Возвращает true, если элемент был добавлен успешно.

clear(): удаляет все элементы из TreeSet.

contains(Object o): возвращает true, если TreeSet содержит указанный элемент.

first(): возвращает первый (наименьший) элемент в TreeSet.

last(): возвращает последний (наибольший) элемент в TreeSet.

remove(Object o): удаляет указанный элемент из TreeSet, если он там есть. Возвращает true, если элемент был успешно удален.

size(): возвращает количество элементов в TreeSet.

ceiling(E e): возвращает наименьший элемент в TreeSet, который больше или равен указанному элементу e. Если такого элемента нет, возвращает null.

floor(E e): возвращает наибольший элемент в TreeSet, который меньше или равен указанному элементу e. Если такого элемента нет, возвращает null.

higher(E e): возвращает наименьший элемент в TreeSet, который больше указанного элемента e. Если такого элемента нет, возвращает null.

lower(E e): возвращает наибольший элемент в TreeSet, который меньше указанного элемента e. Если такого элемента нет, возвращает null.

iterator(): возвращает итератор по элементам TreeSet в возрастающем порядке.

descendingIterator(): возвращает итератор по элементам TreeSet в убывающем порядке.

subSet(E fromElement, E toElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, начиная с элемента fromElement и заканчивая элементом toElement. Включение/исключение границ диапазона зависит от использованной перегрузки метода.

tailSet(E fromElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, начиная с элемента fromElement и до конца TreeSet.

headSet(E toElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, от начала до элемента toElement (не включая его).






    12. Расскажите реализации интерфейса Map?


Интерфейс Map в Java представляет абстракцию для хранения ключей и связанных с ними значений. Все реализации интерфейса Map используют пары ключ-значение для хранения и доступа к данным. Ниже приведены основные реализации интерфейса Map в Java:

HashMap: наиболее распространенная реализация интерфейса Map. Она хранит пары ключ-значение в неупорядоченном виде, используя хеш-таблицу для быстрого доступа к данным.

LinkedHashMap: реализация, которая хранит пары ключ-значение в порядке добавления элементов или их доступа.

TreeMap: реализация, которая хранит пары ключ-значение в отсортированном порядке ключей. Она использует красно-черное дерево для хранения данных.

EnumMap: реализация, которая использует перечисления в качестве ключей и хранит значения в массиве. Это обеспечивает быстрый доступ к данным и позволяет использовать перечисления для проверки наличия ключа.

WeakHashMap: реализация, которая хранит пары ключ-значение в виде слабых ссылок. Это означает, что если ключ не используется в программе, он будет удален автоматически, чтобы освободить память.

IdentityHashMap: реализация, которая использует проверку на идентичность ключей, а не проверку на равенство. Это означает, что если два ключа имеют одинаковое значение, но разные идентификаторы, они будут храниться как разные элементы.

ConcurrentHashMap: реализация, которая обеспечивает потокобезопасный доступ к данным. Она использует блокировки для защиты данных, что позволяет нескольким потокам работать с различными частями хеш-таблицы одновременно.



HashMap - это реализация интерфейса Map в Java, которая используется для хранения пары ключ-значение (key-value). Она позволяет быстро и эффективно искать, добавлять, удалять и изменять значения элементов, используя хеш-функции для оптимизации процесса доступа к данным.

Внутренне HashMap представляет собой массив (бакеты) фиксированного размера, который может быть увеличен или уменьшен в зависимости от количества элементов. Каждый элемент хранится в виде объекта, который содержит ключ и значение. При добавлении элемента, HashMap вычисляет хеш-код ключа и на основе него определяет, в каком бакете должен быть сохранен элемент.

Если в одном бакете находится несколько элементов, они хранятся в связном списке. Когда количество элементов в одном бакете достигает определенного порога, связный список превращается в бинарное дерево для ускорения поиска.
. В стандартной реализации Java для HashMap порог переключения с односвязного списка на бинарное дерево равен 8 элементам, что соответствует коэффициенту загрузки 0,75. Изначально каждый бакет представляет собой односвязный список, и только при добавлении в один бакет большего числа элементов, чем 8, он перестраивается в бинарное дерево.

HashMap поддерживает операции вставки, удаления и поиска элементов за константное время (O(1)) в среднем случае, но в худшем случае сложность может достигать O(n), если все элементы хранятся в одном бакете. Поэтому важно выбирать правильный размер массива и хеш-функцию, чтобы минимизировать количество коллизий (ситуация, когда разным ключам соответствует один и тот же хеш-код) и обеспечить быстрый доступ к данным.

Худший и средний случайы обычно связаны с производительностью алгоритма в зависимости от входных данных.

Худший случай - это когда входные данные являются наихудшими для алгоритма, то есть входные данные, которые заставляют алгоритм работать максимально медленно или требовать большого объема памяти. Например, худшим случаем для алгоритма поиска в несортированном массиве является поиск отсутствующего элемента, который потребует прохода по всему массиву.

Средний случай - это случай, когда входные данные выбраны случайным образом из всех возможных входных данных. В этом случае средний случай отражает производительность алгоритма в реальных условиях. Например, средним случаем для алгоритма сортировки является сортировка массива, где элементы распределены равномерно.




HashMap - это одна из реализаций интерфейса Map, который используется для хранения данных в виде пары "ключ-значение". Реализация HashMap основана на хеш-таблицах.

Хеш-таблица - это структура данных, которая использует хеш-функцию для преобразования ключа в индекс массива, где значение хранится. Когда требуется получить значение, оно ищется по ключу, проходя по массиву по указанному индексу.

В HashMap каждая пара "ключ-значение" хранится в объекте Entry, который содержит ключ, значение и ссылку на следующий объект Entry, если при добавлении элементов произошла коллизия (два ключа имеют одинаковый хеш-код). Каждый объект Entry добавляется в массив, называемый бакетом, по индексу, вычисленному по хеш-коду ключа. При получении значения по ключу, HashMap вычисляет хеш-код ключа, находит соответствующий бакет и проходит по цепочке объектов Entry, пока не найдет нужный ключ или не достигнет конца цепочки.

Когда количество элементов в HashMap превышает определенный порог, размер массива увеличивается и все элементы перераспределяются в новый массив с большим размером. Этот процесс называется перехешированием.

Преимущества HashMap заключаются в том, что операции добавления, поиска и удаления элементов происходят за почти постоянное время O(1). Однако, при наличии коллизий производительность может ухудшаться до времени O(n). Кроме того, HashMap не гарантирует порядок элементов, что может быть нежелательно в некоторых случаях.

Entry - это внутренний класс в HashMap, который представляет собой узел, хранящий пару ключ-значение. Каждый объект Entry содержит ссылки на следующий и предыдущий элементы, что обеспечивает связанный список всех элементов в хэш-таблице.

Здесь важно отметить, что HashMap внутренне представляет собой массив связанных списков. Каждый элемент массива - это корень связанного списка, который содержит все элементы, у которых хэш-код совпадает с индексом в массиве. Если при добавлении нового элемента вычисленный хэш-код уже есть в массиве, то элемент добавляется в конец соответствующего связанного списка.

Каждый узел в связанном списке является объектом Entry, который содержит следующие поля:

final K key - ключ элемента;
V value - значение элемента;
int hash - хэш-код ключа;
Entry<K,V> next - ссылка на следующий элемент в связанном списке.
При поиске элемента в HashMap вычисляется хэш-код ключа и производится поиск элемента в соответствующем связанном списке. Если ключ не найден, то возвращается null. Если найден элемент с нужным ключом, то возвращается соответствующее ему значение. Если в связанном списке несколько элементов, у которых хэш-код ключа совпадает, то производится последовательный перебор элементов до тех пор, пока не будет найден элемент с нужным ключом.

Вставка элемента в HashMap происходит следующим образом:

вычисляется хэш-код ключа;
вычисляется индекс в массиве по модулю размера массива;
производится поиск элемента с таким же ключом в соответствующем связанном списке;
если элемент с таким ключом не найден, то создается новый объект Entry с заданными ключом и значением;
новый объект Entry добавляется в конец связанного списка.
Если связанный список слишком длинный, то это может привести к ухудшению производительности, так как при поиске элемента производится перебор всех элементов в списке. Чтобы избежать этой проблемы, можно увеличить размер массива HashMap. При этом все элементы будут перераспределены по новым индексам, что может привести к увеличению эффективности поиска элемента в связанном списке.

Вот список всех методов HashMap с кратким описанием того, что они возвращают:


Collection<V> values() - возвращает коллекцию всех значений в отображении в виде объекта типа Collection.
clear(): метод clear() удаляет все элементы из HashMap и не возвращает никакого значения.
containsKey(Object key): метод containsKey(Object key) проверяет, содержится ли указанный ключ key в HashMap. Если ключ содержится, то метод возвращает true, иначе - false.
containsValue(Object value): метод containsValue(Object value) проверяет, содержится ли указанное значение value в HashMap. Если значение содержится, то метод возвращает true, иначе - false.
entrySet(): метод entrySet() возвращает набор элементов Map.Entry в HashMap. Каждый элемент Map.Entry содержит пару "ключ-значение". Метод возвращает Set<Map.Entry<K,V>>.
equals(Object obj): метод equals(Object obj) проверяет, равна ли HashMap указанному объекту obj. Если объекты равны, то метод возвращает true, иначе - false.
get(Object key): метод get(Object key) возвращает значение, связанное с указанным ключом key в HashMap. Если ключа нет в HashMap, то метод вернет null.
hashCode(): метод hashCode() возвращает хеш-код HashMap. Хеш-код используется для быстрого поиска объектов в хранилищах данных. Метод возвращает int.
isEmpty(): метод isEmpty() проверяет, пуста ли HashMap. Если HashMap не содержит элементов, то метод возвращает true, иначе - false.
keySet(): метод keySet() возвращает набор всех ключей в HashMap. Метод возвращает Set<K>.
put(K key, V value): метод put(K key, V value) связывает указанное значение value с указанным ключом key в HashMap. Если ранее было связано другое значение с указанным ключом, то метод заменяет его на новое. Если ключ ранее не был связан с каким-либо значением, то метод добавляет новую пару "ключ-значение" в HashMap. Метод возвращает предыдущее значение, связанное с указанным ключом, или null, если ключ ранее не был связан с каким-либо значением.
putAll(Map<? extends K,? extends V> m): метод putAll(Map<? extends K,? extends V> m) копирует все отображения из указанной Map m в HashMap. Метод не возвращает никакого значения.
remove(Object key): метод remove(Object key) удаляет отображение, связанное с указанным ключом key, из HashMap. Метод возвращает предыдущее значение, связанное с указанным ключом, или null, если ключ не был связан с каким-либо значением.
size(): метод size() возвращает количество отображений в HashMap.
Класс HashMap имеет следующие конструкторы:

HashMap(): создает пустой объект HashMap с начальной емкостью 16 и коэффициентом загрузки по умолчанию 0.75.
HashMap(int initialCapacity): создает пустой объект HashMap с указанной начальной емкостью и коэффициентом загрузки по умолчанию 0.75.
HashMap(int initialCapacity, float loadFactor): создает пустой объект HashMap с указанными начальной емкостью и коэффициентом загрузки.
HashMap(Map<? extends K, ? extends V> m): создает объект HashMap, который содержит те же элементы, что и переданная Map.
В каждом конструкторе мы можем передать начальную емкость и коэффициент загрузки (отношение текущего размера к емкости), которые будут использоваться для вычисления, когда нужно будет увеличить емкость HashMap. Если начальная емкость не указана, по умолчанию используется значение 16. Если коэффициент загрузки не указан, по умолчанию используется значение 0.75.

Конструктор HashMap(Map<? extends K, ? extends V> m) позволяет создать новый объект HashMap, содержащий все элементы из указанной Map.

LinkedHashMap - это класс в Java, который реализует интерфейс Map и представляет собой хэш-таблицу с возможностью сохранения порядка вставки элементов.

Подобно HashMap, LinkedHashMap использует хэш-таблицу для хранения пар "ключ-значение". Однако, в отличие от HashMap, LinkedHashMap также поддерживает связный список элементов, который отображает порядок вставки элементов. Таким образом, порядок элементов в LinkedHashMap будет соответствовать порядку их вставки.

LinkedHashMap может быть использован в тех случаях, когда необходимо сохранить порядок вставки элементов, например, при реализации LRU-кэша (Least Recently Used - кэш с вытеснением давно неиспользуемых элементов).

В LinkedHashMap есть несколько конструкторов, которые позволяют указать начальную емкость, коэффициент загрузки и порядок итерации элементов (вставки или доступа). Также LinkedHashMap предоставляет методы, аналогичные методам HashMap, например, put(), get(), remove(), containsKey(), containsValue() и др.

Одним из дополнительных методов, предоставляемых LinkedHashMap, является removeEldestEntry(). Этот метод может быть переопределен в подклассах LinkedHashMap для определения, должен ли быть удален самый старый элемент в случае превышения определенного числа элементов. Это особенно полезно для реализации LRU-кэшей.

Как и HashMap, LinkedHashMap не является потокобезопасным и может вызывать ошибки при использовании из нескольких потоков. Для потокобезопасного доступа к LinkedHashMap можно использовать метод Collections.synchronizedMap().

У класса LinkedHashMap есть несколько конструкторов:

LinkedHashMap() - создает пустой LinkedHashMap со стандартной начальной емкостью (16) и коэффициентом загрузки (0.75).
LinkedHashMap(int initialCapacity) - создает пустой LinkedHashMap с указанной начальной емкостью и коэффициентом загрузки (0.75).
LinkedHashMap(int initialCapacity, float loadFactor) - создает пустой LinkedHashMap с указанной начальной емкостью и коэффициентом загрузки.
LinkedHashMap(Map<? extends K,? extends V> m) - создает LinkedHashMap, содержащий те же отображения, что и указанная карта, в том же порядке, что и она.
Вот некоторые методы, которые определены в LinkedHashMap:

void clear(): удаляет все элементы из LinkedHashMap.
boolean containsKey(Object key): проверяет, содержит ли LinkedHashMap указанный ключ.
boolean containsValue(Object value): проверяет, содержит ли LinkedHashMap указанное значение.
Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов Map.Entry в LinkedHashMap.
boolean equals(Object obj): проверяет, равен ли LinkedHashMap указанному объекту.
V get(Object key): возвращает значение, связанное с указанным ключом в LinkedHashMap.
int hashCode(): возвращает хеш-код LinkedHashMap.
boolean isEmpty(): проверяет, пуст ли LinkedHashMap.
Set<K> keySet(): возвращает набор всех ключей в LinkedHashMap.
V put(K key, V value): связывает указанное значение с указанным ключом в LinkedHashMap. Если ключ уже существует, то заменяет предыдущее значение новым и возвращает старое значение.
void putAll(Map<? extends K,? extends V> m): копирует все отображения из указанной Map в LinkedHashMap.
V remove(Object key): удаляет отображение, связанное с указанным ключом, из LinkedHashMap и возвращает связанное значение. Если такого ключа нет, то возвращает null.
int size(): возвращает количество отображений в LinkedHashMap.
Collection<V> values(): возвращает коллекцию всех значений в LinkedHashMap в порядке их вставки.


removeEldestEntry(Map.Entry<K,V> eldest) - это метод, который используется для настройки стратегии удаления элементов при вставке новых элементов в LinkedHashMap. Он вызывается после каждой операции добавления элемента и позволяет определить, нужно ли удалить старый элемент из LinkedHashMap.
Метод по умолчанию всегда возвращает false, что означает, что элемент не будет удален. Если мы хотим изменить эту стратегию, мы можем переопределить этот метод в нашем классе-потомке LinkedHashMap.
Например, мы можем создать LinkedHashMap с емкостью 3 и настроить его на удаление старых элементов, когда количество элементов достигнет 3:
java
Copy code
LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(3, 0.75f, true) {
    protected boolean removeEldestEntry(Map.Entry<String, Integer> eldest) {
        return size() > 3;
    }
};
В этом примере мы переопределили метод removeEldestEntry так, чтобы он возвращал true, если размер карты больше 3, что означает, что старый элемент будет удален.



TreeMap - это реализация интерфейса Map, которая хранит ключи в отсортированном порядке. Каждый элемент в TreeMap представляет пару "ключ-значение", где ключ используется для доступа к соответствующему значению.
По умолчанию, TreeMap использует естественный порядок сортировки ключей. Если ключи являются числами, то они сортируются в порядке возрастания. Если ключи являются строками, то они сортируются в лексикографическом порядке.

Например, если в TreeMap хранятся числовые ключи 1, 3, 2, 5, 4, то они будут отсортированы в порядке возрастания: 1, 2, 3, 4, 5. А если в TreeMap хранятся строковые ключи "cat", "apple", "dog", "banana", то они будут отсортированы в лексикографическом порядке: "apple", "banana", "cat", "dog".

В случае, если нужно использовать свой порядок сортировки, можно передать в конструктор TreeMap компаратор, который определяет порядок сортировки ключей.
Лексикографический порядок - это порядок сортировки символов в строке, когда каждый символ рассматривается по очереди, начиная с первого, и сравнивается с соответствующим символом в другой строке. Если символы равны, сравниваются следующие символы, и так далее, до тех пор, пока не будет найден первый символ, который отличается в двух строках. В этом случае меньшей считается строка, у которой символ на соответствующей позиции меньше. Например, строки "abc" и "abd" будут отсортированы в порядке "abc", "abd", потому что символ "c" меньше символа "d".




Внутренне TreeMap использует структуру красно-черного дерева для хранения элементов. При добавлении элементов в TreeMap, они автоматически сортируются по ключу. Это позволяет быстро выполнять операции поиска, вставки и удаления элементов, так как каждый узел в дереве имеет двух потомков, и сложность этих операций зависит от высоты дерева.



TreeMap поддерживает все методы Map, включая добавление элементов put(), получение элементов по ключу get(), удаление элементов remove(), проверка наличия ключа containsKey(), получение размера size(), очистка clear(), а также возможность получить набор всех ключей keySet() и набор всех значений values().

Однако, кроме этого, TreeMap также предоставляет ряд дополнительных методов, таких как:

firstKey(): возвращает наименьший ключ в TreeMap.
lastKey(): возвращает наибольший ключ в TreeMap.
ceilingKey(K key): возвращает наименьший ключ, который больше или равен заданному ключу.
floorKey(K key): возвращает наибольший ключ, который меньше или равен заданному ключу.
higherKey(K key): возвращает наименьший ключ, который больше заданного ключа.
lowerKey(K key): возвращает наибольший ключ, который меньше заданного ключа.
TreeMap также позволяет определять компаратор для ключей, что позволяет производить сортировку в пользовательском порядке. Компаратор может быть передан в конструктор TreeMap или установлен с помощью метода comparator(). Если компаратор не задан, то элементы сортируются в естественном порядке ключей.

"Структура красно-черного дерева" - это один из видов бинарных деревьев поиска, который имеет следующие свойства:

Каждый узел дерева окрашен в красный или черный цвет.
Корень дерева всегда окрашен в черный цвет.
Листья (внешние узлы) дерева всегда окрашены в черный цвет.
Если узел окрашен в красный цвет, то его родительский узел окрашен в черный цвет.
Все простые пути от узла до его листовых потомков содержат одинаковое количество черных узлов.
Красно-черное дерево позволяет эффективно хранить и оперировать данными, так как высота дерева ограничена и гарантировано логарифмическая.

TreeMap использует структуру красно-черного дерева для хранения ключей в отсортированном порядке. Красно-черное дерево позволяет быстро выполнять операции вставки, удаления и поиска элементов, а также позволяет поддерживать ключи в отсортированном порядке.
Красно-черное дерево - это бинарное дерево поиска, в котором каждый узел имеет цвет - либо красный, либо черный. Каждый узел содержит ключ и связанное с ним значение. Красно-черное дерево является сбалансированным деревом, что означает, что высота поддерева с корнем в любом узле отличается не более чем в два раза.

В TreeMap каждый узел представляет собой объект, содержащий три поля: ключ, значение и цвет. Цвет может быть либо красным, либо черным. Все листья дерева (null-узлы) являются черными. Каждый красный узел имеет двух черных потомков, а каждый путь от корня до листа содержит одинаковое число черных узлов.

Добавление, удаление и поиск элементов в TreeMap выполняется за время O(log n), где n - число элементов в дереве. Благодаря использованию красно-черного дерева, TreeMap гарантирует, что элементы будут храниться в отсортированном порядке по ключу.

Ключи в TreeMap должны реализовывать интерфейс Comparable или передаваться в конструктор TreeMap с использованием объекта Comparator, который будет использоваться для сравнения ключей. Это необходимо для упорядочивания элементов в дереве.
Цвет узла красно-черного дерева зависит от его свойств и положения в дереве.

Каждый узел дерева может иметь один из двух цветов: красный или черный. Корень дерева всегда черный. Все листья дерева, т.е. те узлы, которые не имеют потомков, также являются черными. Если узел красный, то его дочерние узлы должны быть черными.

При вставке нового элемента в красно-черное дерево, его место находится в соответствии с обычными правилами бинарного дерева поиска, а затем, если необходимо, производятся повороты узлов и перекрашивание, чтобы сохранить свойства красно-черного дерева. Когда узел перекрашивается, его цвет меняется с черного на красный или с красного на черный, чтобы сохранить или восстановить свойства красно-черного дерева.

Цвета узлов используются для обеспечения баланса дерева и для обеспечения эффективного выполнения операций вставки, удаления и поиска. Красно-черное дерево является самобалансирующимся деревом, что означает, что его глубина всегда логарифмически зависит от числа узлов, что гарантирует быстрый доступ к элементам и быстрое выполнение операций.







    13. Отличие ArrayList от LinkedList?
Основное отличие этих коллекций - это организация вставки и удаления элементов.
У этого метода интересное поведение. Если ячейка уже занята, то элементы сдвигаются вправо, а не заменяются, как в массиве.


ArrayList и LinkedList - это две реализации интерфейса List в Java. Они оба представляют упорядоченную коллекцию элементов, которые могут дублироваться.

Однако, у них есть существенные отличия в том, как они хранят и управляют элементами.

ArrayList представляет собой динамический массив, который расширяется при необходимости добавления новых элементов. При создании ArrayList выделяется начальная емкость (capacity) массива, которую можно указать явно или использовать значение по умолчанию. Если емкости массива не хватает для добавления нового элемента, ArrayList автоматически расширяет массив и копирует все элементы в новый массив. Таким образом, доступ к элементам ArrayList осуществляется через индексы, а операции вставки и удаления элементов могут быть довольно медленными, если необходимо сдвинуть множество элементов в массиве.

LinkedList, с другой стороны, представляет собой связный список, где каждый элемент хранит ссылку на предыдущий и следующий элементы. Каждый элемент списка, называемый узлом (node), хранит данные и ссылки на предыдущий и следующий узлы. При вставке нового элемента в LinkedList, элемент просто добавляется в список и изменяются ссылки на соседние элементы. Удаление элемента также происходит быстро, поскольку не требуется сдвигать множество элементов в массиве.

Таким образом, ArrayList обычно эффективен для доступа к элементам по индексу и приложений с частыми операциями чтения, в то время как LinkedList хорошо подходит для операций вставки и удаления элементов в середине списка. Однако, если требуется часто выполнять операции вставки и удаления элементов в начале и конце списка, рекомендуется использовать другую структуру данных, такую как Deque или ArrayDeque, которые обеспечивают более эффективную работу с этими операциями.
Время выполнения различных операций для ArrayList и LinkedList может зависеть от различных факторов, таких как размер списка, тип операции и способ доступа к элементам.

В целом, доступ к элементам в ArrayList быстрее, чем в LinkedList, потому что ArrayList представляет собой непрерывный блок памяти, а доступ к элементам в LinkedList требует перехода между узлами списка. Однако, вставка и удаление элементов в середине списка быстрее для LinkedList, так как она не требует копирования большого количества элементов, как это может происходить в ArrayList.

Вот приблизительные времена выполнения операций для ArrayList и LinkedList:

Доступ к элементу по индексу: O(1) для ArrayList, O(n) для LinkedList.
Вставка или удаление элемента в конец списка: O(1) для ArrayList, O(1) для LinkedList.
Вставка или удаление элемента в середину списка: O(n) для ArrayList, O(1) для LinkedList.
Поиск элемента по значению: O(n) для ArrayList, O(n) для LinkedList.




















    14. Отличие Set от List?

Set и List - это два различных интерфейса коллекций в Java, каждый из которых имеет свои особенности и отличия.

Set - это коллекция, которая содержит уникальные элементы. Это означает, что каждый элемент в Set может появляться только один раз. Set не гарантирует порядок элементов, то есть элементы могут храниться в произвольном порядке.

List - это коллекция, которая содержит элементы в определенном порядке. Это означает, что порядок элементов в List определен и сохраняется. Элементы могут повторяться в List.

Основные отличия между Set и List:

Уникальность элементов: Set не содержит повторяющихся элементов, в то время как List может содержать одинаковые элементы.

Порядок элементов: порядок элементов в Set не гарантируется, в то время как порядок элементов в List сохраняется.

Использование итератора: при использовании итератора, порядок элементов в List сохраняется, в то время как порядок элементов в Set не гарантируется.

Использование метода contains(): для поиска элемента в Set используется метод contains(), который работает быстрее, чем в List, потому что в Set элементы хранятся в хэш-таблице.

Использование метода get(): в List для доступа к элементу используется метод get(), который работает быстрее, чем в Set, потому что элементы в List хранятся в массиве, и доступ к элементу осуществляется по индексу.


















    15. Расскажите про методы Object hashCode и equals?

«Что может охарактеризовать любую сущность в программировании?». Очевидно, что это число, т.к. в компьютере на низком уровне (на уровне машинного кода) работают именно с числами. Именно поэтому уже на уровне Object есть метод hashCode().
Тут встает другой вопрос. Как это число определить? Т.е. как из объекта сделать число? На этот вопрос нет точного ответа, именно поэтому метод hashCode() не имеет точно определенную реализацию.
С этими соображениями появилась структура данных, называемая ассоциативным массивом или словарем, т.е. массивом, хранящим пары (ключ, значение). По ключу мы производим операции, такие как вставка, обновление, удаление и т.д.
Ключ, разумеется, может быть объектом, и здесь как раз производится преобразование в число. Зачем? Мы используем массив, а чтобы получить доступ к элементу массива, нужно знать его индекс. Таким образом, задача сводится к вычислению индекса по ключу. Причем функция, которая производит это преобразование, называется хэш-функцией, а полученный индекс хэш-значением или «хэшем». В классическом в виде это выглядит так:
i = hash(key), где hash() –хэш-функция, key – исходный ключ, i – хэш
Схема:
    1. Вычисление хэш-кода через метод hashCode() у ключа
    2. Вычисление хэша через метод hash() в HashMap
    3. Вычисление позиции в таблице, на уровне мапы через оператор &
Это сделано намеренно, чтобы мапа работала независимо от того, какой ключ используется.
Таким образом, вычисление индекса выглядит так:
i = hash(hk) & (table.length - 1), где метод hash() - это метод hash() мапы, hk = key.hashCode(), i – это конечный индекс, по которому будет расположен объект.
Методы хэширования
1.	Метод деления
Самый простой способ. Берется просто остаток от деления от hk на length. Очевидно, что hk % length принадлежит диапазону [0, length - 1], следовательно попадает в диапазон допустимых индексов.
Например,
hk = 5, hk % length = 5 => объект попадет на позицию 5
hk = 31, hk % length = 15 => объект попадет на позицию 15
Пример означает, что для объекта с хэш-кодом 5 и длиной массива (или хэш-таблицы) равной 16, объект будет помещен в ячейку с индексом 5 (так как 5 % 16 = 5). Для объекта с хэш-кодом 31, он будет помещен в ячейку с индексом 15 (так как 31 % 16 = 15)
2. Метод серединных квадратов

Для использования метода серединных квадратов при вычислении хэш-кода, следует выполнить следующие шаги:

Преобразовать исходный ключ в числовое значение. Например, строку можно преобразовать в число, вычислив сумму кодов ASCII каждого символа строки.

Возвести полученное число в квадрат.

Выбрать центральные цифры полученного квадрата в соответствии с требуемой длиной хэш-кода.

Взять эти цифры в качестве хэш-кода.

Например, пусть исходный ключ - строка "hello", которую мы преобразуем в число, вычислив сумму кодов ASCII каждого символа:

104 + 101 + 108 + 108 + 111 = 532

Затем, мы возводим это число в квадрат:

532 * 532 = 282,624

Далее, выбираем центральные цифры полученного квадрата длиной, скажем, 3 цифры:

2|82|,624

Наконец, берем эти цифры в качестве хэш-кода: 826.

Обратите внимание, что при использовании метода серединных квадратов необходимо выбирать размер хэш-таблицы таким образом, чтобы количество цифр в хэш-коде было достаточным для избежания коллизий. Кроме того, не рекомендуется использовать этот метод для генерации хэш-кодов для больших объемов данных, так как при повторном использовании одних и тех же значений ключей в алгоритме, может возникнуть периодичность в генерируемых значениях хэш-кодов, что приведет к увеличению количества коллизий.


Однако, метод деления может приводить к коллизиям, когда разные объекты имеют одинаковый хэш-код и попадают в одну и ту же ячейку хэш-таблицы. Для уменьшения количества коллизий можно выбрать другой алгоритм вычисления хэш-кода, например, метод умножения или метод сложения.
3. Метод hash() из HashMap
Метод hash() является внутренним методом класса HashMap и используется для вычисления хеш-кода ключа объекта. Он не предназначен для использования напрямую в пользовательском коде, а только для внутреннего использования в реализации HashMap.

Алгоритм метода hash() является комбинацией нескольких шагов. Сначала вызывается метод hashCode() для ключа, который возвращает исходный хеш-код. Затем этот хеш-код проходит через функцию сдвига и побитового исключающего ИЛИ (XOR) с его собственным сдвигом. Это делается для того, чтобы уменьшить количество коллизий, когда несколько ключей имеют одинаковый хеш-код. Затем полученный хеш-код снова проходит через функцию сдвига и побитового исключающего ИЛИ с его собственным сдвигом, а также с номером корзины (bucket) в HashMap, в которую он будет помещен.

Этот алгоритм может быть довольно эффективным для вычисления хеш-кода, но его основное преимущество заключается в том, что он уменьшает количество коллизий в HashMap.
-----------------------------------------------------------------------------------------------------------------------------

Вы обязаны перекрывать hashCode в каждом классе, перекрывающем equals. Если это не сделать, ваш класс будет нарушать общий контракт hashCode, что не позволит ему корректно работать с коллекциями, такими как HashMap и HashSet. Вот как выглядит этот контракт, взятый из спецификации Object.
• Во время выполнения приложения при многократном вызове для одного и того же объекта метод hashCode должен всегда возвращать одно и то же целое число при условии, что никакая информация, используемая при сравнении этого объекта с другими методом equals, не изменилась. Однако не требуется, чтобы это же значение оставалось тем же при другом выполнении приложения.
 • Если два объекта равны согласно результату работы equals (Object), то при вызове для каждого из них метода hashCode должны получиться одинаковые целочисленные значения.
• Если метод equals (Ob j ect) утверждает, что два объекта не равны один другому, это не означает, что метод hashCode возвратит для них разные числа. Однако программист должен понимать, что генерация разных чисел для неравных объектов может повысить производительность хеш-таблиц.

 Главным условием при перекрытии метода hashCode является второе: равные объекты должны давать одинаковый хеш-код. Два различных экземпляра с точки зрения метода equals могут быть логически эквивалентными, однако для метода hashCode класса Object оказаться всего лишь двумя объектами, не имеющими между собой ничего общего. Поэтому метод hashCode, скорее всего, возвратит для этих объектов два кажущихся случайными числа, а не два одинаковых, как того требует контракт.

Действительно, Джошуа Блох в своей книге "Effective Java" рекомендует следующие принципы для переопределения метода hashCode():

Всегда используйте одни и те же поля для вычисления hashCode() и equals().
 Если поле участвует в вычислении equals(), то оно должно участвовать и в вычислении hashCode().
Выберите изначальное значение (называемое seed), например, число 17, и сохраните его в локальной переменной. Затем для каждого поля класса вычислите хэш-код и объедините его с seed путем вычисления следующего выражения: result = 31 * result + fieldHashCode. Это даст хорошее распределение хэш-кодов при работе с хэш-таблицами.

Если класс является неизменяемым, вычислите хэш-код один раз при создании объекта и сохраните его в локальной переменной. После этого просто возвращайте сохраненное значение при каждом вызове hashCode(). Это повышает производительность.
Если класс является изменяемым, необходимо пересчитывать хэш-код при каждом изменении состояния объекта. Если класс наследуется от другого класса, переопределите метод hashCode() и там же вызовите super.hashCode(), чтобы учесть состояние родительского класса.
Переопределяйте hashCode() только тогда, когда класс переопределяет equals(). Если класс не переопределяет equals(), то и hashCode() использовать не нужно.
Эти принципы помогут избежать ошибок при работе с хэш-таблицами и сделать переопределение метода hashCode() корректным.

------------------------------------------------------------------
Методы hashCode() и equals() являются двумя основными методами класса Object в Java. Они используются для сравнения объектов и хранения объектов в коллекциях, таких как HashMap, HashSet и других.
Метод equals():
Метод equals() используется для сравнения двух объектов на равенство. Этот метод имеет следующую сигнатуру:

public boolean equals(Object obj)
Метод принимает объект типа Object и возвращает true, если объект, для которого вызывается метод equals(), равен объекту, переданному в качестве аргумента. Важно понимать, что метод equals() должен быть корректно переопределен в пользовательских классах.

Правильная реализация метода equals() должна удовлетворять следующим условиям:

Рефлексивность: a.equals(a) должен возвращать true, то есть объект должен быть равен самому себе.
Симметричность: a.equals(b) должен возвращать то же самое значение, что и b.equals(a), то есть если a равен b, то b должен быть равен a.
Транзитивность: если a.equals(b) возвращает true и b.equals(c) возвращает true, то a.equals(c) должен возвращать true.
Консистентность: если никакие изменения не вносятся в объекты, которые сравниваются, то метод equals() всегда должен возвращать одинаковое значение.
null не должен вызывать ошибку: a.equals(null) должен возвращать false.
Метод hashCode() возвращает целочисленное значение, которое представляет хэш-код объекта. Этот метод имеет следующую сигнатуру:

public int hashCode()
Хэш-код используется для оптимизации работы с коллекциями. В хэш-таблицах объекты хранятся по их хэш-кодам. Если объекты имеют разные хэш-коды, они будут храниться в разных ячейках таблицы, что ускоряет поиск объектов.
Правильная реализация метода hashCode() должна удовлетворять следующим условиям:
Если a.equals(b) возвращает true, то a.hashCode() и b.hashCode() должны возвращать одинаковое значение.
Если a.equals(b) возвращает false, то a.hashCode() и b.hashCode() могут возвращать разные значения, но это не обязательно.
Хорошей практикой является переопределение методов equals() и hashCode() в пользовательских класса
---------------------------------------------------------------------------
В дополнение к основным принципам, которые я уже описал, есть несколько дополнительных вещей, которые полезно знать о методах equals() и hashCode():

Метод equals() должен проверять тип объекта перед сравнением. Если объекты не являются одного и того же типа, они не могут быть равными.

Реализация метода hashCode() должна быть эффективной. Хэш-код объекта должен быть вычислен на основе его состояния, и это вычисление должно быть быстрым и не занимать слишком много памяти.

Если вы переопределяете метод equals(), вы также должны переопределить метод hashCode(). Если вы не сделаете этого, объекты могут быть помещены в коллекции, которые используют хэш-коды для быстрого поиска, и они могут не работать должным образом.

Хэш-коды должны быть стабильными в течение жизненного цикла объекта. Если изменится состояние объекта, его хэш-код должен измениться.

В Java 7 и более поздних версиях класс Objects содержит метод equals() и hashCode(), которые облегчают переопределение этих методов в пользовательских классах.

При работе с неизменяемыми объектами (immutable objects) вы можете вычислить хэш-код один раз и затем кэшировать его, чтобы избежать повторных вычислений.

Важно помнить, что равенство объектов и их хэш-коды являются двумя отдельными концепциями. Два объекта могут иметь разные хэш-коды, но быть равными, и наоборот.

-----------------------------------------------------------------------------------------------------------------
Важно выбирать правильный алгоритм для вычисления хэш-кода, чтобы избежать коллизий (ситуации, когда два разных объекта имеют одинаковый хэш-код). Хорошим выбором может быть использование простых арифметических операций, таких как сложение и умножение, с учетом особенностей конкретного класса.

Если класс содержит много полей, которые участвуют в вычислении хэш-кода и сравнении методом equals(), может быть полезно использовать автоматическое сгенерированное переопределение методов equals() и hashCode() с помощью IDE (интегрированной среды разработки), чтобы избежать ошибок.

При реализации методов equals() и hashCode() важно следить за соблюдением контракта, который описывает их взаимодействие друг с другом и с другими частями языка Java.

Некоторые классы, такие как String и Integer, уже имеют корректно реализованные методы equals() и hashCode(), поэтому нет необходимости переопределять их в пользовательских классах, если они не добавляют нового поведения.

При работе с коллекциями объектов, такими как HashSet и HashMap, важно помнить, что изменение объекта, который был добавлен в коллекцию, может нарушить инварианты коллекции и привести к непредсказуемому поведению. Поэтому изменяемые объекты должны быть использованы с осторожностью.
--------------------------------------------------------------------
Да, дополнительно можно упомянуть следующее:

При переопределении метода equals() следует учитывать особенности работы с null-ссылками. Так, например, равенство ссылок на null-объект должно быть обязательным условием для метода equals(), а также следует проверять на null-ссылки перед вызовом методов equals() у полей объекта.

Хэш-коды должны быть по возможности уникальными, чтобы сократить вероятность коллизий, но они не должны быть слишком сложными или медленными в вычислении. Использование хэш-кода объекта для индексации в HashMap или HashSet требует вычисления хэш-кода на каждый элемент в коллекции, поэтому лучше, если это будет быстро.

Если в классе не все поля должны участвовать в сравнении и вычислении хэш-кода, можно использовать аннотации @EqualsAndHashCode и @EqualsAndHashCode.Exclude библиотеки Lombok для автоматической генерации методов equals() и hashCode(), и исключения из них определенных полей.

Методы equals() и hashCode() также используются при сортировке объектов в списке или массиве. Для корректной сортировки объектов необходимо переопределить метод compareTo(), который используется при вызове метода Arrays.sort() или при добавлении элементов в TreeSet.

Важно следить за тем, чтобы при изменении состояния объекта не изменялось значение его хэш-кода. В противном случае, объект может потеряться в коллекции, где он был добавлен, что может привести к серьезным проблемам. Хорошим подходом может быть использование неизменяемых (immutable) объектов, которые гарантированно не будут изменять свое состояние.





    16. Расскажите, что такое коллизии в Map? Как с ними бороться?
Способы разрешения коллизий
Несмотря на то, что хэш функция может быть «хорошей», могут возникать коллизии. Коллизия - эта такая ситуация, при которой для двух разных (что значит разный или одинаковый, поговорим позже) объектов (ключей) мы получаем один и тот же бакет.
Рассмотрим, относительно чего бывают коллизии. Давайте еще раз вспомним, что происходит при добавлении в HashMap
1. Вычисляется hashCode()
2. Вычисляется значение хэш функции методом hash() в мапе
3. Получается индекс hash & (table.length - 1)
Очевидно, что на каждом из этих шагов выполняются арифметические операции => могу возникнуть коллизии => могут быть следующие причины коллизий:
1. относительно получения индекса, т.е. относительно оператора &. Например, если h1 = 1 и h2 = 17, h1 & 15 == h2 & 15
2. относительно hash() функции. Например, если хэш функция это сумма цифр, то hash(123) == hash(321). Это причина повлечет за собой коллизию как в случае 1
3. относительно hashCode(). Например, o1.hashCode() == o2.hasCode(). Это причина повлечет за собой коллизию как в случае 2
Если получение индекса мы изменить не можем, то hash() и hashCode() нам подвластны. Поэтому особое внимание уделяют этим методам.
Во избежание потери данных, нам нужно что-то делать в этой ситуации. Алгоритмы действий в этой ситуации называются методами разрешения коллизий. Они бывают следующие:
1. Открытая адресация. Здесь есть несколько способов. Рассмотрим самый простой – линейное пробирование.
Например, мы получили хэш i и оказалось, что это место занято. В этом случае делается следующее: запускается цикл и просматриваются ячейки, индексы которых вычисляются как ( h + ik ) % length, где h – исходный хэш, k - фиксированный интервал между ячейками (обычно равен 1), i - (i)ный элемент последовательности проб, а length – это размер таблицы
2. Метод цепочек
У открытой адресации есть недостатки - возможна потеря данных, т.к. возможно зацикливание, поэтому число проб ограничивают. Если сделать его большим, то программа будет работать дольше, а если малым, то возможно, что вставка не произойдет
Как альтернатива существует метод цепочек. Этот метод основан на связных списках, т.е. вместо вставки самих данных напрямую, вставка идет в список, который хранится по хэшу. В случае коллизии элемент просто вставляется в конец списка.
Из всего этого следует, что у нас есть массив связных списков. Отдельно взятый список называют бакетом.
Тут же стоит упомянуть про фактор загрузки (load factor) – это такое число, которое показывает при какой пропорции количества элементов на размер таблицы стоит ее расширять. Оптимальным считается 0.75.
Например, count – число элементов, capacity – размер таблицы
count / capacity >= 0.75 => нужно расширять таблицы
count / capacity < 0.75 => не нужно расширять, продолжаем заполнять
Замена или добавление?
Вы знаете, что в мапе могут быть только уникальные ключи, и если мы добавляем по идентичному ключу, то происходит замена значения.
Если взглянуть в метод добавления, то можно увидеть, что мы всегда вычисляем конечный индекс бакета. В случае замены, происходит коллизия. Тут нам нужно пройтись по всем узлам бакета и проверить если такой у которого ключ равен по equals() с исходным ключом. Если таковой не найден, то происходит добавление дальше в бакет
Важно! Перед проверкой по equals() делается проверка по хэшу. Зачем? Т.к. из o1.hashCode() == o2.hashCode() => hash(o1.hashCode()) == hash(o2.hashCode()) => если объекты равны по хэш-кодам, то они и равны по хэшам. Причем, если объекты не равны по хэшам, то они не равны вообще (по контракту между equals() & hashCode() и из умозаключения сделанного ранее), а т.к. значения хэшей уже вычислено, то целесообразно сравнить быстро по ним и только потом если они равны сравнить по equals().
Расширение контейнера
Как было сказано ранее, фактор загрузки показывает максимальное количество элементов, которое может содержать таблица данного размера. При превышении данного соотношения нужно расширять контейнер. Фактор загрузки ввели для того, чтобы понизить число коллизий.
Итак, нам нужно расширить контейнер. Как мы можем поступить?
Может использовать Arrays.copyOf(), как мы это делали для динамических массивов, ведь хэш-таблица тоже массив? Нет, так делать нельзя. Давайте разберемся почему.
Пусть размер таблицы 5. Хэш функция задана как остаток от деления.
К примеру, мы добавляем ключ с хэш-кодом 6. Где разместить объект? 6 % 5 = 1, т.е. под индексом 1. Далее мы добавляем другие объекты.
Допустим, пришло время расширить контейнер. Пусть мы расширяем его в два раза, используя Arrays.copyOf(). Теперь размер таблицы 10. Что произойдет? Часть таблицы, которую заполнили ранее, окажется в левой части массива, а новое пространство справа.
Теперь давайте попробуем получить объект по ключу, по которому добавляли первый раз. 6 % 10 = 6. Мы получаем совершенно другой хэш, ведь у нас данный объект разместился под хэшем 1. Теряется соответствие между ключом и получаемым значением. Поэтому Arrays.copyOf() не допустимо использовать для хэш-таблицы, потому что хэш зависит от размера таблицы.
Как же тогда расширять? Делается так называемое «рехэширование». Создается новая пустая таблица. Мы проходим по старой таблице и добавляем в новую уже по новому хэшу, полученному по новому размеру таблицы.
Коллизии при получении/удалении
Часто, говоря о хэш-таблице, мы упоминаем про коллизии только в методе добавления. НО коллизии возникают не только в нем.
К примеру, есть таблица размера 5, хэш-функция задана как остаток от деления. Мы добавляем по ключу с хеш-кодом 1. Куда попадет объект? Под хэш 1, т.к. 1 % 5 = 1. Теперь давайте попробуем получить объект по ключу с хеш-кодом 6. 6 % 5 = 1. Как видим, мы попадаем в ту же ячейку. Но ключи разные. Это и есть коллизия. Поэтому в мапе при получении/удалении сначала делается проверка по хэш значению, а затем по equals(). Эти проверки обязательны, иначе можно получить/удалить не тот объект.
Хэш-код и equals
Существует контракт. Если переопределен hashCode(), то нужно обязательно переопределить equals(). Почему? Дело в том, что может показаться, что мы можем сравнивать объекты на равенство по hashCode(), но это заблуждение:
Например,
Первый хэш вычислен так 1 + 3
Второй хэш вычислен так 2 + 2
Оба равны 4, тем не менее содержимое первого и второго объектов разное.
Здесь есть такие правила:
•	Если объекты равны по hashCode(), то они не обязательно равны по equals()
•	Если объекты равны по equals(), то они обязательно равны по hashCode()
•	Если объект не равны по hashCode(), то они точно не равны по equals()
•	Если объекты не равны по equals(), то возможно совпадение их hashCode()
Блок-схема
Получаем хэш-код ключа, используя метод hashCode()


Вычисляем хэш от полученного значения с помощью хэш-функции:
Определяем индекс бакета, куда будет помещен элемент:
Используется оператор & для того, чтобы получить остаток от деления хэш-кода на размер таблицы.





Проверяем, что бакет пустой или равен null:
if (table[i] == null) {
    // Создаем новый узел
    // ...
    table[i] = newNode;
}

Если бакет не пустой, то проходим по всем узлам в цепочке и проверяем, есть ли элемент с таким же ключом:
Node<K,V> e = table[i];
while (e != null) {
    if (e.hash == hash && (e.key == key || key.equals(e.key))) {
        // Элемент уже существует, заменяем его значение
        // ...
        return oldValue;
    }
    e = e.next;
}
Если элемент существует, то мы заменяем его значение и возвращаем старое значение.

Если же найден узел с таким же ключом, то его значение заменяется новым значением и добавляется в конец списка связанных узлов.

Если узел не найден, то проверяется, есть ли еще узел в списке связанных узлов. Если есть, то процесс повторяется для следующего узла в списке. Если нет, то новый узел добавляется в конец списка связанных узлов.

Если коэффициент загрузки таблицы достигает значения 0,75 или более, то производится перехэширование таблицы с увеличением ее размера вдвое. При перехэшировании все узлы из старой таблицы копируются в новую таблицу с учетом новой функции хеширования.

Таким образом, метод put() в HashMap осуществляет добавление пары ключ-значение в таблицу, используя хеш-функцию для определения индекса бакета, в котором хранятся связанные узлы с данным хешем. При этом производится проверка на наличие уже существующего узла с таким же ключом и его замена или добавление нового узла в конец списка связанных узлов. При достижении коэффициента загрузки таблицы 0,75 или более производится перехэширование с увеличением размера таблицы.








public V put(K key, V value) {
    // Преобразуем ключ в хэш-код
    int h = key.hashCode();
    // Вычисляем хэш ключа с помощью хэш-функции
    int hash = hash(h);
    // Определяем индекс бакета в массиве с помощью оператора &
    int i = indexFor(hash, table.length);
    // Проверяем, есть ли уже элемент с таким же ключом в бакете
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            // Если такой элемент уже есть, заменяем его значение на новое
            V oldValue = e.value;
            e.value = value;
            return oldValue;
        }
    }
    // Если элемента с таким ключом нет, создаем новый и добавляем его в бакет
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
Конец метода put() в HashMap:
Если мы не нашли ноду с ключом key в списке связанных нод, то создаем новую ноду с ключом и значением, и добавляем ее в конец списка связанных нод.
Увеличиваем размер карты (size) на 1.
Если после добавления новой ноды размер карты превысил загрузочный фактор (load factor), то вызываем метод resize() для увеличения размера массива бакетов и рехеширования существующих элементов.
Возвращаем null, т.к. в HashMap не было ранее значения, связанного с ключом key.

 Без переопределения equals и hashCode
1.	В классе User не переопределять методы equals() и hasCode();
2.	Создать два объекта User, которые имеют одинаковые значения полей.
3.	Создать карту Map<User, Object>
4.	Добавить две пары: key1:value1 и key2:value2. В качестве ключей использовать объекты User из пункта 2, а в качестве значения new Object(). Вывести карту на печать. Описать полученный результат словами.
5.	Ответить на вопросы:
        5.1. Пары попали в один бакет или в разные?
        5.2. Производилась ли проверка ключей key1 и key2 на равенство их хэш-кодов? Объясните, почему.
        5.3. Производилась ли проверка ключей key1 и key2 на равенство через метод equals()? Объясните, почему.
Объясните полученный результат почему так получилось.

Ответы на вопросы:

5.1. Пары, скорее всего, попали в разные бакеты. Без переопределения методов equals() и hashCode() для класса User будет использоваться реализация по умолчанию, которая базируется на уникальности объектов, а не на их содержимом. Поэтому, даже если объекты User имеют одинаковые значения полей, для них будут созданы разные хэш-коды, что приведет к распределению пар по разным бакетам.

5.2. Проверка ключей key1 и key2 на равенство их хэш-кодов не производилась, потому что при добавлении пары в Map происходит сначала вычисление хэш-кода ключа, затем поиск подходящего бакета по этому хэш-коду. После этого происходит добавление пары в выбранный бакет, без каких-либо дополнительных проверок.

5.3. Проверка ключей key1 и key2 на равенство через метод equals() также не производилась, по той же причине, что и в предыдущем ответе - при добавлении пары в Map используется только хэш-код ключа, а не сам ключ. Кроме того, без переопределения метода equals() для класса User сравнение объектов по значению полей не будет работать корректно, даже если бы было произведено сравнение по ключам.

Полученный результат скорее всего будет выглядеть так:
{User@1db9742d=java.lang.Object@3a71f4dd, User@3d494fbf=java.lang.Object@5e481248}

Это означает, что в Map были добавлены две пары, где ключами были объекты User, имеющие разные адреса в памяти, а значениями - новые объекты класса Object, имеющие тоже разные адреса в памяти. Поскольку методы equals() и hashCode() для класса User не были переопределены, то при вычислении хэш-кодов ключей использовалась реализация по умолчанию, которая основывается на уникальности объектов, а не на содержимом их полей. Поэтому объекты User, имеющие одинаковые значения полей, могут иметь разные хэш-коды, что приводит к размещению пар в разные бакеты.

 Переопределить только hashCode
1.	Переопределить в классе User метод hashCode(), метод equals() не переопределять.
2.	Создать два объекта User, которые имеют одинаковые поля. Убедитесь что вы передаете одну и ту же дату рождения, вплоть до миллисекунд.
3.	Создать карту Map<User, Object>
4.	Добавить две пары: key1:value1 и key2:value2. В качестве ключей использовать объекты User из пункта 2, а в качестве значения new Object().
5.	Вывести карту на печать. Описать полученный результат словами.
6.	Ответить на вопросы:
        6.1. Пары попали в один бакет или в разные?
        6.2. Производилась ли проверка ключей key1 и key2 на равенство их хэш-кодов? Объясните, почему.
        6.3. Производилась ли проверка ключей key1 и key2 на равенство через метод equals()? Объясните, почему.
Объясните полученный результат почему так получилось.
При переопределении только метода hashCode у двух объектов User значения hashCode становятся одинаковыми, что приводит к тому, что объекты попадают в один бакет в HashMap. При добавлении двух пар (ключ:значение) в карту Map, ключи key1 и key2 будут иметь одинаковые значения hashCode, поэтому компилятор будет проверять их на равенство, вызывая метод equals(), но так как метод equals() в классе User не переопределен, то сравнение будет производиться по умолчанию - по ссылке на объект, а не по значениям его полей. Таким образом, пары попадут в один бакет и будут находиться в одном списке элементов в этом бакете.

Итак, ответы на вопросы:

6.1. Пары попали в один бакет.

6.2. Да, производилась проверка ключей key1 и key2 на равенство их hashCode, потому что при добавлении в HashMap ключи с одинаковым hashCode будут сравниваться на равенство, вызывая метод equals().

6.3. Да, производилась проверка ключей key1 и key2 на равенство через метод equals(). Однако, по умолчанию метод equals() сравнивает объекты по ссылке, а не по значению полей, так как в классе User он не переопределен.

--------------------------------------------------------------------------------------------------------------

 Переопределить только equals

1.	В классе User переопределить только метод equals(), метод hasCode() не переопределять.
2.	Создать два объекта User, которые имеют одинаковые значения полей.
3.	Создать карту Map<User, Object>
4.	Добавить две пары: key1:value1 и key2:value2. В качестве ключей использовать объекты User из пункта 2, а в качестве значения new Object(). Вывести карту на печать. Описать полученный результат словами.
5.	Ответить на вопросы:
 5.1. Пары попали в один бакет или в разные?
 5.2. Производилась ли проверка ключей key1 и key2 на равенство их хэш-кодов? Объясните, почему.
 5.3. Производилась ли проверка ключей key1 и key2 на равенство через метод equals()? Объясните, почему.
При этом метод hashCode остается не переопределенным.
После добавления двух пар ключ-значение, содержащих объекты User с одинаковыми значениями полей, они попали в разные бакеты, так как используется хеш-код объекта по умолчанию, который вычисляется на основе адреса объекта в памяти, и он для двух разных объектов всегда разный, даже если их поля равны.

Проверка на равенство хеш-кодов key1 и key2 не производилась, так как при использовании хеш-кода по умолчанию для объектов User, они будут разными, даже если их поля равны.

Проверка на равенство ключей key1 и key2 через метод equals() производилась, так как при использовании объектов User в качестве ключей в карту, сначала вычисляется их хеш-код, а затем производится сравнение ключей. В данном случае хеш-коды разные, поэтому сравнение происходит по методу equals(). Так как метод equals() был переопределен только в классе User, то сравнение полей объектов производится корректно и пары ключ-значение будут добавлены в карту, хотя объекты User, на которые они ссылаются, имеют одинаковые поля.






Переопределить и equals и hashCode
В классе User переопределен equals() и hashCode().Хеш - коды объектов стали одинаковыми. При put() объектов в map, происходит сравнение объектов по хеш - коду.
Так как хеш-коды одинаковые у объектов,
это приводит к коллизии => механизм решения коллизии, где элемент,который добавлется,срвнивается с первым элементом списка в бакете. Хеши ключей объектов одинаковые,далее сравниваются ключи по ссылке, которые у объектов разные, и сравниваются через equals(), который переопределен.
Это значит что сравнение будет происходит по полям объектов, а поля одинаковые. Компилятор при вызове hashCode() и equals() определяет два объекта как один и тот же и перезаписывает его в один бакет.
 Коллизии Map
Задание.
1. В  комментарии распишите про коллизии в Hashtable структурах и как они разрешаются в Java.
2. Ответить на вопросы:
2.1. Коллизия может возникнут при 3 условиях (относительно hash(), относительно hashCode(), и относительно вычисления индекса).
Заключим их в двух ситуациях, например, пусть размер таблицы равен size и есть два объекта O1 и O2
1)	(hash(O1.hashcode()) % size) == (hash(O2.hashcode()) % size), причем hash(O1.hashcode()) == hash(O2.hashcode()
Это условие говорит о том, что у объектов O1 и O2 одинаковые хеш-коды, что вызывает коллизию при попытке добавления их в HashMap
Выражение hash(O1.hashcode()) % size означает, что бакет для объекта O1 выбирается с помощью вычисления остатка от деления хеш-кода объекта O1 на размерность таблицы хешей (size). Аналогично, для объекта O2 выбирается бакет, используя ту же формулу.
Если эти выражения дают одинаковый результат (т.е. объекты попадают в один и тот же бакет), то происходит коллизия. В этом случае HashMap должен использовать механизм разрешения коллизий, чтобы разрешить, какой из объектов должен быть помещен в бакет.
Выражение hash(O1.hashcode()) == hash(O2.hashcode()) проверяет, имеют ли объекты одинаковый хеш-код, что вызывает коллизию.
2)	(hash(O1.hashcode()) % size) == (hash(O2.hashcode()) % size), причем hash(O1.hashcode()) != hash(O2.hashcode())



Это означает, что у объектов O1 и O2 разные хеш-коды, но при вычислении индексов корзин, в которые они будут помещены, произошла коллизия. То есть они попали в одну и ту же корзину, так как остатки от деления их хеш-кодов на размер массива корзин (size) совпали. Это может привести к необходимости сравнения объектов методом equals() в процессе поиска значения в этой корзине.

Отсюда возникают следующие вопросы, на которые вам нужно ответить:
1) Объяснить почему делается в первую очередь эта проверка в мапе

2) Что будет в ситуации первой? Замена или вставка?
3) Что будет в ситуации второй? Замена или вставка?
2.2. При увеличении размера HashMap во что преобразовываются списки в бакетах? Начиная с какой версии Java происходит такое преобразование в бакетах? Что достигается этим преобразованием?
Ответ:
 	1) в if прописана проверка ключей сначала по хэш - коду, который вернет false? иначе сравниваются ключи по ссылке и в случаи неравенства , ключи проверяются по equals.Такой порядок более производителен.
2)  (hash(O1.hashcode()) % size) == (hash(O2.hashcode()) % size), причем hash(O1.hashcode()) == hash(O2.hashcode()) -  если хеш-коды одинаковые, то проверка  01 и 02 осуществляется по equals(). И в бакет старый эл. заменяется новым. А если объекты разные по equals() то эл. вставляется в конец связанного списка.
3) (hash(O1.hashcode()) % size) == (hash(O2.hashcode()) % size), причем hash(O1.hashcode()) != hash(O2.hashcode()) - хеш - коды разные, и согласно правилу, по equals() они не равны, значит эл. вставляется в хвост связанного списка.
2.2 При увеличении размера HashMap происходит перехеширование (rehashing) всех элементов внутри этой хэш-таблицы. Это означает, что все элементы в текущей таблице будут помещены в новую, большую таблицу. При этом размер каждого бакета в новой таблице увеличивается вдвое, а элементы из старых бакетов распределяются в новые бакеты в соответствии с их новыми хэш-кодами
В результате, если в старой таблице было много элементов, которые попадали в один бакет, то при увеличении размера таблицы эти элементы будут распределены по нескольким новым бакетам, что позволит избежать коллизий и ускорит работу HashMap в дальнейшем.
Преобразование списков в бакетах при увеличении размера HashMap происходит начиная с версии Java 8.

До версии Java 8 при увеличении размера HashMap создавалась новая таблица с большим размером, а затем все элементы из старой таблицы копировались в новую таблицу. Это было неэффективно по памяти и времени.

В Java 8 была введена оптимизация, которая позволяет перестроить таблицу без копирования всех элементов. Вместо этого, каждый бакет старой таблицы становится списком, а затем все списки объединяются в один большой список, который затем распределяется по новым бакетам в новой таблице. Это позволяет увеличивать размер HashMap более эффективно и снижает накладные расходы на создание новой таблицы.
 Как вычисляются hashCode у объекта
1. В этой задаче нужно рассказать - как правильно вычислять hashCode у объекта.
2. Рассказать, как вычисляется hash функция в HashMap. Объяснить для чего используются или могут быть использованы операторы %, &, >>>
1. У объетов hashCode вычисляется по полям.
- метод hasCode для одного и того же объекта должен возвращать
одно и то же хеш,при условии что поля объетка не изменялись.
-  метод hashCode для двух объетов должен возвращать одно и то же число,если объекты равны.
-  если объекты не равны между собой, то hashCode возвращает разные значение хеш.

2. Функция hash в HashMap выглядит следующим образом:
 static final int hash(Object key){
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

Это метод для вычисления хеш-кода объекта, который используется в классе HashMap. В нем происходит следующее:

Создается переменная int h;
Если объект key равен null, то переменной h присваивается значение 0, иначе вызывается метод hashCode() у объекта key, который вычисляет его хеш-код и записывает его в переменную h;
Выполняется операция побитового исключающего ИЛИ (XOR) между переменной h и ее же сдвинутой на 16 бит вправо (h >>> 16);
Полученное значение возвращается в качестве результата метода.
Таким образом, в методе hash() происходит вычисление хеш-кода объекта с помощью метода hashCode(), а затем применяется операция XOR и сдвиг вправо для улучшения распределения значений хеш-кодов по бакетам.
Операторы %,&, применяются для вычисления бакета, индекса, тоесть вычисление внешнего хеша, >>>  - побитовый сдвиг применяется для
того, что бы старшие биты хеша h подмешивались в младшие для лучшего распределения по бакетам.
-------------------------------

 Рассказать и продемонстрировать как переопределяют метод hashCode
Действительно, книга "Effective Java" содержит множество рекомендаций по переопределению метода hashCode().

Вот некоторые из них:

Если метод equals() возвращает true для двух объектов, то метод hashCode() должен возвращать одно и то же значение для этих объектов.

Если в классе есть поля, участвующие в методе equals(), то они также должны участвовать в вычислении хеш-кода.

Хеш-коды должны быть вычислены таким образом, чтобы уменьшить количество коллизий, то есть случаев, когда разные объекты имеют одинаковый хеш-код. При этом не обязательно, чтобы все объекты имели разные хеш-коды, но идеально, если количество коллизий минимально.

Хеш-код должен быть вычислен на основе неизменяемых полей объекта, иначе хеш-код может измениться, что может привести к проблемам в хеш-таблицах.

Пример реализации метода hashCode() может выглядеть следующим образом:

arduino
Copy code
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + name.hashCode();
        result = 31 * result + age;
        return result;
    }

    // реализация метода equals()
}
В этом примере используются следующие правила:

начальное значение переменной result равно произвольному простому числу;
для каждого поля, участвующего в методе equals(), вычисляется хеш-код и добавляется к результату;
для String используется хеш-код, вычисленный по стандартному алгоритму, а для примитивов используется их значение;
константа 31 используется, чтобы увеличить уникальность хеш-кода, так как она является нечетным простым числом, а умножение на нее эквивалентно сдвигу на 5 бит влево и вычитанию результата из самого себя (т.е. 31 * x = (x << 5) - x).
Такая реализация учитывает все вышеперечисленные правила и позволяет создавать объекты класса Person, которые могут быть успешно использованы в хеш-таблицах.


    17. Расскажите, что такое анализ алгоритма?

- это процесс оценки эффективности и сложности операций, выполняемых в программировании, так вот  анализ проводят по двум критериям - по временной эффективности и пространственной эффективности.
Временная эффективность - время, затрачиваемое на решение, это не прямое время, а качественное (больше или меньше)
Пространственная эффективность - объемы дополнительной памяти, необходимые для решения. В качестве критерия оценки сложности работы алгоритма наиболее удобной принята big-O-нотация
Наиболее распространены такие формулы сложности:
О(1) - постоянная, или константная, сложность. Как видим, в формуле нет числа элементов n, следовательно, такой алгоритм не зависит от количества обрабатываемых элементов. Такую сложность имеют все операции, которые не работают с коллекциями или со структурами данных, например, операция присваивания, инициализации, сравнения, арифметические операции, операции создания простых объектов
int a = 0;
a++;
int[] arr = new int[4];
Кроме того, такой же сложностью обладают операции, основанные на помещении и извлечении данных в массив или из массива:
arr[1] = a;
int b = arr[2];

O(n) - линейная сложность. В формуле присутствует количество элементов n в первой степени, и это означает, что сложность алгоритма возрастает прямо пропорционально увеличению количества обрабатываемых элементов. Примером является поиск элемента в массиве. Для того, чтобы найти нужный элемент, нам надо в цикле обойти весь массив:
for(int i = 0; i < arr.length; i++) {
  if(arr[i] == model) {
    result = true;
    break;
  }
}
Такой же сложностью обладают операции со структурами данных, выполнение которых основано на использовании цикла.
Примером может являться операция вставки элемента в связный список по индексу - чтобы найти нужный узел, надо пройти список от начала до нужного элемента;  другой пример - поиск элемента в неупорядоченном массиве.
О(log n) - логарифмическая сложность
Для оценки сложности работы алгоритмов используется только логарифм по основанию 2 (или двоичный), поэтому обычно в записи основание логарифма не пишут. Почему только двоичный логарифм? Тут тоже все просто - основным видом поиска в отсортированном массиве является бинарный поиск, в котором массив на каждой итерации делится на 2 части, нужная часть еще на 2 части и так далее. Соответственно, чтобы найти элемент в массиве из n элементов, необходимо сделать не более log n шагов

О(N*logN)  - это сложность хорошо написанных алгоритмов сортировки
Теоретически доказано, что получить лучшую сложность при сортировке, чем О(N*logN) нельзя.


О(n2) - квадратичная сложность. Является частным случаем полиномиальной сложности О(nc) . Показатель степени может быть любым натуральным числом, например, если c = 3, то сложность будет кубической О(n3) . Квадратичная сложность возникает при использовании вложенных циклов. Например, обработка элементов двумерного массива arr[n][m]:
for(int i = 0; i < arr.length; i++) {
    for(int j = 0; i < arr[i].length; j++) {
        System.out.println(arr[i][j]);
    }
}
О(сn)  - экспоненциальная . Здесь с - это некоторая константа, большая 1. Такой сложности надо избегать.
О(n!) - факториальная. Такой сложности надо избегать.
Мышление в терминах Big O
•	Получение элемента коллекции это O(1). Будь то получение по индексу в массиве, или по ключу в словаре в нотации Big O это будет O(1)
•	Перебор коллекции это O(n)
•	Вложенные циклы по той же коллекции это O(n^2)
•	Разделяй и властвуй (Divide and Conquer) всегда O(log n)
•	Итерации которые используют Divide and Conquer это O(n log n)



 18. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны     отличия?



Отличия во временной сложности алгоритмов связаны с тем, как данные хранятся в каждой коллекции. ArrayList и LinkedList хранят элементы последовательно, что позволяет быстро получать доступ к элементам по индексу, но замена и удаление элементов может требовать перестройки всей последовательности. HashSet использует хэш-таблицы для быстрого поиска элементов, но хэш-функция может приводить к коллизиям, что ухудшает производительность в худшем случае. TreeSet использует сбалансированные деревья для хранения элементов, что обеспечивает быстрый поиск, замену и удаление элементов, но требует больше памяти для хранения элементов и поддержания структуры дерева.
ArrayList:

Добавление элемента в конец списка: O(1), в среднем. В худшем случае, когда при добавлении нужно увеличить размер массива, сложность будет O(n).
Добавление элемента в середину или начало списка: O(n), так как все элементы, следующие за добавляемым, придется сдвигать на одну позицию.
Замена элемента по индексу: O(1), так как доступ к элементу осуществляется по индексу.
Удаление элемента по индексу: O(n), так как после удаления элемента, все элементы, следующие за ним, придется сдвигать на одну позицию.
LinkedList:

Добавление элемента в конец списка: O(1).
Добавление элемента в середину или начало списка: O(1), так как новый элемент связывается со следующим и предыдущим элементами.
Замена элемента по индексу: O(n), так как для доступа к элементу придется пройти весь список до нужного индекса.
Удаление элемента по индексу: O(n), так как для доступа к элементу придется пройти весь список до нужного индекса, а затем связать предыдущий и следующий элементы.
HashSet:

Добавление элемента: O(1), в среднем. В худшем случае, когда все элементы попадают в один бакет и образуется длинный список, сложность будет O(n).
Замена элемента: не применимо, так как элементы не имеют индексов.
Удаление элемента: O(1), в среднем. В худшем случае, когда все элементы попадают в один бакет и образуется длинный список, сложность будет O(n).
TreeSet:

Добавление элемента: O(log n).
Замена элемента: не применимо, так как элементы не имеют индексов.
Удаление элемента: O(log n).
HashMap:

Добавление элемента: O(1), в среднем. В худшем случае, когда все элементы попадают в один бакет и образуется длинный список, сложность будет O(n).
Замена элемента: O(1), если ключ существует в Map, O(n) в противном случае.
Удаление элемента: O(1), в среднем
TreeMap:
 добавление, удаление и поиск элемента в TreeMap имеют сложность O(log n), где n - количество элементов в дереве. Это достигается за счет использования красно-черного дерева, которое обеспечивает балансировку дерева и быстрый поиск.
HASHNABLE
Для операций добавления, замены и удаления элементов в Hashtable, в среднем, имеется временная сложность O(1), что означает постоянное время выполнения операции, независимо от размера таблицы. Однако, при возникновении коллизий (когда два ключа хешируются в одно и то же значение), производительность может значительно снижаться, и в худшем случае, временная сложность операции может достигать O(n), где n - это количество элементов в таблице. Также, при перехешировании таблицы (когда количество элементов превышает заданный порог), происходит перераспределение элементов в новые ячейки, что также может привести к значительному снижению производительности операций.





    19. Расскажите реализации данных очередей и стеков.
Очередь – это структура данных, которая работает по принципу "первым пришел - первым вышел" (FIFO - first in, first out). Элементы добавляются в конец очереди, а извлекаются из начала. Рассмотрим две реализации очередей: на основе массива и на основе связного списка.
Рассмотрим методы этого интерфейса, а потом попробуем их использовать на практике.

1. метод add() – добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)

2. Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.

3. Метод offer() – предпринимает попытку вставки элемента в конец очереди.

4. Методы peek() и element() – позволяют вернуть элемент из очереди без его удаления.
Реализация очереди на основе связного списка основана на структуре данных, в которой элементы добавляются в конец очереди и удаляются из начала. Каждый элемент представляет собой узел списка, который содержит значение и указатель на следующий узел.
Подведем некоторые итоги:

1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.

2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.

3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

4. Очереди, доступные в пакете java.util, являются неограниченными очередями.

5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.
Deque (Double-Ended Queue, двусторонняя очередь) - это структура данных, где элементы можно добавлять и удалять с обоих концов очереди. Доступны операции addFirst, addLast для добавления элементов в начало и конец очереди, removeFirst, removeLast для удаления элементов из начала и конца очереди, а также операции peekFirst, peekLast, которые позволяют посмотреть на элементы в начале и конце очереди, но не удаляют их.
Удаление элементов. Для удаления доступно несколько различных методов, но логика примерно так же, как было и с добавлением элементов. Методы poll() и remove() мы уже разбирали у очереди – разница в том, что первый вернет null при пустой очереди, а второй – сгенерирует исключение. Обсудим следующие метод:

- pop() – позволяет удалить головной элемент из очереди и вернуть его. Если очередь пуста – будет сгенерировано исключение NoSuchElementException.

- removeFirst() и pollFirst() – методы также позволят удалить первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

- removeLast() и pollLast() – методы позволят удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

Таким образом мы делаем вывод – предпочтительнее использовать методы poll(), pollFirst() и pollLast(), поскольку они не генерируют непроверяемых исключений, когда наша очередь пустая.
3. Чтение элементов. К ранее рассмотренным методам element() и peek(), которые позволяют прочитать первый элемент из очереди, для чтения также добавлены методы peekFirst() и peekLast() – методы позволяют соответственно прочитать без удаления первый и последний элемент из очереди.
Небольшие выводы:

1. В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.

2. В Java интерфейс Deque поддерживает все методы интерфейса Queue, Collection, включая вставку, удаление и т.д.

3. Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().


4. Наиболее часто используемой реализацией интерфейса Deque является LinkedList

С реализацией интерфейса Queue под названием PriorityQueue
 выводы, что нам доступны все методы интерфейсов Iterable, Collection и Queue
Каждый элемент в очереди имеет связанное с ним значение приоритета. Приоритет элементов в PriorityQueue определяет порядок обслуживания элементов (если быть точнее, то их удаления из очереди). Если элементы в очереди имеют одинаковый приоритет, то они обслуживаются в соответствии с их порядком в очереди (FIFO).

Следовательно, все элементы располагаются либо в возрастающем или убывающем порядке.
Например, возьмем строки. Они сортируются по алфавиту, а точнее по ASCII. В соответствии этим самый низкий приоритет будут иметь элементы с максимальным значением по ASCII, и естественно наоборот – элементы в начале алфавита имеют наивысший приоритет. Элементы с более высоким приоритетом обслуживаются в первую очередь.

Каким же образом определяется приоритет элементов в приоритетной очереди? Одно из главных требований, которые предъявляются к очереди, это то, что элементы в ней должны быть сопоставимыми, т.е. реализовывать интерфейс Comparable. В противном случае при попытке добавить в такую очередь объект класса, который не реализует интерфейс Comparable, мы получим ClassCastException. Но для того чтобы это обойти мы можем создать очередь из объектов пользовательских классов без реализации этими классами интерфейса Comparable за счет организации сортировки элементов на основании пользовательского компаратора.

В таком случае, голова приоритетной очереди является наименьшим элементом, который основан на сортировке по возрастанию в соответствии с реализацией интерфейса Comparable (или же на основании компаратора). Таким образом, элемент с наименьшим (в некоторых реализациях – наибольшим) значением всегда находится в начале. При этом элементы из такой очереди извлекаются от начала очереди. Таким образом мы можем сделать вывод, что самым приоритетным является элемент с наименьшим значением, т.е. тот, который находится в начале очереди.
Разберемся на небольшом примере, например, сортировка почты. Каждый раз, когда почтальон отдает нам письмо, мы вкладываем его в стопку непрочитанных писем в соответствии с приоритетом. Если письмо требует немедленного ответа (к примеру, мы просрочили оплату доступа в интернет и нам его вот-вот отключат), то такое письмо кладется наверх, а письма, на которые можно ответить в свободное время (например, от родственника, которого мы даже ни разу не видели), подкладываются под низ стопки. Письма со средним приоритетом размещаются где-то в середине. Чем выше приоритет, тем выше оказывается письмо в стопке. Верх стопки как раз соответствует началу приоритетной очереди.

Если окажется, что при сортировке два элемента имеют одинаковое упорядочивание (т.е. сравнение с помощью compareTo() или compare() вернуло 0), то в таком случае элементы размещаются по принципу FIFO – первый пришел, первый вышел.

Приоритетные очереди бывают двух типов:

1. Приоритетная очередь по возрастанию. Нетрудно догадаться, что в такой очереди элементы располагаются по возрастанию значений (в соответствии реализации метода compareTo() интерфейса Comparable или метода compare() интерфейса Comparator). Таким образом, наименьшие значения в начале очереди будут иметь наивысший приоритет.

Например, с числами – у нас есть очередь со значениями 3, 5, 6, 8, 10, 11. Здесь 3 – это наименьшее число, поэтому оно получит наивысший приоритет в приоритетной очереди и когда мы будем удалять элемент из очереди, то при первом удалении мы как раз и получим эту тройку.

2. Приоритетная очередь по убыванию. В такой очереди элементы отсортированы в обратном порядке (в соответствии реализации метода compare() интерфейса Comparator, хотя с помощью compareTo() интерфейса Comparable такое также возможно, однако приветствуется не всеми, будьте осторожны). В таком случае первым элементом будет максимальное значение, и оно будет иметь наивысший приоритет.
1. PriorityQueue() – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в естественном порядке, следовательно в такую очередь мы можем добавить только объекты классов, которые реализуют интерфейс Comparable.

2. PriorityQueue(Comparator<? super E> comparator) – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в порядке, который определяет компаратор, который мы передаем в качестве параметра. В такой очереди наши элементы не обязаны реализовывать интерфейс Comparable.

Наши элементы по очереди распределяются в соответствии с результатами их сравнения с помощью наших интерфейсов Comparable и Comparator. Следовательно, очередь с приоритетом не может содержать в себе null элементов, иначе мы получим NullPointerException.
1. Добавление элемента в очередь с приоритетом. Для этого могут быть использованы 2 метод – add() и offer() . Если посмотреть в исходниках, то мы увидим, что метод add() просто вызывает метод offer(). Поэтому будем рассматривать метод offer().
. Удаление элементов. Удалить элемент можно различными способами:

removeIf(Predicate<? super E> filter) – удаление элемента по какому-то условию;

remove() – удаляет элемент из головы очереди, если она пуста, получаем исключение NoSuchElementException;

remove(Object o) – удаляет элемент из очереди, который будет равен по equals() с тем объектом, который мы передали в качестве параметра.

Но особенно важен метод poll(), поскольку в отличие от remove() он не генерирует исключение, а также позволяет получить значение из головы очереди с удалением этого элемента. Как мы помним элемент в голове очереди имеет наивысший приоритет.
Для того чтобы получить элемент из коллекции без удаления можно использовать 2 метода:

element() – возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – будет сгенерировано исключение NoSuchElementException.

peek() - возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – метод вернет null.

Самое главное, что необходимо помнить – эти методы не осуществляют удаления элемента из очереди. Поэтому, если вызывать эти методы несколько подряд, то мы будем получать одно и то же значение.
Небольшие выводы:

1. PriorityQueue является частью Java Collections Framework. PriorityQueue является неограниченной очередью. По умолчанию элементы упорядочены в естественном порядке (обеспечивается сравнением с помощью compareTo()) или же они отсортированы с помощью компаратора;

2. PriorityQueue не позволяет добавлять null элементы, а также те элементы, которые не реализуют интерфейс Comparable (если мы создаем PriorityQueue без компаратора);

3. Размер PriorityQueue не ограничен, но мы можем указать начальный размер очереди в момент ее создания. Когда мы добавляем элементы в PriorityQueue, ее размер увеличивается автоматически.

4. В начале очереди всегда находится элемент с наивысшим приоритетом. При этом в зависимости от типа используемой очереди это может быть элемент или с минимальным значением, или максимальным.


Для реализации очереди на основе связного списка необходимо определить класс узла, который будет содержать данные и ссылку на следующий узел. Также нужно определить класс очереди, который будет содержать указатель на головной и хвостовой узлы, а также методы для добавления и удаления элементов.
 Рассмотрим две реализации очередей: на основе связного списка.и на основе массива
public class Queue {
    private Node head; // указатель на головной элемент очереди
    private Node tail; // указатель на хвостовой элемент очереди

    // вложенный класс Node, представляющий узел очереди
    private static class Node {
        int data; // значение узла
        Node next; // ссылка на следующий узел
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // конструктор очереди, инициализирует указатели на голову и хвост
    public Queue() {
        this.head = null;
        this.tail = null;
    }

    // Метод для добавления элемента в очередь
    public void enqueue(T data) {
        Node<T> node = new Node<>(data); // создаем новый узел с заданными данными
        if (tail != null) {
            tail.next = node; // если хвост не null, то обновляем ссылку на следующий узел
        }
        tail = node; // обновляем ссылку на последний узел
        if (head == null) {
            head = node; // если голова null, то обновляем ссылку на первый узел
        }
    }

    // метод удаления элемента из начала очереди
    public int dequeue() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        int data = this.head.data; // сохраняем значение головного элемента
        this.head = this.head.next; // переходим на следующий узел
        if (this.head == null) { // если очередь стала пустой, обнуляем указатель на хвост
            this.tail = null;
        }
        return data;
    }

    // метод проверки очереди на пустоту
    public boolean isEmpty() {
        return this.head == null;
    }

    // метод возвращает значение головного элемента очереди без его удаления
    public int peek() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        return this.head.data;
    }
}
В данной реализации мы используем массив для хранения элементов очереди. При добавлении элемента мы сдвигаем указатель на хвостовой элемент на одну позицию вправо, добавляем элемент в массив и увеличиваем размер очереди. При удалении элемента мы берем значение головного элемента, сдвигаем указатель на головной элемент на одну позицию вправо и уменьшаем размер очереди. Также в классе реализованы методы peek() для получения значения головного элемента без его удаления, isEmpty() для проверки, пуста ли очередь, и isFull() для проверки, заполнена ли очередь.

public class ArrayQueue {
    private int[] queue;
    private int head; // указатель на головной элемент
    private int tail; // указатель на хвостовой элемент
    private int size; // текущий размер очереди

    public ArrayQueue(int capacity) {
        queue = new int[capacity];
        head = 0;
        tail = -1;
        size = 0;
    }

    public void enqueue(int element) {
        if (size == queue.length) {
            throw new IllegalStateException("Queue is full");
        }
        tail = (tail + 1) % queue.length;
        queue[tail] = element;
        size++;
    }

    public int dequeue() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        int element = queue[head];
        head = (head + 1) % queue.length;
        size--;
        return element;
    }

    public int peek() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[head];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == queue.length;
    }
}

Стек – это структура данных, которая использует принцип LIFO (Last-In-First-Out), то есть последний добавленный элемент становится первым элементом, который удаляется из стека.

Существуют две основные реализации стека: на основе массива и на основе связного списка.

Реализация стека на основе массива:

В реализации стека на основе массива, элементы стека хранятся в непрерывном блоке памяти. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, значение добавляется в вершину стека, а указатель на вершину сдвигается на одну позицию вверх. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на одну позицию вниз. Если указатель на вершину стека достигает нулевой позиции, значит стек пуст.

Реализация стека на основе связного списка:

В реализации стека на основе связного списка, элементы стека хранятся в узлах списка. Каждый узел списка содержит значение элемента и ссылку на следующий узел. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, создается новый узел списка, который добавляется в вершину стека, а указатель на вершину обновляется. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на один узел вниз. Если указатель на вершину стека указывает на пустой список, значит стек пуст.
Выбор между использованием очереди и стека зависит от конкретной задачи, которую необходимо решить.

Стек используется в ситуациях, когда необходимо осуществлять операции "последний вошел - первый вышел" (LIFO). Например, стек может использоваться для реализации функции "отмена" в текстовом редакторе, где последнее действие пользователя должно быть отменено первым.

Очередь же используется в ситуациях, когда необходимо осуществлять операции "первый вошел - первый вышел" (FIFO). Например, очередь может использоваться для обработки задач в порядке их поступления, где задачи, поступившие раньше, должны быть выполнены раньше.
Для джуниор джава программиста может быть сложно определить, какую структуру данных использовать в конкретной ситуации. Ниже приведены примеры выбора между стеком и очередью для разных задач:

Обработка элементов в порядке "последний вошел - первый вышел" (LIFO). В таком случае, следует использовать стек. Например, если нужно обработать последовательность действий пользователя на веб-странице (например, нажатие кнопок), стек можно использовать для сохранения и последующей обработки этих действий в обратном порядке.

Обработка элементов в порядке "первый вошел - первый вышел" (FIFO). В таком случае, следует использовать очередь. Например, если нужно обработать запросы клиентов на сервере в порядке их поступления, очередь может быть использована для сохранения и последующей обработки этих запросов в том порядке, в котором они были получены.

Рекурсивная обработка данных. Если задача требует рекурсивной обработки данных (например, обход дерева или графа), стек может быть использован для сохранения состояния при переходе от одного узла к другому. В то же время, очередь может быть использована для обхода элементов в порядке их появления.

Обработка задач в фоновом режиме. Если нужно обработать большое количество задач в фоновом режиме, очередь может быть использована для сохранения этих задач и последующей обработки их по одной. В то же время, стек может быть использован, если нужно обрабатывать задачи в порядке, обратном порядку их добавления.


Stack - можно получить только последний элемент LIFO
Stack - примитивная структура данных. Работу этой структуры можно представить в виде тарелок, поставленных друг на друга.
Новая тарелка всегда оказывается верхней. Если нам нужно достать тарелку из середины стопки, то нужно снять верхние тарелки.

Stack лучше всего реализовать на базе связанного списка. Почему связанный список лучше всего подходит для этого? Связанный список умеет быстро вставлять данные и удалять с начала или конца. Это поведение как раз и нужно при реализации стека.

например в связанном списке public class ForwardLinked<T> implements Iterable<T>  мы обявляем класс   private static class Node<T> {
        T value;
        Node<T> next;  -
( В Java вложенный класс node - это класс, который объявлен внутри другого класса и используется для представления узла в связном списке. Это позволяет связанному списку быть частью более крупной структуры данных и сохранять свойство инкапсуляции.
Узел (Node) в связанном списке (Linked List) - это элемент, который содержит значение и ссылку на следующий элемент в списке. Каждый узел в списке связан с предыдущим и/или следующим узлом при помощи ссылок, что образует последовательную цепочку узлов.

Обычно, узел связанного списка состоит из двух основных частей: поля данных, которые содержат значение элемента списка, и поля ссылки, которое указывает на следующий элемент списка. Первый узел списка называется головным узлом (head), а последний узел списка называется хвостовым узлом (tail). Хвостовой узел содержит ссылку на null, что означает конец списка.

В узле связного списка обычно хранятся два поля: значение элемента списка и ссылка на следующий элемент списка. Вложенный класс node может содержать эти поля, а также методы для доступа к ним.) - public void add(T value). public Iterator<T> iterator()


Стек (Stack) - это абстрактный тип данных, который представляет собой коллекцию элементов, управляемую по принципу "последним пришел - первым ушел" (Last-In-First-Out, LIFO). Это означает, что последний элемент, добавленный в стек, будет первым, который будет удален из стека.

Операции, которые можно выполнять со стеком, включают добавление элемента в стек (push), удаление элемента из стека (pop) и получение значения верхнего элемента в стеке без его удаления (peek).

Стек может быть реализован как массив или связный список. В реализации на основе массива, элементы стека хранятся в непрерывном блоке памяти, а указатель (индекс) на вершину стека обновляется при каждой операции добавления или удаления элемента. В реализации на основе связного списка, каждый узел списка содержит элемент стека и ссылку на предыдущий узел, что позволяет легко добавлять и удалять элементы из начала списка.
В Java класс Stack предоставляет следующие основные методы для работы со стеком:

push(E element): добавляет элемент в вершину стека.
pop(): удаляет элемент из вершины стека и возвращает его значение.
peek(): возвращает значение элемента, находящегося на вершине стека, но не удаляет его.
empty(): возвращает true, если стек пуст, и false в противном случае.
search(Object element): возвращает позицию элемента в стеке, начиная с вершины. Если элемент не найден, возвращает -1.

Queue (одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли. FIFO
Dequeue (двусторонняя очередь) - можно вставлять/получать элементы из начали и конца.
Stack - можно получить только последний элемент LIFO


    20. Расскажите про реализации деревьев.
В Java есть несколько структур данных, которые можно использовать в различных ситуациях в зависимости от требований проекта:
1.	Массивы (arrays) - это структура данных, которая хранит фиксированное количество элементов одного типа. Они часто используются для хранения элементов одного типа, таких как целые числа или строки.
2.	Списки (lists) - это структура данных, которая позволяет хранить элементы разных типов и изменять их размер динамически. В Java есть несколько типов списков, включая ArrayList и LinkedList.
3.	Множества (sets) - это структура данных, которая хранит набор уникальных элементов без дубликатов. В Java есть несколько типов множеств, включая HashSet и TreeSet.
4.	Отображения (maps) - это структура данных, которая хранит пары ключ-значение, где каждый ключ связан с определенным значением. В Java есть несколько типов отображений, включая HashMap и TreeMap.
5.	Стеки (stacks) - это структура данных, которая используется для хранения элементов в порядке последним пришел - первым вышел (LIFO). В Java есть класс Stack.
6.	Очереди (queues) - это структура данных, которая используется для хранения элементов в порядке первым пришел - первым вышел (FIFO). В Java есть несколько типов очередей, включая LinkedList и PriorityQueue.
7.	Деревья (trees) - это структура данных, которая представляет собой набор элементов, связанных друг с другом в виде древовидной структуры. В Java есть несколько типов деревьев, включая BinarySearchTree и Red-Black Tree.

Поиск в отсортированном массиве происходит за время O(log(n)). Вставка нового элемент в начало за время O(n).
Поиск в связанном списке занимает время O(n), вставка элемента в начало/конец за время O(1).
Деревья объединяют преимущество связанных списков и отсортированных массивов.
В Java используются красно-черные деревья бинарного поиска -  RB Tree.
В этой главе мы последовательно разберем каждый элемент этого названия.
Вначале разберемся, как организованны элементы внутри дерева.
 Базовый элемент дерева - это узел. Узел хранит в себе данные и ссылки на другие узлы. Однако может иметь только одного предка - узел предшественника.

Родительский узел может иметь от 0 до N потомков. В случае с бинарным деревом родительский узел может иметь от 0 до 2 потоков.
В деревьях не могут быть циклические связи. В узел можно прийти только единственным путем.

 Родительский узел имеет левый и правый узел, которые могут быть null ссылками.
Значение левого потомка должно быть меньше родительского. left < parrent
Значение правого потомка должно быть больше или равно родительскому. right >= parrent
Скажите, можно ли назвать деревом бинарного поиска первый рисунок в этом уроке?
Нет нельзя. Потому что левый элемент больше, чем родитель.
Таким образом:
- бинарность, это когда у узла не более двух потомков
- поисковость, это как раз соблюдение условия <, >=
Дерево может быть бинарным, но может не быть деревом поиска, но всякое дерево поиска бинарное.
 Ответить на вопрос: "Чем отличается бинарное дерево от бинарного дерева поиска?
Бинарное дерево - это структура данных, состоящая из узлов, каждый из которых имеет не более двух потомков. Каждый потомок либо пуст, либо является бинарным деревом.
Бинарное дерево поиска (Binary Search Tree, BST) - это особый тип бинарного дерева, в котором каждый узел имеет значение, и для каждого узла выполняются следующие условия:
Значение всех узлов в левом поддереве меньше значения текущего узла;
Значение всех узлов в правом поддереве больше значения текущего узла.
Эти условия гарантируют, что элементы в BST хранятся в отсортированном порядке, что делает возможным эффективный поиск элементов в дереве. Однако, не все бинарные деревья являются BST, поскольку они не обязательно удовлетворяют условиям BST.

Разница между бинарным деревом и бинарным деревом поиска заключается в способе, которым элементы размещаются в дереве и в операциях, которые можно выполнять с этими элементами.
Бинарное дерево - это дерево, в котором каждый узел имеет не более двух потомков. Узел может иметь ноль, один или два потомка.
Схема бинарного дерева:
      1
     / \
    2   3
   / \
  4   5
Бинарное дерево поиска (Binary Search Tree, BST) - это бинарное дерево, в котором каждый узел имеет значение ключа, и значения ключей левого поддерева меньше значения ключа узла, а значения ключей правого поддерева больше значения ключа узла.Схема бинарного дерева поиска:
     4
     / \
    2   6
   / \ / \
  1  3 5  7

На этой схеме каждый узел имеет значение ключа, и ключи левого поддерева меньше ключа узла, а ключи правого поддерева больше ключа узла.

В Java существует несколько реализаций деревьев, каждая из которых имеет свои особенности и применяется в разных случаях. Рассмотрим некоторые из них:

BinaryTree - это двоичное дерево, в котором каждый узел может иметь не более двух потомков. Реализация основана на классе Node, который содержит ссылки на левого и правого потомков, а также на родительский узел. Для добавления элемента в дерево используется алгоритм поиска места вставки, после чего создается новый узел с заданным значением.

BinarySearchTree - это двоичное дерево поиска, в котором каждый узел имеет значение, меньшее или равное значению его правого потомка и большее или равное значению его левого потомка. Реализация основана на классе Node, который содержит ссылки на левого и правого потомков, а также на родительский узел. Для добавления элемента в дерево используется алгоритм поиска места вставки, после чего создается новый узел с заданным значением.

Двоичное дерево состоит из вершин и связей между ними



У этого дерева корнем будет вершина A. Видно, что у вершины D отсутствует левый сын, у вершины B — правый, а у вершин G, H, F и I — оба. Вершины без сыновей принято называть листьями.
static class Node<T1, T2> {
        T1 key;
        T2 value;
         Node<T1, T2> left, right;

        Node(T1 key, T2 value) {
                this.key = key;
                this.value = value;
        }
}

Здесь представлен определение статического вложенного класса Node с параметризованными типами T1 и T2.
Класс Node представляет узел в дереве. Он содержит следующие поля:
key - поле типа T1, представляющее ключ узла.
value - поле типа T2, представляющее значение узла.
left - ссылка на левого потомка узла типа Node<T1, T2>.
right - ссылка на правого потомка узла типа Node<T1, T2>.
Конструктор класса Node принимает ключ и значение и устанавливает соответствующие значения полям key и value.
Этот класс используется для создания узлов в дереве, где каждый узел содержит пару ключ-значение.
Как видно из примеров, мы требуем от ключей, чтобы их можно было сравнивать между собой (Ord a в haskell и T1 implements Comparable<T1> в java). Все это не спроста — для того, чтобы дерево было полезным данные должны храниться в нем по каким-то правилам.

Какие же это правила? Все просто: если в вершине X хранится ключ x, то в левом (правом) поддереве должны храниться только ключи меньшие (соответственно большие) чем x. Проиллюстрируем:
Что же нам дает такое упорядочевание? То, что мы легко можем отыскать требуемый ключ x в дереве! Просто сравним x со значением в корне. Если они равны, то мы нашли требуемое. Если же x меньше (больше), то он может оказаться только в левом (соответственно правом) поддереве. Пусть например мы ищем в дереве число 17



public T2 get(T1 k) {
        Node<T1, T2> x = root;
        while (x != null) {
                int cmp = k.compareTo(x.key);
                if (cmp == 0) {
                        return x.value;
                }
                if (cmp < 0) {
                        x = x.left;
                } else {
                        x = x.right;
                }
        }
        return null;
}

Здесь представлен метод get, который принимает ключ k и возвращает значение (T2), связанное с данным ключом в дереве.

Он выполняет следующие действия:

Инициализирует переменную x ссылкой на корень дерева.
В цикле while продолжает итерации, пока x не станет равным null.
Внутри цикла сравнивает ключ k с ключом текущего узла x с помощью метода compareTo.
Если результат сравнения (cmp) равен 0, значит, ключ найден, и метод возвращает значение x.value.
Если результат сравнения меньше 0, значит, искомый ключ k меньше текущего ключа x.key, и продолжаем поиск в левом поддереве, присваивая x значение x.left.
Если результат сравнения больше 0, значит, искомый ключ k больше текущего ключа x.key, и продолжаем поиск в правом поддереве, присваивая x значение x.right.
Если цикл завершается (т.е., ключ не найден и x становится равным null), метод возвращает null.
Этот метод выполняет поиск по дереву на основе сравнения ключей, сравнивая искомый ключ k с ключами текущих узлов и перемещаясь влево или вправо в зависимости от результата сравнения для поиска нужного значения.

Добавление в дерево

Для этого будем спускаться по дереву как в функции get, пока не найдем вершину с таким же ключем, либо не дойдем до отсутсвующего сына. Если мы нашли вершину с таким же ключем, то просто меняем соответствующее значение. В противно случае легко понять что именно в это место следует вставить новую вершину, чтобы не нарушить порядок. Рассмотрим вставку ключа 42 в дерево на прошлом рисунке:



public void add(T1 k, T2 v) {
        Node<T1, T2> x = root, y = null;
        while (x != null) {
                int cmp = k.compareTo(x.key);
                if (cmp == 0) {
                        x.value = v;
                        return;
                } else {
                        y = x;
                        if (cmp < 0) {
                                x = x.left;
                        } else {
                                x = x.right;
                        }
                }
        }
        Node<T1, T2> newNode = new Node<T1, T2>(k, v);
        if (y == null) {
                root = newNode;
        } else {
                if (k.compareTo(y.key) < 0) {
                        y.left = newNode;
                } else {
                        y.right = newNode;
                }
        }
}
Здесь представлен метод add, который добавляет новый узел в дерево с заданным ключом k и значением v.
Он выполняет следующие действия:
Инициализирует переменные x и y ссылками на корень дерева и null соответственно.
В цикле while продолжает итерации, пока x не станет равным null.
Внутри цикла сравнивает ключ k с ключом текущего узла x с помощью метода compareTo.
Если результат сравнения (cmp) равен 0, значит, ключ уже существует в дереве. В этом случае, обновляем значение текущего узла x.value на v и выходим из метода.
Если результат сравнения меньше 0, значит, искомый ключ k меньше текущего ключа x.key, и продолжаем поиск в левом поддереве, присваивая x значение x.left.
Если результат сравнения больше 0, значит, искомый ключ k больше текущего ключа x.key, и продолжаем поиск в правом поддереве, присваивая x значение x.right.
Если цикл завершается (т.е., достигнут конец дерева и x становится равным null), создается новый узел newNode с ключом k и значением v.
Если y равно null, значит, дерево пустое, и новый узел становится корневым узлом root.
В противном случае, сравниваем ключ k с ключом узла y.
Если k меньше y.key, новый узел становится левым потомком y.left.
Если k больше или равен y.key, новый узел становится правым потомком y.right.
Таким образом, метод add добавляет новый узел в дерево, соблюдая порядок сравнения ключей, и обновляет ссылки между узлами для правильной структуры дерева.

Теперь мы подобрались к самой сложной операции в этой статье — удалению ключа x из дерева. Для начала мы, как и раньше, найдем нашу вершину в дереве. Теперь возникает два случая. Случай 1 (удаляем число 5):




Видно, что у удаляемой вершины нет правого сына. Тогда мы можем убрать ее и вместо нее вставить левое поддерево, не нарушая упорядоченность:
  Если же правый сын есть, налицо случай 2 (удаляем снова вершину 5, но из немного другого дерева):

Тут так просто не получится — у левого сына может уже быть правый сын. Поступим по-другому: найдем в правом поддереве минимум. Ясно, что его можно найти если начать в правом сыне и идти до упора влево. Т.к у найденного минимума нет левого сына, можно вырезать его по аналогии со случаем 1 и вставить его вместо удалеемой вершины. Из-за того что он был минимальным в правом поддереве, свойство упорядоченности не нарушится:




public void remove(T1 k) {
        Node<T1, T2> x = root, y = null;
        while (x != null) {
                int cmp = k.compareTo(x.key);
                if (cmp == 0) {
                        break;
                } else {
                        y = x;
                        if (cmp < 0) {
                                x = x.left;
                        } else {
                                x = x.right;
                        }
                }
        }
        if (x == null) {
                return;
        }
        if (x.right == null) {
                if (y == null) {
                        root = x.left;
                } else {
                        if (x == y.left) {
                                y.left = x.left;
                        } else {
                                y.right = x.left;
                        }
                }
        } else {
                Node<T1, T2> leftMost = x.right;
                y = null;
                while (leftMost.left != null) {
                        y = leftMost;
                        leftMost = leftMost.left;
                }
                if (y != null) {
                        y.left = leftMost.right;
                } else {
                        x.right = leftMost.right;
                }
                x.key = leftMost.key;
                x.value = leftMost.value;
        }
}

Здесь представлен метод remove, который удаляет узел с заданным ключом k из дерева.

Он выполняет следующие действия:

Инициализирует переменные x и y ссылками на корень дерева и null соответственно.
В цикле while продолжает итерации, пока x не станет равным null.
Внутри цикла сравнивает ключ k с ключом текущего узла x с помощью метода compareTo.
Если результат сравнения (cmp) равен 0, значит, найден узел с ключом k, и прерываем цикл.
Если результат сравнения меньше 0, значит, искомый ключ k меньше текущего ключа x.key, и продолжаем поиск в левом поддереве, присваивая x значение x.left.
Если результат сравнения больше 0, значит, искомый ключ k больше текущего ключа x.key, и продолжаем поиск в правом поддереве, присваивая x значение x.right.
Если цикл завершается (т.е., достигнут конец дерева и x становится равным null), значит, узел с ключом k не найден, и мы выходим из метода.
Проверяем случаи удаления узла:
Если узел x не имеет правого поддерева (x.right == null), то необходимо переустановить ссылки родительского узла y на левое поддерево x.left.
Если узел x имеет правое поддерево (x.right != null), то необходимо найти наименьший узел (левыйmost) в правом поддереве x.
В этом случае, инициализируется переменная leftMost значением x.right.
Затем, в цикле, мы идем влево по дереву, обновляя leftMost и y, пока не достигнем крайнего левого узла в правом поддереве.
Если y не равно null, значит, у leftMost есть правое поддерево, и переустанавливаем ссылку y.left на это поддерево.
Если y равно null, значит, leftMost был самым левым узлом в правом поддереве x, и переустанавливаем x.right на leftMost.right.
Затем, копируем ключ и значение из leftMost в x, чтобы заменить узел для удаления.
По завершении операции удаления узла, метод remove завершается.
В итоге, метод remove выполняет следующие действия:
Ищет узел с заданным ключом k в дереве.
Если узел с ключом k найден, производит его удаление из дерева, учитывая различные случаи:
Узел x не имеет правого поддерева: переустанавливает ссылки родительского узла y на левое поддерево x.left.
Узел x имеет правое поддерево: находит наименьший узел leftMost в правом поддереве x, заменяет значения x значениями leftMost, а затем переустанавливает ссылки в правом поддереве.
Таким образом, метод remove обеспечивает удаление узла с заданным ключом из дерева.






AVL-дерево (Adelson-Velsky и Landis) - это тип самобалансирующегося бинарного дерева поиска, где для каждой вершины высота поддеревьев слева и справа от нее различается не более чем на 1. Таким образом, гарантируется, что время выполнения операций поиска, вставки и удаления будет O(log n).
При вставке или удалении элемента, которые нарушают балансировку, дерево перебалансируется, чтобы выполнить условие балансировки. Это достигается путем поворотов поддеревьев вокруг некоторых вершин.
В результате каждая операция вставки или удаления в AVL-дереве занимает O(log n) времени в худшем случае, что делает его хорошим выбором для реализации словарей, кэшей и других структур данных, где быстрый доступ к данным и изменение структуры являются ключевыми требованиями.

          5
         /   \
        3     8
       / \   / \
      2   4 7   9
               /
              6


RedBlackTree - это самобалансирующееся двоичное дерево поиска, в котором каждый узел имеет либо красный, либо черный цвет. Реализация основана на классе Node, который содержит ссылки на левого и правого потомков, а также на родительский узел и цвет узла. Для добавления элемента в дерево используется алгоритм поиска места вставки, после чего происходит перекрашивание и повороты узлов для поддержания баланса дерева.
         11 (B)
         /   \
    2 (B)   14 (R)
   /   \   /   \
  1    7 (R)  15 (R)
      / \
     5   8
Объяснение:

Каждый узел может быть либо красным, либо черным.
Корень дерева всегда черный.
Если узел красный, то его потомки - черные.
У всех листьев (null-узлов) одинаковая чернота, т.е. количество черных узлов на любом пути к листу одинаково.
Красный узел может иметь только черных потомков.
Для любого узла все пути от него до листьев содержат одинаковое количество черных узлов, это называется "равновесие черных узлов".
В данной схеме можно заметить, что узел 11 (корень дерева) - черный, его потомки 2 и 14 - красные. Узел 14 имеет двух красных потомков 15 и 7, а узел 2 имеет одного красного потомка 7 и одного черного потомка 1. Листья дерева (null-узлы) также отображены на схеме.
Выбор цвета для узла в красно-черном дереве зависит от его положения в дереве и правил, которые определяют структуру дерева. В красно-черном дереве узлы могут быть красными или черными. Цвет узла определяет его свойства и его положение в дереве.
Правила структуры красно-черного дерева определяют, что все листья дерева (null-узлы) являются черными. Кроме того, для каждого красного узла все его потомки (дети) являются черными. Эти правила обеспечивают балансировку дерева и гарантируют, что длина самого длинного пути от корня до листа не превысит вдвое длину самого короткого пути.
Красный цвет узла используется для того, чтобы указать на необычное свойство узла (например, что он является родителем красного узла), которое необходимо учитывать при балансировке дерева. Черный цвет узла используется для обозначения его стандартных свойств и положения в дереве.
Красно-черное дерево



B-Tree -
B-дерево (B-Tree) - это структура данных, которая представляет собой дерево, в котором каждый узел может иметь несколько потомков и ключей. Она используется для организации данных на диске и в памяти, где требуется быстрый доступ к большим объемам информации.

Основное отличие B-дерева от обычного двоичного дерева в том, что каждый узел может иметь несколько ключей и потомков. Таким образом, B-дерево может иметь больше двух потомков на каждом уровне, что позволяет эффективно управлять большими объемами данных.

Структура B-дерева обычно представляет собой многомерный индексный массив с множеством ключей, разбитых на блоки фиксированного размера. Каждый узел B-дерева соответствует блоку массива, который может содержать несколько записей. Каждая запись представляет собой ключ и ссылку на блок, соответствующий этому ключу.





    21. Что такое loadFactor?

loadFactor - это параметр, используемый в хеш-таблицах для определения максимального количества элементов, которые могут быть добавлены в таблицу, прежде чем происходит увеличение ее размера.
 Например, если loadFactor установлен на 0,75, то хранилище будет увеличено, когда его заполненность достигнет 75%.

Если loadFactor установлен на 0,75, то при достижении заполненности хранилища 75% его размер увеличится в два раза. Например, если начальный размер хранилища был 16, а количество элементов достигло 12 (75% от 16), то размер хранилища увеличится до 32.





   22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

Побитовые логические операции в Java (и других языках программирования) выполняются над двоичными представлениями чисел. Они применяются к каждому биту в двоичном представлении числа и могут использоваться для выполнения различных операций над битами.

Побитовое И (AND) - обозначается символом "&". Для двух битовых значений, операция AND возвращает 1 только в том случае, если оба бита равны 1. В противном случае, возвращает 0.
Пример: 0011 & 0101 = 0001

Побитовое ИЛИ (OR) - обозначается символом "|". Для двух битовых значений, операция OR возвращает 1, если хотя бы один бит равен 1. В противном случае, возвращает 0.
Пример: 0011 | 0101 = 0111

Побитовое исключающее ИЛИ (XOR) - обозначается символом "^". Для двух битовых значений, операция XOR возвращает 1 только в том случае, если биты различны. В противном случае, возвращает 0.
Пример: 0011 ^ 0101 = 0110

Побитовое отрицание (NOT) - обозначается символом "~". Операция NOT инвертирует все биты в числе.
Пример: ~0011 = 1100


    23. Расскажите про операции сдвига. Какие они бывают и что делают?

- Знаковый сдвиг влево (<<)
Сдвигает двоичное представление первого операнда влево на количество бит, заданное во втором операнде, знак числа сохраняется. Младшие(крайние правые) биты при этом заполняются нулями. Сдвиг на 1 бит влево соответствует умножению на 2.
Примеры:
27 (11011) << 1 = 54 (110110)
-5 (1111 1111 1111 1111 1111 1111 1111 1011) << 1 = -10 (1111 1111 1111 1111 1111 1111 1111 0110)

Если число выходит за границы диапазона типа int, крайний бит (знак числа) теряется:
2 147 483 647 (0111 1111 1111 1111 1111 1111 1111 1111) << 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)

- Знаковый сдвиг вправо (>>)
Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа сохраняется. Старшие(крайние левые биты) заполняются ведущими нулями (при сдвиге положительного числа) или единицами (при сдвиге отрицательного числа). Сдвиг на 1 бит вправо соответствует делению на 2:
24 (11000) >> 1 = 12 (1100)
-4 (1111 1111 1111 1111 1111 1111 1111 1100) >> 1 = -2 (1111 1111 1111 1111 1111 1111 1111 1110)



- Беззнаковый сдвиг вправо(>>>)
Сдвигает двоичное представление первого операнда вправо на количество бит, заданное во втором операнде, знак числа не сохраняется. Для положительных чисел работает как деление:
24 (11000) >>> 1 = 12 (1100)
-24 (1111 1111 1111 1111 1111 1111 1110 1000) >>> 1 = 2147483636 (0111 1111 1111 1111 1111 1111 1111 0100)
Можно увидеть, что знаковый бит был заменён нулём.
Больше о побитовых операциях.
Первые четыре оператора представляют собой применение битовых масок к аргументу в соответствии с логическими функциями. Например, оператор & применяется для поиска элемента в HashMap по формуле h & (length -1), где h - хэшкод элемента, а length - длина массива. (Это мы будем проходить в следующем уроке).
Битовая маска - это двоичное число, нужное для получения определенных цифр другого двоичного числа. Целевое число сравнивается с маской с помощью побитовых логических операций, в результате чего получается бит/биты, то есть результирующее число.
Наибольший интерес представляют операторы сдвига. Первым операндом оператора сдвига является число, которое нужно обработать, а вторым - количество бит, на которое следует выполнить сдвиг. Результатом операции сдвига является двоичное представление числа, сдвинутое в заданном направлении. Знаковые сдвиги также называют арифметическими, а беззнаковые - логическими.
Особенности работы операторов сдвига
Операторы сдвига всегда возвращают тип int, даже если аргумент типа, например, byte. поэтому следующий код вернёт ошибку:
byte n = 27;
  n = n << 1;
Устранить ошибку можно путём приведения к типу byte:
n = (byte) (n << 1);
Нельзя сдвинуть на количество бит, большее, чем разрядность операнда. При этом происходит неявное сокращение правого (кол-во бит) операнда.
Пример:
Если сдвинуть данное число на 32 бита, по идее, результат должен состоять из одних нулей, но на самом деле это не так:
-1 (1111 1111 1111 1111 1111 1111 1111 1111) >> 32 = -1 (1111 1111 1111 1111 1111 1111 1111 1111)
-1 (1111 1111 1111 1111 1111 1111 1111 1111) >>> 32 = -1 (1111 1111 1111 1111 1111 1111 1111 1111)
Примеры применения битовых операций:
•	Ускорение операций умножения и деления чисел на два. Примеры можно увидеть в стандартной библиотеке jdk. Важно понимать, что сдвиги намного хуже читаются в коде, нежели обычные арифметические операции, поэтому применять их нужно согласованно на уровне команды/проекта, иначе другие программисты могут внезапно столкнуться со сложностями чтения такого кода.
•	Битовые поля(флаги). Пример: пусть есть права на доступ - чтение, запись, выполнение. Их удобнее хранить не в трёх разных переменных, а в одной, устанавливая соответствующие биты.
•	Алгоритмы шифрования и сжатия (например, Шифр Вернама построен на XOR).
•	Работа с графикой.
Рассмотрим обмен чисел 5 (0101) и 9 (1001). Начальные данные: А = 5, В = 9.
A = 0101 ^ 1001 = 1100
B = 1100 ^ 1001 = 0101
A = 1100 ^ 0101 = 1001
Таким образом, мы сменили между собой значения переменных А и В.

    24. Как хранится знак числа в Java? Как хранятся отрицательные числа?
Прежде, чем мы продолжим, нужно рассказать о том, как значение хранится в исполняющей среде Java.
Все примитивные (целочисленные) типы представляют из себя двоичные числа разной длины. Например, byte - 8 бит, int - 32 бита.
Рассмотрим как пример число 35 типа byte. В двоичном виде оно записывается как 00100011. Позиция каждого двоичного разряда представляет собой некоторую степень числа 2. В крайнем правом разряде - 2^0 = 1, второй справа - 2^1 = 2, третий справа - 2^2 = 4 и т.д. Чтобы получить из двоичного числа число 35 в привычной нам десятичной форме, нужно взять результаты степени двоек, содержащиеся в разрядах со значением 1 и суммировать их. Единица в числе 00100011 есть в нулевом, первом и пятом разрядах. Далее считаем: 2^0 + 2^1 + 2^5 = 1 + 2 + 32 = 35.
Представление отрицательных чисел в Java
Преобразование положительного числа в отрицательное в двоичном коде происходит путем инвертирования (то есть замены 0 на 1 и наоборот) всех битов числа и добавления 1 к полученному значению. Например, для числа 5 (бинарное представление 0101) преобразование в отрицательное число будет выглядеть следующим образом:

Инвертируем все биты числа 0101 -> 1010
Добавляем 1 к полученному числу: 1010 + 0001 = 1011
Таким образом, полученное число 1011 будет представлять отрицательное значение числа -5 в двоичном коде.
  int i = -5;
  System.out.println(Integer.toBinaryString(i));

