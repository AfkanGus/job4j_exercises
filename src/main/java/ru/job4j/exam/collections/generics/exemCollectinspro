 Экзамен. Структуры данных и алгоритмы
1.	Что такое generics?
Generics (обобщения) - это механизм в языке программирования Java, который позволяет создавать параметризованные типы данных, которые могут работать с различными типами данных.

Generics позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных без необходимости написания отдельного кода для каждого типа данных. Вместо этого, вы можете определить параметр типа (также называемый обобщенным типом), который будет заменен на конкретный тип данных при использовании кода.

Для определения параметра типа используется символ "<" и ">" в сочетании с именем параметра типа. Например, следующий код определяет параметризованный тип данных T:

csharp
Copy code
public class MyClass<T> {
    private T value;
    public MyClass(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
Здесь T - это параметр типа, который будет заменен на конкретный тип данных при создании объекта класса MyClass. Например, чтобы создать объект MyClass с типом данных Integer, мы можем использовать следующий код:
MyClass<Integer> myClass = new MyClass<Integer>(10);

---------------------------------------------------------------------

Параметризованный тип (или обобщенный тип) - это тип данных, который создается с использованием параметра типа. В языке Java параметризованные типы позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

Для создания параметризованного типа в Java используется символ "<" и ">" для указания параметра типа. Например, следующий код создает параметризованный тип List, который может хранить значения типа String:
List<String> myList = new ArrayList<String>();
Здесь List - это интерфейс, который определен в Java Collections Framework, а ArrayList - это класс, который реализует интерфейс List. Мы указываем параметр типа String в угловых скобках, чтобы создать список, который может хранить только значения типа String.
---------------------------------------------------------------------------------

Generics в данном случае это запись, заключенная в скобки <>
Для решения проблемы совместимости типов разных классов.
Прим. Есть коллекция с в классе, и нужно добовать не только экземпялры этого класса в коллекцию, но и другого класса.  Без <> делать это не безопасно,-> Object, приветению типов. А в <> мы указываем тип данных в виде параметра в классах, методах,интерфейсах.  эклссемпляры которого будем использовать в классе с добавлением в коллекции.

Существует 2 типа дженериков:
Параметризированый тип - Обобщения - это параметризованные типы.  для параметризации класса С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.
public static class NumberContainer<T extends Number & Comparable>
Для того чтобы создать класс общего типа достаточно в его объявлении в <> указать перечень общих типов, которые будут использоваться для реализации класса (типов может быть несколько)
: Существует такое понятие, связанное с generics, как необработанные типы (в литературе, интернете еще можно встретить такое название как "сырые типы"). Обозначаются они также как и generics в скобках <>, в которых проставляются заглавные латинские символы, зарезервированные специально Когда мы будем использовать этот класс нам будет необходимо указать точный параметр, который будет использоваться вместо K и V. Добавим метод main() выведем в консоль создаваемые объекты с разными параметрами:
public class GenericsClass<K, V> {
    private K key;

    private V value;

    public GenericsClass(K key, V value) {
        this.key = key;
        this.value = value;
    }
GenericsClass<String, String> gen = new GenericsClass<>("First key", "First value");
    System.out.println("Вывод в консоль: " + gen);

    GenericsClass<Integer, String> second = new GenericsClass<>(12345, "Second value");
    System.out.println("Вывод в консоль: " + second);




<?> Wildcard
 используются в сигнатуре методов


2.	Что такое wild cards
Wildcards (дословный перевод - "шаблоны с подстановочными знаками") в языке программирования Java представляют собой механизм, который позволяет создавать более гибкие и универсальные типы данных.
Wildcards позволяют создавать параметризованные типы, которые могут принимать аргументы любого типа, без необходимости знать конкретный тип. Это делает их очень полезными в контексте обобщенного программирования (generic programming), так как они позволяют создавать универсальные методы и классы, которые могут работать с разными типами данных.

public class Person {
    private String name;

    private int age;

    private Date birthday;

--------------------------------
public class Programmer extends Person {
    public Programmer(String name, int age, Date birthday) {
        super(name, age, birthday);
    }
--------------------------------

public class GenericUsage {
    /*
 метод печатает элементы коллекции (collection) в консоль.
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

    /*
     создадим метод который позволит вывести в консоль все элементы коллекции
     , которая может содержать объекты Person или объекты класса Programmer:
     */
    public void printInfo(Collection<? extends Person> collection) {
        for (Iterator<? extends Person> it = collection.iterator();
             it.hasNext();
        ) {
            Person next = it.next();
            System.out.println(next);
        }
    }

    /*
     мы хотим написать метод, который помещает объекты Integer в список и выводит этот
      список в консоль. При этом наш метод должен быть более гибки
      м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
     */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }
----------------------------------------------------



Unbounded Wildcards <?>
 символом подстановки
подстановочные типы.

    3. Что такое bounded wild cards?
Bounded Wildcards: они позволяют ограничить типы данных, которые могут быть переданы в параметризованный тип. Для этого используется ключевое слово extends или super.
	Upper Bounded Wildcards <? extends Number>
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
 может содержать объекты, класс которых является Number или наследуется от Number.
 метод который нужно реализовать использует определенный тип и все его подтипы
Это ковариантность.
 Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. List<Integer> — подтип List<? extends Number>





Lower Bounded Wildcards <? super Integer>
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
может содержать объекты, класс которых Number или  у которых Number является наследником (супертип от Number)
ограниченный снизу wildcard ограничивает неизвестный тип определенным типом или супертипом этого типа.
Это контравариантность.
Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
 List<Number> является подтипом List<? super Integer>.

 мы хотим написать метод, который помещает объекты Integer в список и выводит этот
  список в консоль. При этом наш метод должен быть более гибки
  м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
 */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }




3.	Что такое unbounded wild cards?
Unbounded Wildcards: они представляются символом "?". Эти wildcards позволяют передавать любой тип данных в параметризованный тип.
Unbounded Wildcards <?> позволяют создавать универсальные методы, которые могут работать с различными типами данных.

Unbounded Wildcards <?>
    /*
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

Для того, чтобы определиться с выбором между extends и super был придуман метод PECS.
Producer Extends Consumer Super
Если метод имеет аргументы с параметризованным типом (например, Collection<T> или Predicate<T>), то в случае, если аргумент — производитель (producer), нужно использовать ? extends T, а если аргумент — потребитель (consumer), нужно использовать ? super T.

{
	/**
	 * Кладёт значение в хранилище по заданному ключу.
	 *
	 * @param key Ключ.
	 * @param value Значение.
	 */
	void put(K key, V value);

	/**
	 * Читает значение из хранилища по заданному ключу.
	 *
	 * @param key Ключ.
	 * @return Значение либо null.
	 */
	@Nullable V get(K key);

	/**
	 * Кладёт все пары ключ-значение в хранилище.
	 *
	 * @param entries Набор пар ключ-значение.
	 */
	void putAll(Map<K, V> entries);

	/**
	 * Читает все значения из хранилища по заданным
	 * ключам.
	 *
	 * @param keys Набор ключей.
	 * @return Пары ключ-значение.
	 */
	Map<K, V> getAll(Collection<K> keys);

	/**
	 * Читает из хранилища все значения, удовлетворяющие
	 * заданному условию (предикату).
	 *
	 * @param p Предикат для проверки значений.
	 * @return Значения, удовлетворяющие предикату.
	 */
	Collection<V> getAll(Predicate<V> p);
 метод getAll(Predicate<V> p) является Consumer, потому что он принимает предикат p, который применяется к каждому элементу хранилища для определения, удовлетворяет ли элемент условию. Метод не производит никаких значений, а только принимает их и возвращает коллекцию значений, удовлетворяющих предикату.

Остальные методы, такие как put(K key, V value), get(K key), putAll(Map<K, V> entries), и getAll(Collection<K> keys), являются Producer, потому что они создают или производят значения и помещают их в хранилище, или возвращают значения из хранилища.



    5. Где хранится информация про Generics?
В Java информация о типах (Generics) стирается во время компиляции (type erasure), то есть, в скомпилированном байт-коде нет информации о типах, используемых в коде

    6. Как можно получить тип Generics?
 в Java есть механизм рефлексии, который позволяет получать информацию о типах во время выполнения программы

 в исходном коде до компиляции информация о generics может быть доступна через использование Java Reflection API. Reflection API позволяет получить информацию о типах переменных, методов, классов
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]
getClass().getGenericSuperclass() позволяет получить информацию о суперклассе объекта, а затем метод getActualTypeArguments() возвращает массив параметров типа, указанных в суперклассе в виде дженериков. Поскольку в данном случае параметр типа находится на первой позиции в массиве параметров типа суперкласса, мы можем получить его, обратившись к элементу массива [0].

Затем мы используем оператор приведения типа (Class<T>) для приведения параметра типа к классу типа T, который был указан при создании объекта этого класса.

  7. Что такое итератор?
Итератор в Java - это интерфейс, предоставляющий возможность последовательного доступа к элементам коллекции без раскрытия ее внутренней реализации. Итератор может использоваться для обхода любого типа коллекции, включая списки, множества, карты и т.д.

Интерфейс Iterator в Java содержит 3 метода:

boolean hasNext() - возвращает true, если в коллекции есть следующий элемент, иначе false.
E next() - возвращает следующий элемент в коллекции типа E.
void remove() - удаляет текущий элемент из коллекции.
Каждый итератор хранит внутреннюю переменную, указывающую на текущую позицию в коллекции. Эта переменная устанавливается в начало коллекции при создании итератора, и каждый вызов метода next() перемещает эту переменную на следующий элемент коллекции. Метод hasNext() проверяет, есть ли следующий элемент в коллекции.

Для использования итератора сначала необходимо получить экземпляр этого интерфейса от коллекции, используя метод iterator(). Затем можно использовать методы hasNext() и next() для обхода коллекции.








  8. Что такое коллекции?

Коллекции в Java - это фреймворк, предоставляющий классы и интерфейсы для управления группами объектов.Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными.
 Java Collection Framework иерархию интерфейсов находятся 2 интерфейса:

1. Collection

2. Map.





    9. Назовите базовые интерфейсы коллекций?
 иерархию интерфейсов   на вершмне Java Collection Framework находятся 2 интерфейса:

1. Collection

2. Map.

Collection – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

Map – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

Однако стоит обратить внимание, что этот интерфейс расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в так называемом улучшенном цикле for (for-each).

У интерфейса Iterable определен только один метод iterator(). Таким образом все наследники Collection (соответственно и Iterable) обязаны вернуть итератор. Итератор – это объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ к элементам любой коллекции без необходимости вникать в суть его реализации
boolean add(E e) – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.
boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась.
Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.
boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.
boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции. Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.
boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод. Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.
int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

Чтобы очистить содержимое коллекции можно использовать метод:

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Коллекцию можно преобразовать в массив, для этого можно использовать следующий метод:

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.




    10. Расскажите реализации интерфейса List?
ArrayList - это класс, который реализует интерфейс List и представляет динамический массив элементов. Он использует массив для хранения элементов и позволяет быстро получать доступ к элементам по индексу. Класс ArrayList также автоматически увеличивает размер массива при добавлении новых элементов, что делает его хорошим выбором для работы с большими списками элементов.
import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // создание нового ArrayList
        List<String> fruits = new ArrayList<String>();

        // добавление элементов
        fruits.add("apple");
        fruits.add("banana");
        fruits.add("orange");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + fruits.get(0));
        System.out.println("Element at index 1: " + fruits.get(1));

        // удаление элементов
        fruits.remove("banana");
        System.out.println("After removing banana: " + fruits);

        // замена элемента
        fruits.set(1, "pear");
        System.out.println("After replacing index 1 with pear: " + fruits);

        // получение размера списка
        System.out.println("Size of the list: " + fruits.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain orange? " + fruits.contains("orange"));

        // очистка списка
        fruits.clear();
        System.out.println("After clearing the list: " + fruits);
    }
}



LinkedList - это класс, который реализует интерфейс List и представляет двусвязный список элементов. Он использует узлы для хранения элементов и позволяет быстро добавлять и удалять элементы из начала и конца списка. Класс LinkedList также позволяет быстро добавлять и удалять элементы по индексу.
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args) {
        // создание нового LinkedList
        List<String> names = new LinkedList<String>();

        // добавление элементов
        names.add("John");
        names.add("Alice");
        names.add("Bob");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + names.get(0));
        System.out.println("Element at index 1: " + names.get(1));

        // удаление элементов
        names.remove("Alice");
        System.out.println("After removing Alice: " + names);

        // замена элемента
        names.set(1, "Mary");
        System.out.println("After replacing index 1 with Mary: " + names);

        // получение размера списка
        System.out.println("Size of the list: " + names.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain Bob? " + names.contains("Bob"));

        // очистка списка
        names.clear();
        System.out.println("After clearing the list: " + names);
    }
}

package ru.job4j.exam.collections.generics.list;

import java.util.*;

public class ListUsage {
    @SuppressWarnings("checkstyle:MethodLength")
    public static void main(String[] args) {
       /* Для добавления новых элементов предназначены 4 метода:
        1.1. boolean add(E e) – добавляет элемент e в конец списка.*/
        List<String> rsl = new ArrayList<>();
        rsl.add("one");
        rsl.add("two");
        rsl.add("three");
/*
1.2. void add(int index, E element) – добавляет указанный элемент
(element) в указанную позицию(index) в списке.
*/
        rsl.add(0, "four");
       /* 1.3. boolean addAll(Collection<? extends E> c) – добавляет все элементы из переданной коллекции в
         конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.*/
        List<String> list = new ArrayList<>();
        list.add("four");
        list.add("five");
        rsl.addAll(2, list);
        for (String s : rsl) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("Прочитать элементы из списка можно двумя способами:\""
                + " 2.1. Использование метода get():");
        for (int i = 0; i < rsl.size(); i++) {
            System.out.println("Текущий элемент: " + rsl.get(i));
        }
        System.out.println("2.2. использовать итератор для доступа к элементам."
                +
                " Для того чтобы получить экземпляр итератора в интерфейсе List<E> определены 3 метода:\n"
                +
                "        Iterator<E> iterator() – метод возвращает объект Iterator, который содержит в\n"
                +
                "         себе все элементы исходной коллекции.");
        Iterator<String> iterator = rsl.iterator();
        while (iterator.hasNext()) {
            System.out.println("Текущий элемент: " + iterator.next());
        }
        System.out.println("ListIterator<E> listIterator() – возвращает итератор списка для элементов в этом списке.");
        ListIterator<String> listIterator = rsl.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator.next());
        }
        System.out.println("ListIterator<E> listIterator(int index) – возвращает итератор списка для элементов"
                + " в этом списке, начиная с элемента индекс которого равен index.");
        ListIterator<String> listIterator1 = rsl.listIterator(5);
        while (listIterator1.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator1.next());
        }
        /*
3. Изменение элементов в списке

E set(int index, E element) – заменяет элемент позиция которого равна index на элемент
 который мы передаем в метод (element). При этом метод возвращает старое значение элемента
  с индексом index.
         */
        List<String> rsl1 = new ArrayList<>();
        rsl1.add("one");
        rsl1.add("two");
        rsl1.add("three");
        rsl1.set(1, "two and second");
        for (String s : rsl1) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
        default void replaceAll(UnaryOperator<E> operator) – заменяет каждый элемент
         в списке результатом применения оператора (operator) к каждому элементу.
         */
        List<String> rsl2 = new ArrayList<>();
        rsl2.add("one");
        rsl2.add("two");
        rsl2.add("three");
        rsl2.replaceAll(String::toUpperCase);
        for (String s : rsl2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        4. Удаление элементов из списка
        Для выполнения данной операции в интерфейсе List<E> определены 5 методов:
         */
        List<String> rsl3 = new ArrayList<>();
        rsl3.add("one");
        rsl3.add("two");
        rsl3.add("three");
        /*
        E remove(int index) – удаляет элемент из списка по индексу index, при этом метод
         возвращает удаленный элемент.
         */
        rsl3.remove(1);
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        . boolean remove(E e) – удаляет элемент е типа E из коллекции при его
         ПЕРВОМ вхождении в список, если он есть в коллекции.
         */
        rsl3.remove("three");
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        boolean removeAll(Collection<?> col) – метод удаляет из списка все элементы,
         которые содержатся в коллекции col, если в результате работы метода исходный
          список изменился - метод возвращает true.
         */
        List<String> list2 = new ArrayList<>();
        list2.add("one");
        list2.add("three");
        list2.removeAll(list2);
        for (String s : list2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("-----");
        /*
         boolean retainAll(Collection<?> col) – метод также удаляет элементы из списка,
          за исключением тех, которые находятся в коллекции col, если в результате
           работы метода исходный список изменился - метод возвращает true.
         */
        List<String> list4 = new ArrayList<>();
        list4.add("one");
        list4.add("three");
        list4.retainAll(rsl);
        for (String s : list4) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
 default boolean removeIf(Predicate<? super E> filter) – метод удаляет все элементы из коллекции,
  которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения).
   Если в результате работы метода список изменился - метод возвращает true.
         */
        List<String> words = new ArrayList<>();
        words.add("кот");
        words.add("собака");
        words.add("слон");
        words.add("мышь");
        words.add("хомяк");
        words.removeIf(s -> s.length() <= 3);
        System.out.println(words);

    /*
    . boolean contains*(E element) – метод возвращает true, если список содержит
     переданный в метод элемент element.
     */
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        boolean b = numbers.contains(2);
        System.out.println("Список содержит элемент: " + b);
        System.out.println("------------");
        /*
        int indexOf*(E element) – метод возвращает индекс элемента element при его
         первом вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> strings = new ArrayList<>();
        strings.add("one");
        strings.add("two");
        strings.add("three");
        strings.add("four");
        strings.add("five");
        int i = strings.indexOf("two");
        System.out.println("Индекс элемента в списке: " + i);
        System.out.println("----------");
        /*
        int lastIndexOf*(E element) - метод возвращает индекс элемента element
         при его последнем вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> str = new ArrayList<>();
        str.add("two");
        str.add("three");
        str.add("one");
        int index = str.lastIndexOf("one");
        System.out.println("ндекс элемента в списке: " + index);
        System.out.println("----");
        /*
         List<E> subList(int fromIndex, int toIndex) - метод возвращает список, который содержит
          все элементы исходного списка начиная с индекса fromIndex(включительно)
           и до toIndex(значение исключается). При этом, если выполняется условие
            fromIndex == toIndex,- метод вернет пустой список.
         */
        List<String> strings2 = new ArrayList<>();
        strings2.add("one");
        strings2.add("two");
        strings2.add("three");
        strings2.add("four");
        strings2.add("five");
        List<String> newlist = strings2.subList(1, 2);
        for (String s : newlist) {
            System.out.println("екущий элемент: " + s);
        }
        System.out.println("----------");
        /*
        . default void sort(Comparator<? super E> comp) – метод осуществляет сортировку
         списка в соответствии с компаратором comp, который мы передаем в метод.
         */
        List<Integer> numbers1 = new ArrayList<>();
        numbers1.add(5);
        numbers1.add(2);
        numbers1.add(8);
        numbers1.add(1);
        numbers1.sort(Comparator.reverseOrder());
        System.out.println(numbers1);

    }
}



    11. Расскажите реализации интерфейса Set?

    12. Расскажите реализации интерфейса Map?

    13. Отличие ArrayList от LinkedList?


    14. Отличие Set от List?
    15. Расскажите про методы Object hashCode и equals?
    16. Расскажите, что такое коллизии в Map? Как с ними бороться?
    17. Расскажите, что такое анализ алгоритма?
 18. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны     отличия?
    19. Расскажите реализации данных очередей и стеков.
    20. Расскажите про реализации деревьев.
    21. Что такое loadFactor?
   22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.
    23. Расскажите про операции сдвига. Какие они бывают и что делают?
    24. Как хранится знак числа в Java? Как хранятся отрицательные числа?
