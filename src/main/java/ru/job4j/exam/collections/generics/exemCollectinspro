Экзамен. Структуры данных и алгоритмы
1.	Что такое generics?
Generics (обобщения) - это механизм в языке программирования Java, который позволяет создавать параметризованные типы данных, которые могут работать с различными типами данных.

Generics позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных без необходимости написания отдельного кода для каждого типа данных. Вместо этого, вы можете определить параметр типа (также называемый обобщенным типом), который будет заменен на конкретный тип данных при использовании кода.

Для определения параметра типа используется символ "<" и ">" в сочетании с именем параметра типа. Например, следующий код определяет параметризованный тип данных T:

csharp
Copy code
public class MyClass<T> {
    private T value;
    public MyClass(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
Здесь T - это параметр типа, который будет заменен на конкретный тип данных при создании объекта класса MyClass. Например, чтобы создать объект MyClass с типом данных Integer, мы можем использовать следующий код:
MyClass<Integer> myClass = new MyClass<Integer>(10);

---------------------------------------------------------------------

Параметризованный тип (или обобщенный тип) - это тип данных, который создается с использованием параметра типа. В языке Java параметризованные типы позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

Для создания параметризованного типа в Java используется символ "<" и ">" для указания параметра типа. Например, следующий код создает параметризованный тип List, который может хранить значения типа String:
List<String> myList = new ArrayList<String>();
Здесь List - это интерфейс, который определен в Java Collections Framework, а ArrayList - это класс, который реализует интерфейс List. Мы указываем параметр типа String в угловых скобках, чтобы создать список, который может хранить только значения типа String.
---------------------------------------------------------------------------------

Generics в данном случае это запись, заключенная в скобки <>
Для решения проблемы совместимости типов разных классов.
Прим. Есть коллекция с в классе, и нужно добовать не только экземпялры этого класса в коллекцию, но и другого класса.  Без <> делать это не безопасно,-> Object, приветению типов. А в <> мы указываем тип данных в виде параметра в классах, методах,интерфейсах.  эклссемпляры которого будем использовать в классе с добавлением в коллекции.



Существует 2 типа дженериков:
Параметризированый тип - Обобщения - это параметризованные типы.  для параметризации класса С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.
public static class NumberContainer<T extends Number & Comparable>
Для того чтобы создать класс общего типа достаточно в его объявлении в <> указать перечень общих типов, которые будут использоваться для реализации класса (типов может быть несколько)
: Существует такое понятие, связанное с generics, как необработанные типы (в литературе, интернете еще можно встретить такое название как "сырые типы"). Обозначаются они также как и generics в скобках <>, в которых проставляются заглавные латинские символы, зарезервированные специально Когда мы будем использовать этот класс нам будет необходимо указать точный параметр, который будет использоваться вместо K и V. Добавим метод main() выведем в консоль создаваемые объекты с разными параметрами:
public class GenericsClass<K, V> {
    private K key;

    private V value;

    public GenericsClass(K key, V value) {
        this.key = key;
        this.value = value;
    }
GenericsClass<String, String> gen = new GenericsClass<>("First key", "First value");
    System.out.println("Вывод в консоль: " + gen);

    GenericsClass<Integer, String> second = new GenericsClass<>(12345, "Second value");
    System.out.println("Вывод в консоль: " + second);




<?> Wildcard
 используются в сигнатуре методов


2.	Что такое wild cards
Wildcards (дословный перевод - "шаблоны с подстановочными знаками") в языке программирования Java представляют собой механизм, который позволяет создавать более гибкие и универсальные типы данных.
Wildcards позволяют создавать параметризованные типы, которые могут принимать аргументы любого типа, без необходимости знать конкретный тип. Это делает их очень полезными в контексте обобщенного программирования (generic programming), так как они позволяют создавать универсальные методы и классы, которые могут работать с разными типами данных.

public class Person {
    private String name;

    private int age;

    private Date birthday;

--------------------------------
public class Programmer extends Person {
    public Programmer(String name, int age, Date birthday) {
        super(name, age, birthday);
    }
--------------------------------

public class GenericUsage {
    /*
 метод печатает элементы коллекции (collection) в консоль.
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

    /*
     создадим метод который позволит вывести в консоль все элементы коллекции
     , которая может содержать объекты Person или объекты класса Programmer:
     */
    public void printInfo(Collection<? extends Person> collection) {
        for (Iterator<? extends Person> it = collection.iterator();
             it.hasNext();
        ) {
            Person next = it.next();
            System.out.println(next);
        }
    }

    /*
     мы хотим написать метод, который помещает объекты Integer в список и выводит этот
      список в консоль. При этом наш метод должен быть более гибки
      м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
     */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }
----------------------------------------------------



Unbounded Wildcards <?>
 символом подстановки
подстановочные типы.



    3. Что такое bounded wild cards?
Bounded Wildcards: они позволяют ограничить типы данных, которые могут быть переданы в параметризованный тип. Для этого используется ключевое слово extends или super.
	Upper Bounded Wildcards <? extends Number>
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
 может содержать объекты, класс которых является Number или наследуется от Number.
 метод который нужно реализовать использует определенный тип и все его подтипы
Это ковариантность.
 Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. List<Integer> — подтип List<? extends Number>

Lower Bounded Wildcards <? super Integer>
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
может содержать объекты, класс которых Number или  у которых Number является наследником (супертип от Number)
ограниченный снизу wildcard ограничивает неизвестный тип определенным типом или супертипом этого типа.
Это контравариантность.
Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
 List<Number> является подтипом List<? super Integer>.

 мы хотим написать метод, который помещает объекты Integer в список и выводит этот
  список в консоль. При этом наш метод должен быть более гибки
  м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
 */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }




3.	Что такое unbounded wild cards?
Unbounded Wildcards: они представляются символом "?". Эти wildcards позволяют передавать любой тип данных в параметризованный тип.
Unbounded Wildcards <?> позволяют создавать универсальные методы, которые могут работать с различными типами данных.

Unbounded Wildcards <?>
    /*
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

Для того, чтобы определиться с выбором между extends и super был придуман метод PECS.
Producer Extends Consumer Super
Если метод имеет аргументы с параметризованным типом (например, Collection<T> или Predicate<T>), то в случае, если аргумент — производитель (producer), нужно использовать ? extends T, а если аргумент — потребитель (consumer), нужно использовать ? super T.

{
	/**
	 * Кладёт значение в хранилище по заданному ключу.
	 *
	 * @param key Ключ.
	 * @param value Значение.
	 */
	void put(K key, V value);

	/**
	 * Читает значение из хранилища по заданному ключу.
	 *
	 * @param key Ключ.
	 * @return Значение либо null.
	 */
	@Nullable V get(K key);

	/**
	 * Кладёт все пары ключ-значение в хранилище.
	 *
	 * @param entries Набор пар ключ-значение.
	 */
	void putAll(Map<K, V> entries);

	/**
	 * Читает все значения из хранилища по заданным
	 * ключам.
	 *
	 * @param keys Набор ключей.
	 * @return Пары ключ-значение.
	 */
	Map<K, V> getAll(Collection<K> keys);

	/**
	 * Читает из хранилища все значения, удовлетворяющие
	 * заданному условию (предикату).
	 *
	 * @param p Предикат для проверки значений.
	 * @return Значения, удовлетворяющие предикату.
	 */
	Collection<V> getAll(Predicate<V> p);
 метод getAll(Predicate<V> p) является Consumer, потому что он принимает предикат p, который применяется к каждому элементу хранилища для определения, удовлетворяет ли элемент условию. Метод не производит никаких значений, а только принимает их и возвращает коллекцию значений, удовлетворяющих предикату.

Остальные методы, такие как put(K key, V value), get(K key), putAll(Map<K, V> entries), и getAll(Collection<K> keys), являются Producer, потому что они создают или производят значения и помещают их в хранилище, или возвращают значения из хранилища.



    5. Где хранится информация про Generics?
В Java информация о типах (Generics) стирается во время компиляции (type erasure), то есть, в скомпилированном байт-коде нет информации о типах, используемых в коде

    6. Как можно получить тип Generics?
 в Java есть механизм рефлексии, который позволяет получать информацию о типах во время выполнения программы

 в исходном коде до компиляции информация о generics может быть доступна через использование Java Reflection API. Reflection API позволяет получить информацию о типах переменных, методов, классов
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]
getClass().getGenericSuperclass() позволяет получить информацию о суперклассе объекта, а затем метод getActualTypeArguments() возвращает массив параметров типа, указанных в суперклассе в виде дженериков. Поскольку в данном случае параметр типа находится на первой позиции в массиве параметров типа суперкласса, мы можем получить его, обратившись к элементу массива [0].

Затем мы используем оператор приведения типа (Class<T>) для приведения параметра типа к классу типа T, который был указан при создании объекта этого класса.

  7. Что такое итератор?
Итератор в Java - это интерфейс, предоставляющий возможность последовательного доступа к элементам коллекции без раскрытия ее внутренней реализации. Итератор может использоваться для обхода любого типа коллекции, включая списки, множества, карты и т.д.

Интерфейс Iterator в Java содержит 3 метода:

boolean hasNext() - возвращает true, если в коллекции есть следующий элемент, иначе false.
E next() - возвращает следующий элемент в коллекции типа E.
void remove() - удаляет текущий элемент из коллекции.
Каждый итератор хранит внутреннюю переменную, указывающую на текущую позицию в коллекции. Эта переменная устанавливается в начало коллекции при создании итератора, и каждый вызов метода next() перемещает эту переменную на следующий элемент коллекции. Метод hasNext() проверяет, есть ли следующий элемент в коллекции.

Для использования итератора сначала необходимо получить экземпляр этого интерфейса от коллекции, используя метод iterator(). Затем можно использовать методы hasNext() и next() для обхода коллекции.
 fail-fast поведение, т.е. если с момента создания итератора коллекция подверглась структурному изменению, итератор должен кидать ConcurrentModificationException.
Это достигается через введение счетчика изменений - modCount. Каждая операция, которая структурно модифицирует коллекцию, должна инкрементировать этот счетчик. В свою очередь, итератор запоминает значение этого счетчика на момент своего создания (expectedModCount), а затем, на каждой итерации, сравнивает сохраненное значение с текущим значением поля modCount, если они отличаются, то генерируется исключение.

Ранее мы с Вами реализовывали и использовали Iterator, который обладает поведением fail-fast. Что это значит? Это значит, что если мы по ходу итерирования меняем коллекцию, то получаем исключение ConcurrentModificationException. Например, такой код приведет к этому исключению

java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer i : list) {
    list.add(i * i);
}
В качестве альтернативы "обычному" итератору, есть ListIterator. Он обладает fail-safe поведением, это значит, что мы можем менять коллекцию по ходу итерирования, но только с помощью самого итератора.

Подобный код по прежнему не будет работать

java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
ListIterator<Integer> i = list.listIterator();
while (i.hasNext()) {
    Integer value = i.next();
    if (value <= 5) {
        list.add(value * value);
    }
    i.next();
}
Таким образом, чтобы как-то манипулировать списком во время итерирования, нужно использовать методы ListIterator



  8. Что такое коллекции?

Коллекции в Java - это фреймворк, предоставляющий классы и интерфейсы для управления группами объектов.Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными.
 Java Collection Framework иерархию интерфейсов находятся 2 интерфейса:

1. Collection

2. Map.
Что такое Java Collections Framework?

Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет разработчику пользоваться большим количесвом структур данных из «коробки».


Базовые понятия

На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» (словари).



Collection — этот интерфейс находится в составе JDK c версии 1.2 и определяет основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (например size(), isEmpty(), add(E e) и др.). Интерфейс был слегка доработан с приходом дженериков в Java 1.5. Также, в версии Java 8, было добавлено несколько новых методов для работы с лямбдами (такие как stream(), parallelStream(), removeIf(Predicate<? super E> filter) и др.).

Важно также отметить, что эти методы были реализованы непосредственно в интерфейсе как default-методы.

Map. Данный интерфейс также находится в составе JDK c версии 1.2 и предоставляет разработчику базовые методы для работы с данными вида «ключ — значение».Также как и Collection, он был дополнен дженериками в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые зачастую реализовались в логике приложения (getOrDefault(Object key, V defaultValue), putIfAbsent(K key, V value)).


Интерфейс Map [doc]



Hashtable — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Как и другие коллекции из Java 1.0, Hashtable является синхронизированной (почти все методы помечены как synchronized). Из-за этой особенности у неё имеются существенные проблемы с производительностью и, начиная с Java 1.2, в большинстве случаев рекомендуется использовать другие реализации интерфейса Map ввиду отсутствия у них синхронизации.

HashMap — коллекция является альтернативой Hashtable. Двумя основными отличиями от Hashtable являются то, что HashMap не синхронизирована и HashMap позволяет использовать null как в качестве ключа, так и значения. Так же как и Hashtable, данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции. Добавление элемента выполняется за константное время O(1), но время удаления, получения зависит от распределения хэш-функции. В идеале является константным, но может быть и линейным O(n). Более подробную информацию о HashMap можно почитать здесь (актуально для Java < 8).

LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). Но это преимущество имеет также и недостаток — увеличение памяти, которое занимет коллекция. Более подробная информация изложена в этой статье.

TreeMap — реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.

WeakHashMap — реализация хэш-таблицы, которая организована с использованием weak references. Другими словами, Garbage Collector автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элеметна нет жёстких ссылок.


Интерфейс List [doc]



Реализации этого интерфейса представляют собой упорядоченные коллекции. Кроме того, разработчику предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).

Vector — реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Vector появился в JDK версии Java 1.0, но как и Hashtable, эту коллекцию не рекомендуется использовать, если не требуется достижения потокобезопасности. Потому как в Vector, в отличии от других реализаций List, все операции с данными являются синхронизированными. В качестве альтернативы часто применяется аналог — ArrayList.

Stack — данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push()). После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.

ArrayList — как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Как можно догадаться из названия, его реализация основана на обычном массиве. Данную реализацию следует применять, если в процессе работы с коллекцией предплагается частое обращение к элементам по индексу. Из-за особенностей реализации поиндексное обращение к элементам выполняется за константное время O(1). Но данную коллекцию рекомендуется избегать, если требуется частое удаление/добавление элементов в середину коллекции. Подробный анализ и описание можно почитать в этом хабратопике.

LinkedList — ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий). Благодаря этому, добавление и удаление из середины, доступ по индексу, значению происходит за линейное время O(n), а из начала и конца за константное O(1). Так же, ввиду реализации, данную коллекцию можно использовать как стек или очередь. Для этого в ней реализованы соответствующие методы. На Хабре также есть статья с подробным анализом и описанием этой коллекции.


Интерфейс Set [doc]



Представляет собой неупорядоченную коллекцию, которая не может содержать дублирующиеся данные. Является программной моделью математического понятия «множество».

HashSet — реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.

LinkedHashSet — отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.

TreeSet — аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".


Интерфейс Queue [doc]



Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для извлечения и добавления элементов в очередь. Большинство реализаций данного интерфейса находится в пакете java.util.concurrent и подробно рассматриваются в данном обзоре.

PriorityQueue — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. Данная коллекция не поддерживает null в качестве элементов.

ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к элементам по индексу и хранение null. Как заявлено в документации, коллекция работает быстрее чем Stack, если используется как LIFO коллекция, а также быстрее чем LinkedList, если используется как FIFO.


Заключение

Java Collections Framework содержит большое количество различных структур данных, доступных в JDK «из коробки», которые в большинстве случаев покрывают все потребности при реализации логики приложения. Сравнение временных характеристик основных коллекций, которые зачастую используются в разработке приложений приведено в таблице:



При необходимости, разработчик может создать собственную реализацию, расширив или переопределив существующую логику, либо создав свою собственную реализацию подходящего интерфейса с нуля. Также существует некоторое количество готовых решений, которые являются альтернативой или дополнением к Java Collections Framework. Наиболее популярными являются Google Guava и Commons Collections.

    9. Назовите базовые интерфейсы коллекций?
 иерархию интерфейсов   на вершмне Java Collection Framework находятся 2 интерфейса:

1. Collection

2. Map.

Collection – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

Map – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

Однако стоит обратить внимание, что этот интерфейс расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в так называемом улучшенном цикле for (for-each).

У интерфейса Iterable определен только один метод iterator(). Таким образом все наследники Collection (соответственно и Iterable) обязаны вернуть итератор. Итератор – это объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ к элементам любой коллекции без необходимости вникать в суть его реализации
boolean add(E e) – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.
boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась.
Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.
boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.
boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции. Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.
boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод. Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.

int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

Чтобы очистить содержимое коллекции можно использовать метод:

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Коллекцию можно преобразовать в массив, для этого можно использовать следующий метод:

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.




    10. Расскажите реализации интерфейса List?
ArrayList - это класс, который реализует интерфейс List и представляет динамический массив элементов. Он использует массив для хранения элементов и позволяет быстро получать доступ к элементам по индексу. Класс ArrayList также автоматически увеличивает размер массива при добавлении новых элементов, что делает его хорошим выбором для работы с большими списками элементов.
ArrayList: основан на массивах и обеспечивает быстрый доступ к элементам, но медленное вставление и удаление элементов в середине списка.

Класс ArrayList в Java имеет несколько конструкторов:

ArrayList(): создает пустой список.

ArrayList(Collection<? extends E> c): создает список, содержащий все элементы заданной коллекции, в порядке, в котором они встречаются в итераторе коллекции.

ArrayList(int initialCapacity): создает список с начальной емкостью initialCapacity.
Значение initialCapacity должно быть неотрицательным. Если передано отрицательное значение, будет выброшено исключение IllegalArgumentException. Если initialCapacity не указан явно, список создается с начальной емкостью по умолчанию, равной 10 элементам.


import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // создание нового ArrayList
        List<String> fruits = new ArrayList<String>();

        // добавление элементов
        fruits.add("apple");
        fruits.add("banana");
        fruits.add("orange");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + fruits.get(0));
        System.out.println("Element at index 1: " + fruits.get(1));

        // удаление элементов
        fruits.remove("banana");
        System.out.println("After removing banana: " + fruits);

        // замена элемента
        fruits.set(1, "pear");
        System.out.println("After replacing index 1 with pear: " + fruits);

        // получение размера списка
        System.out.println("Size of the list: " + fruits.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain orange? " + fruits.contains("orange"));

        // очистка списка
        fruits.clear();
        System.out.println("After clearing the list: " + fruits);
    }
}



LinkedList - это класс, который реализует интерфейс List и представляет двусвязный список элементов. Он использует узлы для хранения элементов и позволяет быстро добавлять и удалять элементы из начала и конца списка. Класс LinkedList также позволяет быстро добавлять и удалять элементы по индексу.
Односвязный список (Singly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение и ссылку на следующий узел в списке. Последний узел в списке содержит ссылку на null. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка и в конце списка, но медленно искать элементы по индексу.
Связанный список - это структура данных, состоящая из узлов, каждый из которых содержит данные и ссылку на следующий узел в списке. Таким образом, элементы списка связаны между собой ссылками, и каждый узел может быть легко найден, используя ссылку на следующий узел.

В Java, связанные списки реализованы в виде класса LinkedList, который реализует интерфейс List. Каждый элемент связанного списка представлен объектом типа Node, который содержит данные и ссылку на следующий узел. Для доступа к первому и последнему элементам списка используются ссылки на головной и последний элементы списка соответственно.

Одним из основных преимуществ связанных списков является то, что они позволяют эффективно добавлять и удалять элементы в любом месте списка, включая начало и конец. Также, при использовании связанных списков, не требуется предварительно выделять память для всего списка, что позволяет экономить ресурсы при работе с большими объемами данных. Однако, связанные списки обладают более сложной логикой работы по сравнению с массивами, их использование может привести к большему количеству операций чтения/записи в память, что может замедлить работу программы в некоторых случаях.

Двусвязный список (Doubly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение, ссылку на следующий узел в списке и ссылку на предыдущий узел в списке. Первый узел в списке имеет ссылку на null в качестве предыдущего узла, а последний узел имеет ссылку на null в качестве следующего узла. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка, в конце списка и по индексу.



Класс LinkedList имеет два конструктора:

LinkedList(): конструктор без параметров, создает пустой связный список.

LinkedList(Collection<? extends E> c): конструктор, который создает связный список из элементов коллекции c.

Оба конструктора создают объект типа LinkedList. Первый конструктор создает пустой связный список, а второй конструктор создает связный список из элементов переданной коллекции c.
Разница между односвязным списком и двусвязным списком заключается в том, что двусвязный список содержит дополнительные ссылки на предыдущий узел в списке, что делает его более гибким для некоторых операций, но требует больше памяти для хранения ссылок на предыдущие узлы.
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args) {
        // создание нового LinkedList
        List<String> names = new LinkedList<String>();

        // добавление элементов
        names.add("John");
        names.add("Alice");
        names.add("Bob");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + names.get(0));
        System.out.println("Element at index 1: " + names.get(1));

        // удаление элементов
        names.remove("Alice");
        System.out.println("After removing Alice: " + names);

        // замена элемента
        names.set(1, "Mary");
        System.out.println("After replacing index 1 with Mary: " + names);

        // получение размера списка
        System.out.println("Size of the list: " + names.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain Bob? " + names.contains("Bob"));

        // очистка списка
        names.clear();
        System.out.println("After clearing the list: " + names);
    }
}

package ru.job4j.exam.collections.generics.list;

import java.util.*;

public class ListUsage {
    @SuppressWarnings("checkstyle:MethodLength")
    public static void main(String[] args) {
       /* Для добавления новых элементов предназначены 4 метода:
        1.1. boolean add(E e) – добавляет элемент e в конец списка.*/
        List<String> rsl = new ArrayList<>();
        rsl.add("one");
        rsl.add("two");
        rsl.add("three");
/*
1.2. void add(int index, E element) – добавляет указанный элемент
(element) в указанную позицию(index) в списке.
*/
        rsl.add(0, "four");
       /* 1.3. boolean addAll(Collection<? extends E> c) – добавляет все элементы из переданной коллекции в
         конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.*/
        List<String> list = new ArrayList<>();
        list.add("four");
        list.add("five");
        rsl.addAll(2, list);
        for (String s : rsl) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("Прочитать элементы из списка можно двумя способами:\""
                + " 2.1. Использование метода get():");
        for (int i = 0; i < rsl.size(); i++) {
            System.out.println("Текущий элемент: " + rsl.get(i));
        }
        System.out.println("2.2. использовать итератор для доступа к элементам."
                +
                " Для того чтобы получить экземпляр итератора в интерфейсе List<E> определены 3 метода:\n"
                +
                "        Iterator<E> iterator() – метод возвращает объект Iterator, который содержит в\n"
                +
                "         себе все элементы исходной коллекции.");
        Iterator<String> iterator = rsl.iterator();
        while (iterator.hasNext()) {
            System.out.println("Текущий элемент: " + iterator.next());
        }
        System.out.println("ListIterator<E> listIterator() – возвращает итератор списка для элементов в этом списке.");
        ListIterator<String> listIterator = rsl.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator.next());
        }
        System.out.println("ListIterator<E> listIterator(int index) – возвращает итератор списка для элементов"
                + " в этом списке, начиная с элемента индекс которого равен index.");
        ListIterator<String> listIterator1 = rsl.listIterator(5);
        while (listIterator1.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator1.next());
        }
        /*
3. Изменение элементов в списке

E set(int index, E element) – заменяет элемент позиция которого равна index на элемент
 который мы передаем в метод (element). При этом метод возвращает старое значение элемента
  с индексом index.
         */
        List<String> rsl1 = new ArrayList<>();
        rsl1.add("one");
        rsl1.add("two");
        rsl1.add("three");
        rsl1.set(1, "two and second");
        for (String s : rsl1) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
        default void replaceAll(UnaryOperator<E> operator) – заменяет каждый элемент
         в списке результатом применения оператора (operator) к каждому элементу.
         */
        List<String> rsl2 = new ArrayList<>();
        rsl2.add("one");
        rsl2.add("two");
        rsl2.add("three");
        rsl2.replaceAll(String::toUpperCase);
        for (String s : rsl2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        4. Удаление элементов из списка
        Для выполнения данной операции в интерфейсе List<E> определены 5 методов:
         */
        List<String> rsl3 = new ArrayList<>();
        rsl3.add("one");
        rsl3.add("two");
        rsl3.add("three");
        /*
        E remove(int index) – удаляет элемент из списка по индексу index, при этом метод
         возвращает удаленный элемент.
         */
        rsl3.remove(1);
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        . boolean remove(E e) – удаляет элемент е типа E из коллекции при его
         ПЕРВОМ вхождении в список, если он есть в коллекции.
         */
        rsl3.remove("three");
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        boolean removeAll(Collection<?> col) – метод удаляет из списка все элементы,
         которые содержатся в коллекции col, если в результате работы метода исходный
          список изменился - метод возвращает true.
         */
        List<String> list2 = new ArrayList<>();
        list2.add("one");
        list2.add("three");
        list2.removeAll(list2);
        for (String s : list2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("-----");
        /*
         boolean retainAll(Collection<?> col) – метод также удаляет элементы из списка,
          за исключением тех, которые находятся в коллекции col, если в результате
           работы метода исходный список изменился - метод возвращает true.
         */
        List<String> list4 = new ArrayList<>();
        list4.add("one");
        list4.add("three");
        list4.retainAll(rsl);
        for (String s : list4) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
 default boolean removeIf(Predicate<? super E> filter) – метод удаляет все элементы из коллекции,
  которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения).
   Если в результате работы метода список изменился - метод возвращает true.
         */
        List<String> words = new ArrayList<>();
        words.add("кот");
        words.add("собака");
        words.add("слон");
        words.add("мышь");
        words.add("хомяк");
        words.removeIf(s -> s.length() <= 3);
        System.out.println(words);

    /*
    . boolean contains*(E element) – метод возвращает true, если список содержит
     переданный в метод элемент element.
     */
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        boolean b = numbers.contains(2);
        System.out.println("Список содержит элемент: " + b);
        System.out.println("------------");
        /*
        int indexOf*(E element) – метод возвращает индекс элемента element при его
         первом вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> strings = new ArrayList<>();
        strings.add("one");
        strings.add("two");
        strings.add("three");
        strings.add("four");
        strings.add("five");
        int i = strings.indexOf("two");
        System.out.println("Индекс элемента в списке: " + i);
        System.out.println("----------");
        /*
        int lastIndexOf*(E element) - метод возвращает индекс элемента element
         при его последнем вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> str = new ArrayList<>();
        str.add("two");
        str.add("three");
        str.add("one");
        int index = str.lastIndexOf("one");
        System.out.println("ндекс элемента в списке: " + index);
        System.out.println("----");
        /*
         List<E> subList(int fromIndex, int toIndex) - метод возвращает список, который содержит
          все элементы исходного списка начиная с индекса fromIndex(включительно)
           и до toIndex(значение исключается). При этом, если выполняется условие
            fromIndex == toIndex,- метод вернет пустой список.
         */
        List<String> strings2 = new ArrayList<>();
        strings2.add("one");
        strings2.add("two");
        strings2.add("three");
        strings2.add("four");
        strings2.add("five");
        List<String> newlist = strings2.subList(1, 2);
        for (String s : newlist) {
            System.out.println("екущий элемент: " + s);
        }
        System.out.println("----------");
        /*
        . default void sort(Comparator<? super E> comp) – метод осуществляет сортировку
         списка в соответствии с компаратором comp, который мы передаем в метод.
         */
        List<Integer> numbers1 = new ArrayList<>();
        numbers1.add(5);
        numbers1.add(2);
        numbers1.add(8);
        numbers1.add(1);
        numbers1.sort(Comparator.reverseOrder());
        System.out.println(numbers1);

    }
}



    11. Расскажите реализации интерфейса Set?
java.util.Set - классы реализующие этот интерфейс не могут содержать дубликаты элементов. Их также называют множества.
В коллекциях типа java.util.Set нет возможности указать индекс. Так же здесь нет возможности заменить элемент.
Вопрос, а как мы получаем данные из java.util.Set если там нет механизма извлечения данных.
Для начала давайте поймем, что же это такое и для чего нужно. Чаще всего на просторах можно встретить такую характеристику, как "множество". Это означает, что в такой коллекции собраны объекты, которые уникальны и все отличаются друг от друга (о том, как программа узнает, что объекты равны друг другу, будет рассказано немного позже). Самый простой пример из жизни - это русский или английский алфавит - в таком наборе данных не может быть двух одинаковых букв.

Set<E> является наследником интерфейса Collection<E>, при этом не добавляет новых методов в список унаследованных, только вносит в них изменения. Рассмотрим CRUD - операции, которые помогают нам использовать Set<E> для хранилища данных.

На самом деле все коллекции реализуют шаблон проектирования - итератор. Этот шаблон позволяет получить все элементы из любой коллекции.

Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:

boolean hasNext() - проверяет на наличие следующего элемента в списке.
T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
void remove() - удаляет элемент из коллекции и переводит указатель назад.

Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например для массива указатель будет индекс элемента.Главной особенностью коллекций java.util.Set является хранение только уникальных элементов.

Изменение элементов в множестве.

К сожалению, для данной структуры данных не определено методов которые напрямую позволяют изменить элементы в множестве.

Но в данном случае можно пойти на хитрость и использовать связку методов - remove() и add(). Т.е. мы сначала удаляем элемент, который надо заменить, а потом добавляем элемент, которым надо его заменить.

. Коллекции java.util.Set не будут добавлять дублирующие элементы.
Познакомимся с интерфейсом Set и его реализациями. Он расширяет интерфейс Collection и представляет собой набор уникальных элементов, т.е. в наборе значений не могут находиться одинаковые значения. Равенство элементов определяется методами equals() и hashcode(), которые определены в классе Object. Для реализаций своих моделей данных эти методы необходимо переопределять для более корректной работы.

Set не добавляет никаких методов по сравнению с Collection, только вносит изменения в унаследованные. Например метод add():

 boolean add(E e) – добавляет элемент в множество и при этом возвращает true только в том случае, если такого элемента еще нет в наборе данных. Если уже такой элемент имеется в коллекции - метод вернет false и набор данных при этом не изменится. Равенство объектов определяется по методу equals()

boolean addAll(Collection<? extends E> c) - добавляет все элементы из переданной коллекции в множество, если они еще не присутствуют в данном множестве. Если передаваемая коллекция также является множеством, то применение данного метода является эффективным способом объединения двух множеств.
int size() - метод возвращает количество элементов в коллекции.
Set<E> of(E ... elements) - метод возвращает множество, в которое помещены список элементов elements типа E.
4. Удаление элементов из множества.
 boolean remove(E e) - удаляет указанный элемент из множества, если он присутствует в нем. Метод возвращает true, если в результате вызова метода набор данных изменился, т.е. если в результате он был удален.
boolean removeAll(Collection<?> c) - удаляет из множества все элементы, которые содержатся в переданной в метод коллекции. Метод возвращает true, если в результате работы метода исходное множество изменилось.

boolean retainAll(Collection<?> c) - в результате работы метода во множестве сохраняются только те элементы, которые содержатся в передаваемой в метод коллекции. Если в результате работы метода исходное множество было изменено - метод вернет true.
default boolean removeIf(Predicate<? super E> filter) - метод удаляет все элементы из коллекции, которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения). Если в результате работы метода множество изменилось - метод возвращает true.
strings.removeIf(s -> s.startsWith("t"));
System.out.println("Вывод в консоль после удаления...");
for (String s : strings) {
    System.out.println("Текущий элемент: " + s);
}т.е. в данном случае мы удалили все строки, которые начинаются на букву t.
boolean contains(E e) – метод возвращает true, если множество содержит переданный в метод элемент e. Сравнение объектов выполняется с помощью метода equals()
int size() - метод возвращает целочисленное значение, и говорит нам о том, сколько элементов содержит наше множество.
default Stream<E> stream() - метод возвращает последовательный поток Stream, источником которой является наше множество. Далее этот поток мы обрабатываем методами которые определены в интерфейсе Stream.
strings.stream()
        .filter(s -> s.length() < 5)
        .forEach(st -> System.out.println("Текущий элемент: " + st));Используем этот метод, отфильтруем его, и выведем каждый элемент в консоль:


Интерфейс Set не имеет собственных конструкторов, так как это всего лишь интерфейс, определяющий набор методов, которые должны быть реализованы в классах-коллекциях, реализующих этот интерфейс.

Но у классов-реализаций интерфейса Set есть свои конструкторы. Например, у класса HashSet есть следующие конструкторы:

HashSet(): создает пустой HashSet с начальной емкостью по умолчанию (16) и коэффициентом загрузки по умолчанию (0.75).

HashSet(int initialCapacity): создает пустой HashSet с указанной начальной емкостью и коэффициентом загрузки по умолчанию (0.75).

HashSet(int initialCapacity, float loadFactor): создает пустой HashSet с указанной начальной емкостью и коэффициентом загрузки.

HashSet(Collection<? extends E> c): создает новый HashSet с элементами из указанной коллекции.

	Коэффициент загрузки (load factor) - это параметр, который используется в хеш-таблицах для определения того, насколько заполнена таблица, прежде чем ее размер увеличится автоматически.

В контексте HashMap и HashSet, коэффициент загрузки определяет, насколько заполнен должен быть массив хранения элементов, прежде чем размер массива увеличится. Например, если коэффициент загрузки установлен на 0.75, это означает, что массив должен быть заполнен не более чем на 75% до того, как размер массива увеличится.

Таким образом, значение 0.75 для коэффициента загрузки по умолчанию означает, что массив хранения элементов в HashMap или HashSet будет увеличен автоматически, когда заполненность достигнет 75%.



Интерфейс Set<E> имеет три реализации: HashSet, LinkedHashSet и TreeSet.

1. HashSet.

Это коллекция, которая не позволяет хранить одинаковые объекты(как и любой Set). HashSet инкапсулирует в себе объект HashMap, поэтому для хранения используется хэш-таблица. При этом ключами в таблице будут значения которые мы поместили в HashSet, а значения, которые соответствуют этим ключам - "заглушки" в виде экземпляров класса Object.

Хэш-таблица хранит информацию, используя механизм хеширования, в котором содержимое ключа используется для определения уникального значения - хеш-код. Хеш-код используется в качестве индекса, с которым ассоциируются данные, которые доступны по ключу. Преобразование ключа в хеш-код и обратно выполняется автоматически - об этом будет рассказано позже при рассмотрении HashMap. Хеширование выгодно тем, что оно обеспечивает константное время выполнения методов contains(), add(), remove().

Для того, чтобы использовать HashSet для хранения объектов, описанных классами собственной реализации, необходимо переопределить методы hashcode() и equals(), иначе два логически одинаковых объекта будут считать разными.

Класс HashSet не гарантирует упорядоченности элементов, поскольку процесс хеширования не позволяет сделать в итоге отсортированный набор данных.

Для создания объекта HashSet в классе определены 4 конструктора:

HashSet() - создается пустое множество - при этом инкапсулированный объект HashMap имеет по умолчанию начальную емкость 16 элементов и коэффициент загрузки 0.75.

HashSet(int initialCapacity) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость, переданную в конструктор, и коэффициент загрузки по умолчанию - 0.75.

HashSet(int initialCapacity, float loadFactor) - создается пустое множество - при этом объект HashMap, который используется внутри будет иметь начальную емкость и коэффициент загрузки, которые передаются в конструктор.

HashSet(Collection<? extends E> c) - будет создано множество, в которое будет помещены элементы передаваемой коллекции.

HashSet в Java - это реализация интерфейса Set, основанная на хеш-таблице. Он используется для хранения набора уникальных элементов без упорядочения.

Хеш-таблица - это структура данных, которая используется для реализации словарей, множеств и других ассоциативных массивов. Она основывается на функции хеширования, которая преобразует ключи в хеш-коды, которые затем используются для поиска и добавления элементов в таблицу.

Хеш-таблица состоит из массива бакетов, в которых хранятся элементы. Каждый бакет имеет индекс и соответствующий ему список элементов. При добавлении элемента в хеш-таблицу, функция хеширования вычисляет хеш-код ключа и определяет индекс бакета, куда будет помещен элемент. Если в этом бакете уже есть элементы, то новый элемент добавляется в конец списка.

В HashSet каждый элемент хранится в виде ключа, без каких-либо значений. HashSet использует хеш-таблицу для хранения элементов, что позволяет быстро выполнять операции поиска, добавления и удаления элементов. При добавлении элемента в HashSet вычисляется его хеш-код, который определяет индекс бакета, в который будет помещен элемент. Если в этом бакете уже есть элементы, то новый элемент добавляется в конец списка.

HashSet позволяет хранить только уникальные элементы. Если в HashSet попытаться добавить уже существующий элемент, то операция добавления будет проигнорирована. Это достигается благодаря использованию хеш-кодов, которые позволяют быстро проверять, есть ли элемент в хеш-таблице.


В контексте Set, бакет (bucket) - это ячейка или список внутри таблицы хеш-кодов, который содержит элементы Set, имеющие одинаковый хеш-код.

Когда элемент добавляется в HashSet, сначала вычисляется его хеш-код с помощью метода hashCode(), а затем он помещается в соответствующий бакет в таблице хеш-кодов. Если в бакете уже есть элементы, то новый элемент будет добавлен в конец списка в этом бакете.

При поиске элемента в HashSet, сначала вычисляется его хеш-код, затем ищется соответствующий бакет в таблице хеш-кодов, и элементы в этом бакете проверяются на равенство с искомым элементом при помощи метода equals(). Если элемент найден, то возвращается соответствующий объект, если нет - возвращается null.

Количество бакетов в таблице хеш-кодов HashSet зависит от размера Set и выбранной реализации. При увеличении количества элементов в Set, HashSet может перестраивать таблицу хеш-кодов, чтобы увеличить количество бакетов и улучшить производительность поиска.

Хеш-код (hash code) - это числовое значение, которое определяется на основе содержимого объекта и используется для его идентификации. В коллекциях, таких как HashSet, хеш-код используется для распределения объектов по "бакетам" (buckets). Бакеты представляют собой группы объектов, хранящихся в коллекции. Когда вы добавляете новый объект в HashSet, его хеш-код вычисляется и используется для определения бакета, в который он будет помещен.

Хеш-код вычисляется с помощью специальной функции, которая преобразует содержимое объекта в числовое значение. Хорошая хеш-функция должна минимизировать вероятность коллизий - ситуации, когда два разных объекта имеют одинаковый хеш-код. Если такое происходит, они будут помещены в один бакет и будут сравниваться с помощью метода equals, чтобы определить, являются ли они одинаковыми или разными.
Для сравнения объектов  в Set использовать метод:

public static boolean equals(Object a,
 Object b)Возвращает true, если аргументы равны друг другу, и false в противном случае. Следовательно, если оба аргумента равны нулю, возвращается значение true. В противном случае, если первый аргумент не равен null, равенство определяется вызовом метода equals первого аргумента со вторым аргументом этого метода. В противном случае возвращается false.

public static boolean deepEquals(Object a,
 Object b)Он используется для сравнения двух объектов на равенство. В случае, если сравниваемые объекты являются массивами, метод выполняет глубокое сравнение, то есть сравнивает не только ссылки на массивы, но и содержимое элементов массивов.

Метод принимает два объекта в качестве параметров и возвращает true, если они равны и false в противном случае. Если хотя бы один из параметров равен null, метод вернет true.Например, если мы хотим сравнить два массива a и b на равенство, мы можем вызвать метод deepEquals следующим образом:
boolean result = Objects.deepEquals(a, b);
Если a и b равны по содержимому, то метод вернет true, иначе - false.
В Set интерфейсе метод hashCode() возвращает хеш-код множества, то есть целочисленное значение, которое является индексом внутренней хеш-таблицы.

Реализация метода hashCode() в разных реализациях Set интерфейса может отличаться. Но в общем случае, если два множества равны (определяется методом equals()), то их хеш-коды должны быть равными.

Однако не гарантируется, что если хеш-коды двух множеств равны, то множества также будут равны. Это может произойти из-за коллизий хеш-функции, когда разным объектам присваивается одинаковый хеш-код.
hashCode - это метод, который возвращает целочисленное значение, которое используется для идентификации объекта в HashMap, HashSet и других структурах данных, которые используют хеш-таблицы. Хеш-таблица - это структура данных, которая использует хеш-функцию для преобразования ключа объекта в индекс массива, где хранится сам объект.

Когда объект добавляется в HashSet, он помещается в соответствующий "бакет" (ячейку хеш-таблицы) на основе его хеш-кода. Если в этом бакете уже есть другие объекты, то выполняется сравнение объектов методом equals. Если equals возвращает true, то объект не добавляется, так как в Set не могут быть дубликаты. Если equals возвращает false, то объект добавляется в этот бакет.

Кроме того, метод hashCode используется для поиска объектов в HashSet. При вызове метода contains или remove с объектом в HashSet, сначала вычисляется хеш-код этого объекта, затем производится поиск в соответствующем бакете. Если объект не найден, то он не был ранее добавлен в HashSet. Если объект найден, то выполняется сравнение объектов методом equals.

Важно понимать, что разные объекты могут иметь одинаковый хеш-код, поэтому метод equals всегда должен быть реализован вместе с методом hashCode.





2. LinkedHashSet

Класс LinkedHashSet расширяет класс HashSet, при этом он не добавляет никаких новых методов. Но в отличие от HashSet, LinkedHashSet поддерживает связанный список элементов множества в том порядке, в котором они были добавлены в множество. Это значит, что когда будет выполняться перебор элементов, которые помещены в объект класса LinkedHashSet, с применением итератора - элементы будут извлечены в том порядке, в каком они были добавлены (HashSet, к сожалению, такого не гарантирует).

Чтобы создать объект класса LinkedHashSet можно использовать аналогичные конструкторы, что и у HashSet.
LinkedHashSet в Java является подклассом HashSet, который наследует все его свойства, но также сохраняет порядок элементов в коллекции, а именно порядок добавления элементов. Таким образом, LinkedHashSet объединяет в себе быстрый доступ к элементам за счет хеш-таблицы и сохранение порядка вставки элементов.

Это может быть полезным в тех случаях, когда важен порядок элементов в коллекции, например, при обработке данных в определенном порядке.

В LinkedHashSet используется двухсторонний связный список для поддержания порядка элементов. В процессе добавления элементов в LinkedHashSet, элементы добавляются в хеш-таблицу, а затем ссылки на них добавляются в конец списка. При удалении элемента из LinkedHashSet, он удаляется из хеш-таблицы, а затем ссылки на этот элемент удаляются из списка.

LinkedHashSet является реализацией интерфейса Set и наследуется от класса HashSet. Конструкторы LinkedHashSet аналогичны конструкторам HashSet, за исключением того, что LinkedHashSet поддерживает порядок вставки элементов, в то время как HashSet не гарантирует порядок хранения элементов.

Конструкторы LinkedHashSet:

LinkedHashSet(): создает пустой экземпляр LinkedHashSet с начальной емкостью 16 и коэффициентом загрузки по умолчанию 0.75.
LinkedHashSet(int initialCapacity): создает пустой экземпляр LinkedHashSet с указанной начальной емкостью и коэффициентом загрузки по умолчанию 0.75.
LinkedHashSet(int initialCapacity, float loadFactor): создает пустой экземпляр LinkedHashSet с указанной начальной емкостью и указанным коэффициентом загрузки.
LinkedHashSet(Collection<? extends E> c): создает экземпляр LinkedHashSet, содержащий элементы указанной коллекции, в порядке их добавления. Начальная емкость устанавливается равной максимальному значению изначальной емкости и количества элементов в коллекции, а коэффициент загрузки по умолчанию - 0,75.

3. TreeSet

Класс TreeSet представляет собой структуру данных в виде дерева, в котором все объекты хранятся в отсортированном по возрастанию порядке. TreeSet инкапсулирует в себе TreeMap, который в свою очередь использует сбалансированное бинарное красно черное дерево для хранения элементов.

Создать объект класса TreeSet можно с помощью следующих конструкторов:

TreeSet() - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Collection<? extends E> c) - создается древовидное множество, которое будет содержать элементы из передаваемой коллекции, элементы будут отсортированы в соответствии с естественным порядком его элементов(по возрастанию).

TreeSet(Comparator<? super E> comparator) - создается новое пустое дерево, в котором элементы будут отсортированы в соответствии с передаваемым в конструктор компаратором.
TreeSet - это реализация интерфейса Set, которая использует структуру данных Tree для хранения элементов в отсортированном порядке.

Как и в случае с HashSet, элементы в TreeSet не допускаются повторяться. Но в отличие от HashSet, элементы TreeSet автоматически сортируются по возрастанию или убыванию их значений, в зависимости от реализации Comparator.

При добавлении нового элемента в TreeSet происходит его вставка в структуру данных Tree в соответствии с его порядком. При удалении элемента, структура Tree автоматически перестраивается, чтобы сохранить порядок.

Операции добавления, удаления и поиска в TreeSet имеют асимптотическую сложность O(log n), что делает эту структуру данных хорошим выбором для приложений, где необходимо часто выполнять эти операции в большом множестве данных.

TreeSet - это класс, который реализует интерфейс Set и представляет собой отсортированный по возрастанию набор уникальных элементов. Вот некоторые методы, которые есть в TreeSet:

add(E e): добавляет элемент в TreeSet, если его там еще нет. Если элемент уже есть, то ничего не делает. Возвращает true, если элемент был добавлен успешно.

clear(): удаляет все элементы из TreeSet.

contains(Object o): возвращает true, если TreeSet содержит указанный элемент.

first(): возвращает первый (наименьший) элемент в TreeSet.

last(): возвращает последний (наибольший) элемент в TreeSet.

remove(Object o): удаляет указанный элемент из TreeSet, если он там есть. Возвращает true, если элемент был успешно удален.

size(): возвращает количество элементов в TreeSet.

ceiling(E e): возвращает наименьший элемент в TreeSet, который больше или равен указанному элементу e. Если такого элемента нет, возвращает null.

floor(E e): возвращает наибольший элемент в TreeSet, который меньше или равен указанному элементу e. Если такого элемента нет, возвращает null.

higher(E e): возвращает наименьший элемент в TreeSet, который больше указанного элемента e. Если такого элемента нет, возвращает null.

lower(E e): возвращает наибольший элемент в TreeSet, который меньше указанного элемента e. Если такого элемента нет, возвращает null.

iterator(): возвращает итератор по элементам TreeSet в возрастающем порядке.

descendingIterator(): возвращает итератор по элементам TreeSet в убывающем порядке.

subSet(E fromElement, E toElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, начиная с элемента fromElement и заканчивая элементом toElement. Включение/исключение границ диапазона зависит от использованной перегрузки метода.

tailSet(E fromElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, начиная с элемента fromElement и до конца TreeSet.

headSet(E toElement): возвращает TreeSet, содержащий все элементы из данного TreeSet, от начала до элемента toElement (не включая его).






    12. Расскажите реализации интерфейса Map?


Интерфейс Map в Java представляет абстракцию для хранения ключей и связанных с ними значений. Все реализации интерфейса Map используют пары ключ-значение для хранения и доступа к данным. Ниже приведены основные реализации интерфейса Map в Java:

HashMap: наиболее распространенная реализация интерфейса Map. Она хранит пары ключ-значение в неупорядоченном виде, используя хеш-таблицу для быстрого доступа к данным.

LinkedHashMap: реализация, которая хранит пары ключ-значение в порядке добавления элементов или их доступа.

TreeMap: реализация, которая хранит пары ключ-значение в отсортированном порядке ключей. Она использует красно-черное дерево для хранения данных.

EnumMap: реализация, которая использует перечисления в качестве ключей и хранит значения в массиве. Это обеспечивает быстрый доступ к данным и позволяет использовать перечисления для проверки наличия ключа.

WeakHashMap: реализация, которая хранит пары ключ-значение в виде слабых ссылок. Это означает, что если ключ не используется в программе, он будет удален автоматически, чтобы освободить память.

IdentityHashMap: реализация, которая использует проверку на идентичность ключей, а не проверку на равенство. Это означает, что если два ключа имеют одинаковое значение, но разные идентификаторы, они будут храниться как разные элементы.

ConcurrentHashMap: реализация, которая обеспечивает потокобезопасный доступ к данным. Она использует блокировки для защиты данных, что позволяет нескольким потокам работать с различными частями хеш-таблицы одновременно.




HashMap - это одна из реализаций интерфейса Map, который используется для хранения данных в виде пары "ключ-значение". Реализация HashMap основана на хеш-таблицах.

Хеш-таблица - это структура данных, которая использует хеш-функцию для преобразования ключа в индекс массива, где значение хранится. Когда требуется получить значение, оно ищется по ключу, проходя по массиву по указанному индексу.

В HashMap каждая пара "ключ-значение" хранится в объекте Entry, который содержит ключ, значение и ссылку на следующий объект Entry, если при добавлении элементов произошла коллизия (два ключа имеют одинаковый хеш-код). Каждый объект Entry добавляется в массив, называемый бакетом, по индексу, вычисленному по хеш-коду ключа. При получении значения по ключу, HashMap вычисляет хеш-код ключа, находит соответствующий бакет и проходит по цепочке объектов Entry, пока не найдет нужный ключ или не достигнет конца цепочки.

Когда количество элементов в HashMap превышает определенный порог, размер массива увеличивается и все элементы перераспределяются в новый массив с большим размером. Этот процесс называется перехешированием.

Преимущества HashMap заключаются в том, что операции добавления, поиска и удаления элементов происходят за почти постоянное время O(1). Однако, при наличии коллизий производительность может ухудшаться до времени O(n). Кроме того, HashMap не гарантирует порядок элементов, что может быть нежелательно в некоторых случаях.

Entry - это внутренний класс в HashMap, который представляет собой узел, хранящий пару ключ-значение. Каждый объект Entry содержит ссылки на следующий и предыдущий элементы, что обеспечивает связанный список всех элементов в хэш-таблице.

Здесь важно отметить, что HashMap внутренне представляет собой массив связанных списков. Каждый элемент массива - это корень связанного списка, который содержит все элементы, у которых хэш-код совпадает с индексом в массиве. Если при добавлении нового элемента вычисленный хэш-код уже есть в массиве, то элемент добавляется в конец соответствующего связанного списка.

Каждый узел в связанном списке является объектом Entry, который содержит следующие поля:

final K key - ключ элемента;
V value - значение элемента;
int hash - хэш-код ключа;
Entry<K,V> next - ссылка на следующий элемент в связанном списке.
При поиске элемента в HashMap вычисляется хэш-код ключа и производится поиск элемента в соответствующем связанном списке. Если ключ не найден, то возвращается null. Если найден элемент с нужным ключом, то возвращается соответствующее ему значение. Если в связанном списке несколько элементов, у которых хэш-код ключа совпадает, то производится последовательный перебор элементов до тех пор, пока не будет найден элемент с нужным ключом.

Вставка элемента в HashMap происходит следующим образом:

вычисляется хэш-код ключа;
вычисляется индекс в массиве по модулю размера массива;
производится поиск элемента с таким же ключом в соответствующем связанном списке;
если элемент с таким ключом не найден, то создается новый объект Entry с заданными ключом и значением;
новый объект Entry добавляется в конец связанного списка.
Если связанный список слишком длинный, то это может привести к ухудшению производительности, так как при поиске элемента производится перебор всех элементов в списке. Чтобы избежать этой проблемы, можно увеличить размер массива HashMap. При этом все элементы будут перераспределены по новым индексам, что может привести к увеличению эффективности поиска элемента в связанном списке.

Вот список всех методов HashMap с кратким описанием того, что они возвращают:


Collection<V> values() - возвращает коллекцию всех значений в отображении в виде объекта типа Collection.
clear(): метод clear() удаляет все элементы из HashMap и не возвращает никакого значения.
containsKey(Object key): метод containsKey(Object key) проверяет, содержится ли указанный ключ key в HashMap. Если ключ содержится, то метод возвращает true, иначе - false.
containsValue(Object value): метод containsValue(Object value) проверяет, содержится ли указанное значение value в HashMap. Если значение содержится, то метод возвращает true, иначе - false.
entrySet(): метод entrySet() возвращает набор элементов Map.Entry в HashMap. Каждый элемент Map.Entry содержит пару "ключ-значение". Метод возвращает Set<Map.Entry<K,V>>.
equals(Object obj): метод equals(Object obj) проверяет, равна ли HashMap указанному объекту obj. Если объекты равны, то метод возвращает true, иначе - false.
get(Object key): метод get(Object key) возвращает значение, связанное с указанным ключом key в HashMap. Если ключа нет в HashMap, то метод вернет null.
hashCode(): метод hashCode() возвращает хеш-код HashMap. Хеш-код используется для быстрого поиска объектов в хранилищах данных. Метод возвращает int.
isEmpty(): метод isEmpty() проверяет, пуста ли HashMap. Если HashMap не содержит элементов, то метод возвращает true, иначе - false.
keySet(): метод keySet() возвращает набор всех ключей в HashMap. Метод возвращает Set<K>.
put(K key, V value): метод put(K key, V value) связывает указанное значение value с указанным ключом key в HashMap. Если ранее было связано другое значение с указанным ключом, то метод заменяет его на новое. Если ключ ранее не был связан с каким-либо значением, то метод добавляет новую пару "ключ-значение" в HashMap. Метод возвращает предыдущее значение, связанное с указанным ключом, или null, если ключ ранее не был связан с каким-либо значением.
putAll(Map<? extends K,? extends V> m): метод putAll(Map<? extends K,? extends V> m) копирует все отображения из указанной Map m в HashMap. Метод не возвращает никакого значения.
remove(Object key): метод remove(Object key) удаляет отображение, связанное с указанным ключом key, из HashMap. Метод возвращает предыдущее значение, связанное с указанным ключом, или null, если ключ не был связан с каким-либо значением.
size(): метод size() возвращает количество отображений в HashMap.
Класс HashMap имеет следующие конструкторы:

HashMap(): создает пустой объект HashMap с начальной емкостью 16 и коэффициентом загрузки по умолчанию 0.75.
HashMap(int initialCapacity): создает пустой объект HashMap с указанной начальной емкостью и коэффициентом загрузки по умолчанию 0.75.
HashMap(int initialCapacity, float loadFactor): создает пустой объект HashMap с указанными начальной емкостью и коэффициентом загрузки.
HashMap(Map<? extends K, ? extends V> m): создает объект HashMap, который содержит те же элементы, что и переданная Map.
В каждом конструкторе мы можем передать начальную емкость и коэффициент загрузки (отношение текущего размера к емкости), которые будут использоваться для вычисления, когда нужно будет увеличить емкость HashMap. Если начальная емкость не указана, по умолчанию используется значение 16. Если коэффициент загрузки не указан, по умолчанию используется значение 0.75.

Конструктор HashMap(Map<? extends K, ? extends V> m) позволяет создать новый объект HashMap, содержащий все элементы из указанной Map.

LinkedHashMap - это класс в Java, который реализует интерфейс Map и представляет собой хэш-таблицу с возможностью сохранения порядка вставки элементов.

Подобно HashMap, LinkedHashMap использует хэш-таблицу для хранения пар "ключ-значение". Однако, в отличие от HashMap, LinkedHashMap также поддерживает связный список элементов, который отображает порядок вставки элементов. Таким образом, порядок элементов в LinkedHashMap будет соответствовать порядку их вставки.

LinkedHashMap может быть использован в тех случаях, когда необходимо сохранить порядок вставки элементов, например, при реализации LRU-кэша (Least Recently Used - кэш с вытеснением давно неиспользуемых элементов).

В LinkedHashMap есть несколько конструкторов, которые позволяют указать начальную емкость, коэффициент загрузки и порядок итерации элементов (вставки или доступа). Также LinkedHashMap предоставляет методы, аналогичные методам HashMap, например, put(), get(), remove(), containsKey(), containsValue() и др.

Одним из дополнительных методов, предоставляемых LinkedHashMap, является removeEldestEntry(). Этот метод может быть переопределен в подклассах LinkedHashMap для определения, должен ли быть удален самый старый элемент в случае превышения определенного числа элементов. Это особенно полезно для реализации LRU-кэшей.

Как и HashMap, LinkedHashMap не является потокобезопасным и может вызывать ошибки при использовании из нескольких потоков. Для потокобезопасного доступа к LinkedHashMap можно использовать метод Collections.synchronizedMap().

У класса LinkedHashMap есть несколько конструкторов:

LinkedHashMap() - создает пустой LinkedHashMap со стандартной начальной емкостью (16) и коэффициентом загрузки (0.75).
LinkedHashMap(int initialCapacity) - создает пустой LinkedHashMap с указанной начальной емкостью и коэффициентом загрузки (0.75).
LinkedHashMap(int initialCapacity, float loadFactor) - создает пустой LinkedHashMap с указанной начальной емкостью и коэффициентом загрузки.
LinkedHashMap(Map<? extends K,? extends V> m) - создает LinkedHashMap, содержащий те же отображения, что и указанная карта, в том же порядке, что и она.
Вот некоторые методы, которые определены в LinkedHashMap:

void clear(): удаляет все элементы из LinkedHashMap.
boolean containsKey(Object key): проверяет, содержит ли LinkedHashMap указанный ключ.
boolean containsValue(Object value): проверяет, содержит ли LinkedHashMap указанное значение.
Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов Map.Entry в LinkedHashMap.
boolean equals(Object obj): проверяет, равен ли LinkedHashMap указанному объекту.
V get(Object key): возвращает значение, связанное с указанным ключом в LinkedHashMap.
int hashCode(): возвращает хеш-код LinkedHashMap.
boolean isEmpty(): проверяет, пуст ли LinkedHashMap.
Set<K> keySet(): возвращает набор всех ключей в LinkedHashMap.
V put(K key, V value): связывает указанное значение с указанным ключом в LinkedHashMap. Если ключ уже существует, то заменяет предыдущее значение новым и возвращает старое значение.
void putAll(Map<? extends K,? extends V> m): копирует все отображения из указанной Map в LinkedHashMap.
V remove(Object key): удаляет отображение, связанное с указанным ключом, из LinkedHashMap и возвращает связанное значение. Если такого ключа нет, то возвращает null.
int size(): возвращает количество отображений в LinkedHashMap.
Collection<V> values(): возвращает коллекцию всех значений в LinkedHashMap в порядке их вставки.


removeEldestEntry(Map.Entry<K,V> eldest) - это метод, который используется для настройки стратегии удаления элементов при вставке новых элементов в LinkedHashMap. Он вызывается после каждой операции добавления элемента и позволяет определить, нужно ли удалить старый элемент из LinkedHashMap.
Метод по умолчанию всегда возвращает false, что означает, что элемент не будет удален. Если мы хотим изменить эту стратегию, мы можем переопределить этот метод в нашем классе-потомке LinkedHashMap.
Например, мы можем создать LinkedHashMap с емкостью 3 и настроить его на удаление старых элементов, когда количество элементов достигнет 3:
java
Copy code
LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(3, 0.75f, true) {
    protected boolean removeEldestEntry(Map.Entry<String, Integer> eldest) {
        return size() > 3;
    }
};
В этом примере мы переопределили метод removeEldestEntry так, чтобы он возвращал true, если размер карты больше 3, что означает, что старый элемент будет удален.


TreeMap - это реализация интерфейса Map, которая хранит ключи в отсортированном порядке. Каждый элемент в TreeMap представляет пару "ключ-значение", где ключ используется для доступа к соответствующему значению.

Внутренне TreeMap использует структуру красно-черного дерева для хранения элементов. При добавлении элементов в TreeMap, они автоматически сортируются по ключу. Это позволяет быстро выполнять операции поиска, вставки и удаления элементов, так как каждый узел в дереве имеет двух потомков, и сложность этих операций зависит от высоты дерева.

TreeMap поддерживает все методы Map, включая добавление элементов put(), получение элементов по ключу get(), удаление элементов remove(), проверка наличия ключа containsKey(), получение размера size(), очистка clear(), а также возможность получить набор всех ключей keySet() и набор всех значений values().

Однако, кроме этого, TreeMap также предоставляет ряд дополнительных методов, таких как:

firstKey(): возвращает наименьший ключ в TreeMap.
lastKey(): возвращает наибольший ключ в TreeMap.
ceilingKey(K key): возвращает наименьший ключ, который больше или равен заданному ключу.
floorKey(K key): возвращает наибольший ключ, который меньше или равен заданному ключу.
higherKey(K key): возвращает наименьший ключ, который больше заданного ключа.
lowerKey(K key): возвращает наибольший ключ, который меньше заданного ключа.
TreeMap также позволяет определять компаратор для ключей, что позволяет производить сортировку в пользовательском порядке. Компаратор может быть передан в конструктор TreeMap или установлен с помощью метода comparator(). Если компаратор не задан, то элементы сортируются в естественном порядке ключей.

"Структура красно-черного дерева" - это один из видов бинарных деревьев поиска, который имеет следующие свойства:

Каждый узел дерева окрашен в красный или черный цвет.
Корень дерева всегда окрашен в черный цвет.
Листья (внешние узлы) дерева всегда окрашены в черный цвет.
Если узел окрашен в красный цвет, то его родительский узел окрашен в черный цвет.
Все простые пути от узла до его листовых потомков содержат одинаковое количество черных узлов.
Красно-черное дерево позволяет эффективно хранить и оперировать данными, так как высота дерева ограничена и гарантировано логарифмическая.

TreeMap использует структуру красно-черного дерева для хранения ключей в отсортированном порядке. Красно-черное дерево позволяет быстро выполнять операции вставки, удаления и поиска элементов, а также позволяет поддерживать ключи в отсортированном порядке.
Красно-черное дерево - это бинарное дерево поиска, в котором каждый узел имеет цвет - либо красный, либо черный. Каждый узел содержит ключ и связанное с ним значение. Красно-черное дерево является сбалансированным деревом, что означает, что высота поддерева с корнем в любом узле отличается не более чем в два раза.

В TreeMap каждый узел представляет собой объект, содержащий три поля: ключ, значение и цвет. Цвет может быть либо красным, либо черным. Все листья дерева (null-узлы) являются черными. Каждый красный узел имеет двух черных потомков, а каждый путь от корня до листа содержит одинаковое число черных узлов.

Добавление, удаление и поиск элементов в TreeMap выполняется за время O(log n), где n - число элементов в дереве. Благодаря использованию красно-черного дерева, TreeMap гарантирует, что элементы будут храниться в отсортированном порядке по ключу.

Ключи в TreeMap должны реализовывать интерфейс Comparable или передаваться в конструктор TreeMap с использованием объекта Comparator, который будет использоваться для сравнения ключей. Это необходимо для упорядочивания элементов в дереве.
Цвет узла красно-черного дерева зависит от его свойств и положения в дереве.

Каждый узел дерева может иметь один из двух цветов: красный или черный. Корень дерева всегда черный. Все листья дерева, т.е. те узлы, которые не имеют потомков, также являются черными. Если узел красный, то его дочерние узлы должны быть черными.

При вставке нового элемента в красно-черное дерево, его место находится в соответствии с обычными правилами бинарного дерева поиска, а затем, если необходимо, производятся повороты узлов и перекрашивание, чтобы сохранить свойства красно-черного дерева. Когда узел перекрашивается, его цвет меняется с черного на красный или с красного на черный, чтобы сохранить или восстановить свойства красно-черного дерева.

Цвета узлов используются для обеспечения баланса дерева и для обеспечения эффективного выполнения операций вставки, удаления и поиска. Красно-черное дерево является самобалансирующимся деревом, что означает, что его глубина всегда логарифмически зависит от числа узлов, что гарантирует быстрый доступ к элементам и быстрое выполнение операций.







    13. Отличие ArrayList от LinkedList?
Основное отличие этих коллекций - это организация вставки и удаления элементов.
У этого метода интересное поведение. Если ячейка уже занята, то элементы сдвигаются вправо, а не заменяются, как в массиве.


ArrayList и LinkedList - это две реализации интерфейса List в Java. Они оба представляют упорядоченную коллекцию элементов, которые могут дублироваться.

Однако, у них есть существенные отличия в том, как они хранят и управляют элементами.

ArrayList представляет собой динамический массив, который расширяется при необходимости добавления новых элементов. При создании ArrayList выделяется начальная емкость (capacity) массива, которую можно указать явно или использовать значение по умолчанию. Если емкости массива не хватает для добавления нового элемента, ArrayList автоматически расширяет массив и копирует все элементы в новый массив. Таким образом, доступ к элементам ArrayList осуществляется через индексы, а операции вставки и удаления элементов могут быть довольно медленными, если необходимо сдвинуть множество элементов в массиве.

LinkedList, с другой стороны, представляет собой связный список, где каждый элемент хранит ссылку на предыдущий и следующий элементы. Каждый элемент списка, называемый узлом (node), хранит данные и ссылки на предыдущий и следующий узлы. При вставке нового элемента в LinkedList, элемент просто добавляется в список и изменяются ссылки на соседние элементы. Удаление элемента также происходит быстро, поскольку не требуется сдвигать множество элементов в массиве.

Таким образом, ArrayList обычно эффективен для доступа к элементам по индексу и приложений с частыми операциями чтения, в то время как LinkedList хорошо подходит для операций вставки и удаления элементов в середине списка. Однако, если требуется часто выполнять операции вставки и удаления элементов в начале и конце списка, рекомендуется использовать другую структуру данных, такую как Deque или ArrayDeque, которые обеспечивают более эффективную работу с этими операциями.
Время выполнения различных операций для ArrayList и LinkedList может зависеть от различных факторов, таких как размер списка, тип операции и способ доступа к элементам.

В целом, доступ к элементам в ArrayList быстрее, чем в LinkedList, потому что ArrayList представляет собой непрерывный блок памяти, а доступ к элементам в LinkedList требует перехода между узлами списка. Однако, вставка и удаление элементов в середине списка быстрее для LinkedList, так как она не требует копирования большого количества элементов, как это может происходить в ArrayList.

Вот приблизительные времена выполнения операций для ArrayList и LinkedList:

Доступ к элементу по индексу: O(1) для ArrayList, O(n) для LinkedList.
Вставка или удаление элемента в конец списка: O(1) для ArrayList, O(1) для LinkedList.
Вставка или удаление элемента в середину списка: O(n) для ArrayList, O(1) для LinkedList.
Поиск элемента по значению: O(n) для ArrayList, O(n) для LinkedList.























    14. Отличие Set от List?

Set и List - это два различных интерфейса коллекций в Java, каждый из которых имеет свои особенности и отличия.

Set - это коллекция, которая содержит уникальные элементы. Это означает, что каждый элемент в Set может появляться только один раз. Set не гарантирует порядок элементов, то есть элементы могут храниться в произвольном порядке.

List - это коллекция, которая содержит элементы в определенном порядке. Это означает, что порядок элементов в List определен и сохраняется. Элементы могут повторяться в List.

Основные отличия между Set и List:

Уникальность элементов: Set не содержит повторяющихся элементов, в то время как List может содержать одинаковые элементы.

Порядок элементов: порядок элементов в Set не гарантируется, в то время как порядок элементов в List сохраняется.

Использование итератора: при использовании итератора, порядок элементов в List сохраняется, в то время как порядок элементов в Set не гарантируется.

Использование метода contains(): для поиска элемента в Set используется метод contains(), который работает быстрее, чем в List, потому что в Set элементы хранятся в хэш-таблице.

Использование метода get(): в List для доступа к элементу используется метод get(), который работает быстрее, чем в Set, потому что элементы в List хранятся в массиве, и доступ к элементу осуществляется по индексу.






    15. Расскажите про методы Object hashCode и equals?







    16. Расскажите, что такое коллизии в Map? Как с ними бороться?
    17. Расскажите, что такое анализ алгоритма?
 18. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны     отличия?




    19. Расскажите реализации данных очередей и стеков.
Очередь – это структура данных, которая работает по принципу "первым пришел - первым вышел" (FIFO - first in, first out). Элементы добавляются в конец очереди, а извлекаются из начала. Рассмотрим две реализации очередей: на основе массива и на основе связного списка.
Рассмотрим методы этого интерфейса, а потом попробуем их использовать на практике.

1. метод add() – добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)

2. Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.

3. Метод offer() – предпринимает попытку вставки элемента в конец очереди.

4. Методы peek() и element() – позволяют вернуть элемент из очереди без его удаления.
Реализация очереди на основе связного списка основана на структуре данных, в которой элементы добавляются в конец очереди и удаляются из начала. Каждый элемент представляет собой узел списка, который содержит значение и указатель на следующий узел.
Подведем некоторые итоги:

1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.

2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.

3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

4. Очереди, доступные в пакете java.util, являются неограниченными очередями.

5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.
Deque (Double-Ended Queue, двусторонняя очередь) - это структура данных, где элементы можно добавлять и удалять с обоих концов очереди. Доступны операции addFirst, addLast для добавления элементов в начало и конец очереди, removeFirst, removeLast для удаления элементов из начала и конца очереди, а также операции peekFirst, peekLast, которые позволяют посмотреть на элементы в начале и конце очереди, но не удаляют их.
Удаление элементов. Для удаления доступно несколько различных методов, но логика примерно так же, как было и с добавлением элементов. Методы poll() и remove() мы уже разбирали у очереди – разница в том, что первый вернет null при пустой очереди, а второй – сгенерирует исключение. Обсудим следующие метод:

- pop() – позволяет удалить головной элемент из очереди и вернуть его. Если очередь пуста – будет сгенерировано исключение NoSuchElementException.

- removeFirst() и pollFirst() – методы также позволят удалить первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

- removeLast() и pollLast() – методы позволят удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

Таким образом мы делаем вывод – предпочтительнее использовать методы poll(), pollFirst() и pollLast(), поскольку они не генерируют непроверяемых исключений, когда наша очередь пустая.
3. Чтение элементов. К ранее рассмотренным методам element() и peek(), которые позволяют прочитать первый элемент из очереди, для чтения также добавлены методы peekFirst() и peekLast() – методы позволяют соответственно прочитать без удаления первый и последний элемент из очереди.
Небольшие выводы:

1. В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.

2. В Java интерфейс Deque поддерживает все методы интерфейса Queue, Collection, включая вставку, удаление и т.д.

3. Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().

4. Наиболее часто используемой реализацией интерфейса Deque является LinkedList.






С реализацией интерфейса Queue под названием PriorityQueue
 выводы, что нам доступны все методы интерфейсов Iterable, Collection и Queue
Каждый элемент в очереди имеет связанное с ним значение приоритета. Приоритет элементов в PriorityQueue определяет порядок обслуживания элементов (если быть точнее, то их удаления из очереди). Если элементы в очереди имеют одинаковый приоритет, то они обслуживаются в соответствии с их порядком в очереди (FIFO).

Следовательно, все элементы располагаются либо в возрастающем или убывающем порядке.
Например, возьмем строки. Они сортируются по алфавиту, а точнее по ASCII. В соответствии этим самый низкий приоритет будут иметь элементы с максимальным значением по ASCII, и естественно наоборот – элементы в начале алфавита имеют наивысший приоритет. Элементы с более высоким приоритетом обслуживаются в первую очередь.

Каким же образом определяется приоритет элементов в приоритетной очереди? Одно из главных требований, которые предъявляются к очереди, это то, что элементы в ней должны быть сопоставимыми, т.е. реализовывать интерфейс Comparable. В противном случае при попытке добавить в такую очередь объект класса, который не реализует интерфейс Comparable, мы получим ClassCastException. Но для того чтобы это обойти мы можем создать очередь из объектов пользовательских классов без реализации этими классами интерфейса Comparable за счет организации сортировки элементов на основании пользовательского компаратора.

В таком случае, голова приоритетной очереди является наименьшим элементом, который основан на сортировке по возрастанию в соответствии с реализацией интерфейса Comparable (или же на основании компаратора). Таким образом, элемент с наименьшим (в некоторых реализациях – наибольшим) значением всегда находится в начале. При этом элементы из такой очереди извлекаются от начала очереди. Таким образом мы можем сделать вывод, что самым приоритетным является элемент с наименьшим значением, т.е. тот, который находится в начале очереди.
Разберемся на небольшом примере, например, сортировка почты. Каждый раз, когда почтальон отдает нам письмо, мы вкладываем его в стопку непрочитанных писем в соответствии с приоритетом. Если письмо требует немедленного ответа (к примеру, мы просрочили оплату доступа в интернет и нам его вот-вот отключат), то такое письмо кладется наверх, а письма, на которые можно ответить в свободное время (например, от родственника, которого мы даже ни разу не видели), подкладываются под низ стопки. Письма со средним приоритетом размещаются где-то в середине. Чем выше приоритет, тем выше оказывается письмо в стопке. Верх стопки как раз соответствует началу приоритетной очереди.

Если окажется, что при сортировке два элемента имеют одинаковое упорядочивание (т.е. сравнение с помощью compareTo() или compare() вернуло 0), то в таком случае элементы размещаются по принципу FIFO – первый пришел, первый вышел.

Приоритетные очереди бывают двух типов:

1. Приоритетная очередь по возрастанию. Нетрудно догадаться, что в такой очереди элементы располагаются по возрастанию значений (в соответствии реализации метода compareTo() интерфейса Comparable или метода compare() интерфейса Comparator). Таким образом, наименьшие значения в начале очереди будут иметь наивысший приоритет.

Например, с числами – у нас есть очередь со значениями 3, 5, 6, 8, 10, 11. Здесь 3 – это наименьшее число, поэтому оно получит наивысший приоритет в приоритетной очереди и когда мы будем удалять элемент из очереди, то при первом удалении мы как раз и получим эту тройку.

2. Приоритетная очередь по убыванию. В такой очереди элементы отсортированы в обратном порядке (в соответствии реализации метода compare() интерфейса Comparator, хотя с помощью compareTo() интерфейса Comparable такое также возможно, однако приветствуется не всеми, будьте осторожны). В таком случае первым элементом будет максимальное значение, и оно будет иметь наивысший приоритет.
1. PriorityQueue() – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в естественном порядке, следовательно в такую очередь мы можем добавить только объекты классов, которые реализуют интерфейс Comparable.

2. PriorityQueue(Comparator<? super E> comparator) – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в порядке, который определяет компаратор, который мы передаем в качестве параметра. В такой очереди наши элементы не обязаны реализовывать интерфейс Comparable.

Наши элементы по очереди распределяются в соответствии с результатами их сравнения с помощью наших интерфейсов Comparable и Comparator. Следовательно, очередь с приоритетом не может содержать в себе null элементов, иначе мы получим NullPointerException.
1. Добавление элемента в очередь с приоритетом. Для этого могут быть использованы 2 метод – add() и offer() . Если посмотреть в исходниках, то мы увидим, что метод add() просто вызывает метод offer(). Поэтому будем рассматривать метод offer().
. Удаление элементов. Удалить элемент можно различными способами:

removeIf(Predicate<? super E> filter) – удаление элемента по какому-то условию;

remove() – удаляет элемент из головы очереди, если она пуста, получаем исключение NoSuchElementException;

remove(Object o) – удаляет элемент из очереди, который будет равен по equals() с тем объектом, который мы передали в качестве параметра.

Но особенно важен метод poll(), поскольку в отличие от remove() он не генерирует исключение, а также позволяет получить значение из головы очереди с удалением этого элемента. Как мы помним элемент в голове очереди имеет наивысший приоритет.
Для того чтобы получить элемент из коллекции без удаления можно использовать 2 метода:

element() – возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – будет сгенерировано исключение NoSuchElementException.

peek() - возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – метод вернет null.

Самое главное, что необходимо помнить – эти методы не осуществляют удаления элемента из очереди. Поэтому, если вызывать эти методы несколько подряд, то мы будем получать одно и то же значение.
Небольшие выводы:

1. PriorityQueue является частью Java Collections Framework. PriorityQueue является неограниченной очередью. По умолчанию элементы упорядочены в естественном порядке (обеспечивается сравнением с помощью compareTo()) или же они отсортированы с помощью компаратора;

2. PriorityQueue не позволяет добавлять null элементы, а также те элементы, которые не реализуют интерфейс Comparable (если мы создаем PriorityQueue без компаратора);

3. Размер PriorityQueue не ограничен, но мы можем указать начальный размер очереди в момент ее создания. Когда мы добавляем элементы в PriorityQueue, ее размер увеличивается автоматически.

4. В начале очереди всегда находится элемент с наивысшим приоритетом. При этом в зависимости от типа используемой очереди это может быть элемент или с минимальным значением, или максимальным.





Для реализации очереди на основе связного списка необходимо определить класс узла, который будет содержать данные и ссылку на следующий узел. Также нужно определить класс очереди, который будет содержать указатель на головной и хвостовой узлы, а также методы для добавления и удаления элементов.
 Рассмотрим две реализации очередей: на основе связного списка.и на основе массива
public class Queue {
    private Node head; // указатель на головной элемент очереди
    private Node tail; // указатель на хвостовой элемент очереди

    // вложенный класс Node, представляющий узел очереди
    private static class Node {
        int data; // значение узла
        Node next; // ссылка на следующий узел
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // конструктор очереди, инициализирует указатели на голову и хвост
    public Queue() {
        this.head = null;
        this.tail = null;
    }

    // Метод для добавления элемента в очередь
    public void enqueue(T data) {
        Node<T> node = new Node<>(data); // создаем новый узел с заданными данными
        if (tail != null) {
            tail.next = node; // если хвост не null, то обновляем ссылку на следующий узел
        }
        tail = node; // обновляем ссылку на последний узел
        if (head == null) {
            head = node; // если голова null, то обновляем ссылку на первый узел
        }
    }

    // метод удаления элемента из начала очереди
    public int dequeue() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        int data = this.head.data; // сохраняем значение головного элемента
        this.head = this.head.next; // переходим на следующий узел
        if (this.head == null) { // если очередь стала пустой, обнуляем указатель на хвост
            this.tail = null;
        }
        return data;
    }

    // метод проверки очереди на пустоту
    public boolean isEmpty() {
        return this.head == null;
    }

    // метод возвращает значение головного элемента очереди без его удаления
    public int peek() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        return this.head.data;
    }
}
В данной реализации мы используем массив для хранения элементов очереди. При добавлении элемента мы сдвигаем указатель на хвостовой элемент на одну позицию вправо, добавляем элемент в массив и увеличиваем размер очереди. При удалении элемента мы берем значение головного элемента, сдвигаем указатель на головной элемент на одну позицию вправо и уменьшаем размер очереди. Также в классе реализованы методы peek() для получения значения головного элемента без его удаления, isEmpty() для проверки, пуста ли очередь, и isFull() для проверки, заполнена ли очередь.

public class ArrayQueue {
    private int[] queue;
    private int head; // указатель на головной элемент
    private int tail; // указатель на хвостовой элемент
    private int size; // текущий размер очереди

    public ArrayQueue(int capacity) {
        queue = new int[capacity];
        head = 0;
        tail = -1;
        size = 0;
    }

    public void enqueue(int element) {
        if (size == queue.length) {
            throw new IllegalStateException("Queue is full");
        }
        tail = (tail + 1) % queue.length;
        queue[tail] = element;
        size++;
    }

    public int dequeue() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        int element = queue[head];
        head = (head + 1) % queue.length;
        size--;
        return element;
    }

    public int peek() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[head];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == queue.length;
    }
}

Стек – это структура данных, которая использует принцип LIFO (Last-In-First-Out), то есть последний добавленный элемент становится первым элементом, который удаляется из стека.

Существуют две основные реализации стека: на основе массива и на основе связного списка.

Реализация стека на основе массива:

В реализации стека на основе массива, элементы стека хранятся в непрерывном блоке памяти. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, значение добавляется в вершину стека, а указатель на вершину сдвигается на одну позицию вверх. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на одну позицию вниз. Если указатель на вершину стека достигает нулевой позиции, значит стек пуст.

Реализация стека на основе связного списка:

В реализации стека на основе связного списка, элементы стека хранятся в узлах списка. Каждый узел списка содержит значение элемента и ссылку на следующий узел. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, создается новый узел списка, который добавляется в вершину стека, а указатель на вершину обновляется. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на один узел вниз. Если указатель на вершину стека указывает на пустой список, значит стек пуст.
Выбор между использованием очереди и стека зависит от конкретной задачи, которую необходимо решить.

Стек используется в ситуациях, когда необходимо осуществлять операции "последний вошел - первый вышел" (LIFO). Например, стек может использоваться для реализации функции "отмена" в текстовом редакторе, где последнее действие пользователя должно быть отменено первым.

Очередь же используется в ситуациях, когда необходимо осуществлять операции "первый вошел - первый вышел" (FIFO). Например, очередь может использоваться для обработки задач в порядке их поступления, где задачи, поступившие раньше, должны быть выполнены раньше.
Для джуниор джава программиста может быть сложно определить, какую структуру данных использовать в конкретной ситуации. Ниже приведены примеры выбора между стеком и очередью для разных задач:

Обработка элементов в порядке "последний вошел - первый вышел" (LIFO). В таком случае, следует использовать стек. Например, если нужно обработать последовательность действий пользователя на веб-странице (например, нажатие кнопок), стек можно использовать для сохранения и последующей обработки этих действий в обратном порядке.

Обработка элементов в порядке "первый вошел - первый вышел" (FIFO). В таком случае, следует использовать очередь. Например, если нужно обработать запросы клиентов на сервере в порядке их поступления, очередь может быть использована для сохранения и последующей обработки этих запросов в том порядке, в котором они были получены.

Рекурсивная обработка данных. Если задача требует рекурсивной обработки данных (например, обход дерева или графа), стек может быть использован для сохранения состояния при переходе от одного узла к другому. В то же время, очередь может быть использована для обхода элементов в порядке их появления.

Обработка задач в фоновом режиме. Если нужно обработать большое количество задач в фоновом режиме, очередь может быть использована для сохранения этих задач и последующей обработки их по одной. В то же время, стек может быть использован, если нужно обрабатывать задачи в порядке, обратном порядку их добавления.






Stack - можно получить только последний элемент LIFO
Stack - примитивная структура данных. Работу этой структуры можно представить в виде тарелок, поставленных друг на друга.
Новая тарелка всегда оказывается верхней. Если нам нужно достать тарелку из середины стопки, то нужно снять верхние тарелки.

Stack лучше всего реализовать на базе связанного списка. Почему связанный список лучше всего подходит для этого? Связанный список умеет быстро вставлять данные и удалять с начала или конца. Это поведение как раз и нужно при реализации стека.

например в связанном списке public class ForwardLinked<T> implements Iterable<T>  мы обявляем класс   private static class Node<T> {
        T value;
        Node<T> next;  -
( В Java вложенный класс node - это класс, который объявлен внутри другого класса и используется для представления узла в связном списке. Это позволяет связанному списку быть частью более крупной структуры данных и сохранять свойство инкапсуляции.
Узел (Node) в связанном списке (Linked List) - это элемент, который содержит значение и ссылку на следующий элемент в списке. Каждый узел в списке связан с предыдущим и/или следующим узлом при помощи ссылок, что образует последовательную цепочку узлов.

Обычно, узел связанного списка состоит из двух основных частей: поля данных, которые содержат значение элемента списка, и поля ссылки, которое указывает на следующий элемент списка. Первый узел списка называется головным узлом (head), а последний узел списка называется хвостовым узлом (tail). Хвостовой узел содержит ссылку на null, что означает конец списка.

В узле связного списка обычно хранятся два поля: значение элемента списка и ссылка на следующий элемент списка. Вложенный класс node может содержать эти поля, а также методы для доступа к ним.) - public void add(T value). public Iterator<T> iterator()


Стек (Stack) - это абстрактный тип данных, который представляет собой коллекцию элементов, управляемую по принципу "последним пришел - первым ушел" (Last-In-First-Out, LIFO). Это означает, что последний элемент, добавленный в стек, будет первым, который будет удален из стека.

Операции, которые можно выполнять со стеком, включают добавление элемента в стек (push), удаление элемента из стека (pop) и получение значения верхнего элемента в стеке без его удаления (peek).

Стек может быть реализован как массив или связный список. В реализации на основе массива, элементы стека хранятся в непрерывном блоке памяти, а указатель (индекс) на вершину стека обновляется при каждой операции добавления или удаления элемента. В реализации на основе связного списка, каждый узел списка содержит элемент стека и ссылку на предыдущий узел, что позволяет легко добавлять и удалять элементы из начала списка.
В Java класс Stack предоставляет следующие основные методы для работы со стеком:

push(E element): добавляет элемент в вершину стека.
pop(): удаляет элемент из вершины стека и возвращает его значение.
peek(): возвращает значение элемента, находящегося на вершине стека, но не удаляет его.
empty(): возвращает true, если стек пуст, и false в противном случае.
search(Object element): возвращает позицию элемента в стеке, начиная с вершины. Если элемент не найден, возвращает -1.

Queue (одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли. FIFO
Dequeue (двусторонняя очередь) - можно вставлять/получать элементы из начали и конца.
Stack - можно получить только последний элемент LIFO




    20. Расскажите про реализации деревьев.
    21. Что такое loadFactor?
   22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.
    23. Расскажите про операции сдвига. Какие они бывают и что делают?
    24. Как хранится знак числа в Java? Как хранятся отрицательные числа?
