 Экзамен. Структуры данных и алгоритмы
1.	Что такое generics?
Generics (обобщения) - это механизм в языке программирования Java, который позволяет создавать параметризованные типы данных, которые могут работать с различными типами данных.

Generics позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных без необходимости написания отдельного кода для каждого типа данных. Вместо этого, вы можете определить параметр типа (также называемый обобщенным типом), который будет заменен на конкретный тип данных при использовании кода.

Для определения параметра типа используется символ "<" и ">" в сочетании с именем параметра типа. Например, следующий код определяет параметризованный тип данных T:

csharp
Copy code
public class MyClass<T> {
    private T value;
    public MyClass(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
Здесь T - это параметр типа, который будет заменен на конкретный тип данных при создании объекта класса MyClass. Например, чтобы создать объект MyClass с типом данных Integer, мы можем использовать следующий код:
MyClass<Integer> myClass = new MyClass<Integer>(10);

---------------------------------------------------------------------

Параметризованный тип (или обобщенный тип) - это тип данных, который создается с использованием параметра типа. В языке Java параметризованные типы позволяют создавать классы, интерфейсы и методы, которые могут работать с различными типами данных.

Для создания параметризованного типа в Java используется символ "<" и ">" для указания параметра типа. Например, следующий код создает параметризованный тип List, который может хранить значения типа String:
List<String> myList = new ArrayList<String>();
Здесь List - это интерфейс, который определен в Java Collections Framework, а ArrayList - это класс, который реализует интерфейс List. Мы указываем параметр типа String в угловых скобках, чтобы создать список, который может хранить только значения типа String.
---------------------------------------------------------------------------------

Generics в данном случае это запись, заключенная в скобки <>
Для решения проблемы совместимости типов разных классов.
Прим. Есть коллекция с в классе, и нужно добовать не только экземпялры этого класса в коллекцию, но и другого класса.  Без <> делать это не безопасно,-> Object, приветению типов. А в <> мы указываем тип данных в виде параметра в классах, методах,интерфейсах.  эклссемпляры которого будем использовать в классе с добавлением в коллекции.

Существует 2 типа дженериков:
Параметризированый тип - Обобщения - это параметризованные типы.  для параметризации класса С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра.
public static class NumberContainer<T extends Number & Comparable>
Для того чтобы создать класс общего типа достаточно в его объявлении в <> указать перечень общих типов, которые будут использоваться для реализации класса (типов может быть несколько)
: Существует такое понятие, связанное с generics, как необработанные типы (в литературе, интернете еще можно встретить такое название как "сырые типы"). Обозначаются они также как и generics в скобках <>, в которых проставляются заглавные латинские символы, зарезервированные специально Когда мы будем использовать этот класс нам будет необходимо указать точный параметр, который будет использоваться вместо K и V. Добавим метод main() выведем в консоль создаваемые объекты с разными параметрами:
public class GenericsClass<K, V> {
    private K key;

    private V value;

    public GenericsClass(K key, V value) {
        this.key = key;
        this.value = value;
    }
GenericsClass<String, String> gen = new GenericsClass<>("First key", "First value");
    System.out.println("Вывод в консоль: " + gen);

    GenericsClass<Integer, String> second = new GenericsClass<>(12345, "Second value");
    System.out.println("Вывод в консоль: " + second);




<?> Wildcard
 используются в сигнатуре методов


2.	Что такое wild cards
Wildcards (дословный перевод - "шаблоны с подстановочными знаками") в языке программирования Java представляют собой механизм, который позволяет создавать более гибкие и универсальные типы данных.
Wildcards позволяют создавать параметризованные типы, которые могут принимать аргументы любого типа, без необходимости знать конкретный тип. Это делает их очень полезными в контексте обобщенного программирования (generic programming), так как они позволяют создавать универсальные методы и классы, которые могут работать с разными типами данных.

public class Person {
    private String name;

    private int age;

    private Date birthday;

--------------------------------
public class Programmer extends Person {
    public Programmer(String name, int age, Date birthday) {
        super(name, age, birthday);
    }
--------------------------------

public class GenericUsage {
    /*
 метод печатает элементы коллекции (collection) в консоль.
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

    /*
     создадим метод который позволит вывести в консоль все элементы коллекции
     , которая может содержать объекты Person или объекты класса Programmer:
     */
    public void printInfo(Collection<? extends Person> collection) {
        for (Iterator<? extends Person> it = collection.iterator();
             it.hasNext();
        ) {
            Person next = it.next();
            System.out.println(next);
        }
    }

    /*
     мы хотим написать метод, который помещает объекты Integer в список и выводит этот
      список в консоль. При этом наш метод должен быть более гибки
      м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
     */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }
----------------------------------------------------



Unbounded Wildcards <?>
 символом подстановки
подстановочные типы.

    3. Что такое bounded wild cards?
Bounded Wildcards: они позволяют ограничить типы данных, которые могут быть переданы в параметризованный тип. Для этого используется ключевое слово extends или super.
	Upper Bounded Wildcards <? extends Number>
List<Integer> ints = new ArrayList<Integer>();
List<? extends Number> nums = ints;
 может содержать объекты, класс которых является Number или наследуется от Number.
 метод который нужно реализовать использует определенный тип и все его подтипы
Это ковариантность.
 Ковариантность — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. List<Integer> — подтип List<? extends Number>





Lower Bounded Wildcards <? super Integer>
List<Number> nums = new ArrayList<Number>();
List<? super Integer> ints = nums;
может содержать объекты, класс которых Number или  у которых Number является наследником (супертип от Number)
ограниченный снизу wildcard ограничивает неизвестный тип определенным типом или супертипом этого типа.
Это контравариантность.
Контравариантность — это обращение иерархии исходных типов на противоположную в производных типах.
 List<Number> является подтипом List<? super Integer>.

 мы хотим написать метод, который помещает объекты Integer в список и выводит этот
  список в консоль. При этом наш метод должен быть более гибки
  м и работал не только с типом Integer, но и с его суперклассами (т.е. Number и Object).
 */
    public void addAll(List<? super Integer> list) {
        for (int i = 1; i <= 5; i++) {
            list.add(i);
        }
        for (Object o : list) {
            System.out.println("Текущий элемент: " + o);
        }
    }




3.	Что такое unbounded wild cards?
Unbounded Wildcards: они представляются символом "?". Эти wildcards позволяют передавать любой тип данных в параметризованный тип.
Unbounded Wildcards <?> позволяют создавать универсальные методы, которые могут работать с различными типами данных.

Unbounded Wildcards <?>
    /*
     работает без ограничений, т.е. в него можно передавать
      коллекцию, которая хранит любые типы.
     */
    public void printRsl(Collection<?> collection) {
        for (Iterator<?> iterator = collection.iterator();
             iterator.hasNext();
        ) {
            Object next = iterator.next();
            System.out.println(next);
        }
    }

Для того, чтобы определиться с выбором между extends и super был придуман метод PECS.
Producer Extends Consumer Super
Если метод имеет аргументы с параметризованным типом (например, Collection<T> или Predicate<T>), то в случае, если аргумент — производитель (producer), нужно использовать ? extends T, а если аргумент — потребитель (consumer), нужно использовать ? super T.

{
	/**
	 * Кладёт значение в хранилище по заданному ключу.
	 *
	 * @param key Ключ.
	 * @param value Значение.
	 */
	void put(K key, V value);

	/**
	 * Читает значение из хранилища по заданному ключу.
	 *
	 * @param key Ключ.
	 * @return Значение либо null.
	 */
	@Nullable V get(K key);

	/**
	 * Кладёт все пары ключ-значение в хранилище.
	 *
	 * @param entries Набор пар ключ-значение.
	 */
	void putAll(Map<K, V> entries);

	/**
	 * Читает все значения из хранилища по заданным
	 * ключам.
	 *
	 * @param keys Набор ключей.
	 * @return Пары ключ-значение.
	 */
	Map<K, V> getAll(Collection<K> keys);

	/**
	 * Читает из хранилища все значения, удовлетворяющие
	 * заданному условию (предикату).
	 *
	 * @param p Предикат для проверки значений.
	 * @return Значения, удовлетворяющие предикату.
	 */
	Collection<V> getAll(Predicate<V> p);
 метод getAll(Predicate<V> p) является Consumer, потому что он принимает предикат p, который применяется к каждому элементу хранилища для определения, удовлетворяет ли элемент условию. Метод не производит никаких значений, а только принимает их и возвращает коллекцию значений, удовлетворяющих предикату.

Остальные методы, такие как put(K key, V value), get(K key), putAll(Map<K, V> entries), и getAll(Collection<K> keys), являются Producer, потому что они создают или производят значения и помещают их в хранилище, или возвращают значения из хранилища.



    5. Где хранится информация про Generics?
В Java информация о типах (Generics) стирается во время компиляции (type erasure), то есть, в скомпилированном байт-коде нет информации о типах, используемых в коде

    6. Как можно получить тип Generics?
 в Java есть механизм рефлексии, который позволяет получать информацию о типах во время выполнения программы

 в исходном коде до компиляции информация о generics может быть доступна через использование Java Reflection API. Reflection API позволяет получить информацию о типах переменных, методов, классов
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0]
getClass().getGenericSuperclass() позволяет получить информацию о суперклассе объекта, а затем метод getActualTypeArguments() возвращает массив параметров типа, указанных в суперклассе в виде дженериков. Поскольку в данном случае параметр типа находится на первой позиции в массиве параметров типа суперкласса, мы можем получить его, обратившись к элементу массива [0].

Затем мы используем оператор приведения типа (Class<T>) для приведения параметра типа к классу типа T, который был указан при создании объекта этого класса.

  7. Что такое итератор?
Итератор в Java - это интерфейс, предоставляющий возможность последовательного доступа к элементам коллекции без раскрытия ее внутренней реализации. Итератор может использоваться для обхода любого типа коллекции, включая списки, множества, карты и т.д.

Интерфейс Iterator в Java содержит 3 метода:

boolean hasNext() - возвращает true, если в коллекции есть следующий элемент, иначе false.
E next() - возвращает следующий элемент в коллекции типа E.
void remove() - удаляет текущий элемент из коллекции.
Каждый итератор хранит внутреннюю переменную, указывающую на текущую позицию в коллекции. Эта переменная устанавливается в начало коллекции при создании итератора, и каждый вызов метода next() перемещает эту переменную на следующий элемент коллекции. Метод hasNext() проверяет, есть ли следующий элемент в коллекции.

Для использования итератора сначала необходимо получить экземпляр этого интерфейса от коллекции, используя метод iterator(). Затем можно использовать методы hasNext() и next() для обхода коллекции.
 fail-fast поведение, т.е. если с момента создания итератора коллекция подверглась структурному изменению, итератор должен кидать ConcurrentModificationException.
Это достигается через введение счетчика изменений - modCount. Каждая операция, которая структурно модифицирует коллекцию, должна инкрементировать этот счетчик. В свою очередь, итератор запоминает значение этого счетчика на момент своего создания (expectedModCount), а затем, на каждой итерации, сравнивает сохраненное значение с текущим значением поля modCount, если они отличаются, то генерируется исключение.

Ранее мы с Вами реализовывали и использовали Iterator, который обладает поведением fail-fast. Что это значит? Это значит, что если мы по ходу итерирования меняем коллекцию, то получаем исключение ConcurrentModificationException. Например, такой код приведет к этому исключению

java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer i : list) {
    list.add(i * i);
}
В качестве альтернативы "обычному" итератору, есть ListIterator. Он обладает fail-safe поведением, это значит, что мы можем менять коллекцию по ходу итерирования, но только с помощью самого итератора.

Подобный код по прежнему не будет работать

java
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
ListIterator<Integer> i = list.listIterator();
while (i.hasNext()) {
    Integer value = i.next();
    if (value <= 5) {
        list.add(value * value);
    }
    i.next();
}
Таким образом, чтобы как-то манипулировать списком во время итерирования, нужно использовать методы ListIterator



  8. Что такое коллекции?

Коллекции в Java - это фреймворк, предоставляющий классы и интерфейсы для управления группами объектов.Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными.
 Java Collection Framework иерархию интерфейсов находятся 2 интерфейса:

1. Collection

2. Map.





    9. Назовите базовые интерфейсы коллекций?
 иерархию интерфейсов   на вершмне Java Collection Framework находятся 2 интерфейса:

1. Collection

2. Map.

Collection – этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и т.д.). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и т.д.)

Map – этот интерфейс также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

Однако стоит обратить внимание, что этот интерфейс расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в так называемом улучшенном цикле for (for-each).

У интерфейса Iterable определен только один метод iterator(). Таким образом все наследники Collection (соответственно и Iterable) обязаны вернуть итератор. Итератор – это объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ к элементам любой коллекции без необходимости вникать в суть его реализации
boolean add(E e) – метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно.
boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась.
Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции.
boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, т.е. коллекция изменилась.
boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции. Таким образом после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции.
boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод. Таким образом в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях.
int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

Чтобы очистить содержимое коллекции можно использовать метод:

void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

Коллекцию можно преобразовать в массив, для этого можно использовать следующий метод:

Object[] toArray() – метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод.




    10. Расскажите реализации интерфейса List?
ArrayList - это класс, который реализует интерфейс List и представляет динамический массив элементов. Он использует массив для хранения элементов и позволяет быстро получать доступ к элементам по индексу. Класс ArrayList также автоматически увеличивает размер массива при добавлении новых элементов, что делает его хорошим выбором для работы с большими списками элементов.
import java.util.ArrayList;
import java.util.List;

public class ArrayListExample {
    public static void main(String[] args) {
        // создание нового ArrayList
        List<String> fruits = new ArrayList<String>();

        // добавление элементов
        fruits.add("apple");
        fruits.add("banana");
        fruits.add("orange");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + fruits.get(0));
        System.out.println("Element at index 1: " + fruits.get(1));

        // удаление элементов
        fruits.remove("banana");
        System.out.println("After removing banana: " + fruits);

        // замена элемента
        fruits.set(1, "pear");
        System.out.println("After replacing index 1 with pear: " + fruits);

        // получение размера списка
        System.out.println("Size of the list: " + fruits.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain orange? " + fruits.contains("orange"));

        // очистка списка
        fruits.clear();
        System.out.println("After clearing the list: " + fruits);
    }
}



LinkedList - это класс, который реализует интерфейс List и представляет двусвязный список элементов. Он использует узлы для хранения элементов и позволяет быстро добавлять и удалять элементы из начала и конца списка. Класс LinkedList также позволяет быстро добавлять и удалять элементы по индексу.
Односвязный список (Singly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение и ссылку на следующий узел в списке. Последний узел в списке содержит ссылку на null. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка и в конце списка, но медленно искать элементы по индексу.
Связанный список - это структура данных, состоящая из узлов, каждый из которых содержит данные и ссылку на следующий узел в списке. Таким образом, элементы списка связаны между собой ссылками, и каждый узел может быть легко найден, используя ссылку на следующий узел.

В Java, связанные списки реализованы в виде класса LinkedList, который реализует интерфейс List. Каждый элемент связанного списка представлен объектом типа Node, который содержит данные и ссылку на следующий узел. Для доступа к первому и последнему элементам списка используются ссылки на головной и последний элементы списка соответственно.

Одним из основных преимуществ связанных списков является то, что они позволяют эффективно добавлять и удалять элементы в любом месте списка, включая начало и конец. Также, при использовании связанных списков, не требуется предварительно выделять память для всего списка, что позволяет экономить ресурсы при работе с большими объемами данных. Однако, связанные списки обладают более сложной логикой работы по сравнению с массивами, их использование может привести к большему количеству операций чтения/записи в память, что может замедлить работу программы в некоторых случаях.

Двусвязный список (Doubly Linked List) - это структура данных, которая состоит из узлов, каждый из которых содержит значение, ссылку на следующий узел в списке и ссылку на предыдущий узел в списке. Первый узел в списке имеет ссылку на null в качестве предыдущего узла, а последний узел имеет ссылку на null в качестве следующего узла. Эта реализация позволяет быстро добавлять и удалять элементы в начале списка, в конце списка и по индексу.

Разница между односвязным списком и двусвязным списком заключается в том, что двусвязный список содержит дополнительные ссылки на предыдущий узел в списке, что делает его более гибким для некоторых операций, но требует больше памяти для хранения ссылок на предыдущие узлы.
import java.util.LinkedList;
import java.util.List;

public class LinkedListExample {
    public static void main(String[] args) {
        // создание нового LinkedList
        List<String> names = new LinkedList<String>();

        // добавление элементов
        names.add("John");
        names.add("Alice");
        names.add("Bob");

        // получение элементов по индексу
        System.out.println("Element at index 0: " + names.get(0));
        System.out.println("Element at index 1: " + names.get(1));

        // удаление элементов
        names.remove("Alice");
        System.out.println("After removing Alice: " + names);

        // замена элемента
        names.set(1, "Mary");
        System.out.println("After replacing index 1 with Mary: " + names);

        // получение размера списка
        System.out.println("Size of the list: " + names.size());

        // проверка на наличие элемента
        System.out.println("Does the list contain Bob? " + names.contains("Bob"));

        // очистка списка
        names.clear();
        System.out.println("After clearing the list: " + names);
    }
}

package ru.job4j.exam.collections.generics.list;

import java.util.*;

public class ListUsage {
    @SuppressWarnings("checkstyle:MethodLength")
    public static void main(String[] args) {
       /* Для добавления новых элементов предназначены 4 метода:
        1.1. boolean add(E e) – добавляет элемент e в конец списка.*/
        List<String> rsl = new ArrayList<>();
        rsl.add("one");
        rsl.add("two");
        rsl.add("three");
/*
1.2. void add(int index, E element) – добавляет указанный элемент
(element) в указанную позицию(index) в списке.
*/
        rsl.add(0, "four");
       /* 1.3. boolean addAll(Collection<? extends E> c) – добавляет все элементы из переданной коллекции в
         конец списка в том порядке, в котором они возвращаются итератором переданной коллекции.*/
        List<String> list = new ArrayList<>();
        list.add("four");
        list.add("five");
        rsl.addAll(2, list);
        for (String s : rsl) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("Прочитать элементы из списка можно двумя способами:\""
                + " 2.1. Использование метода get():");
        for (int i = 0; i < rsl.size(); i++) {
            System.out.println("Текущий элемент: " + rsl.get(i));
        }
        System.out.println("2.2. использовать итератор для доступа к элементам."
                +
                " Для того чтобы получить экземпляр итератора в интерфейсе List<E> определены 3 метода:\n"
                +
                "        Iterator<E> iterator() – метод возвращает объект Iterator, который содержит в\n"
                +
                "         себе все элементы исходной коллекции.");
        Iterator<String> iterator = rsl.iterator();
        while (iterator.hasNext()) {
            System.out.println("Текущий элемент: " + iterator.next());
        }
        System.out.println("ListIterator<E> listIterator() – возвращает итератор списка для элементов в этом списке.");
        ListIterator<String> listIterator = rsl.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator.next());
        }
        System.out.println("ListIterator<E> listIterator(int index) – возвращает итератор списка для элементов"
                + " в этом списке, начиная с элемента индекс которого равен index.");
        ListIterator<String> listIterator1 = rsl.listIterator(5);
        while (listIterator1.hasNext()) {
            System.out.println("Текущий элемент: " + listIterator1.next());
        }
        /*
3. Изменение элементов в списке

E set(int index, E element) – заменяет элемент позиция которого равна index на элемент
 который мы передаем в метод (element). При этом метод возвращает старое значение элемента
  с индексом index.
         */
        List<String> rsl1 = new ArrayList<>();
        rsl1.add("one");
        rsl1.add("two");
        rsl1.add("three");
        rsl1.set(1, "two and second");
        for (String s : rsl1) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
        default void replaceAll(UnaryOperator<E> operator) – заменяет каждый элемент
         в списке результатом применения оператора (operator) к каждому элементу.
         */
        List<String> rsl2 = new ArrayList<>();
        rsl2.add("one");
        rsl2.add("two");
        rsl2.add("three");
        rsl2.replaceAll(String::toUpperCase);
        for (String s : rsl2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        4. Удаление элементов из списка
        Для выполнения данной операции в интерфейсе List<E> определены 5 методов:
         */
        List<String> rsl3 = new ArrayList<>();
        rsl3.add("one");
        rsl3.add("two");
        rsl3.add("three");
        /*
        E remove(int index) – удаляет элемент из списка по индексу index, при этом метод
         возвращает удаленный элемент.
         */
        rsl3.remove(1);
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        . boolean remove(E e) – удаляет элемент е типа E из коллекции при его
         ПЕРВОМ вхождении в список, если он есть в коллекции.
         */
        rsl3.remove("three");
        for (String s : rsl3) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("---");
        /*
        boolean removeAll(Collection<?> col) – метод удаляет из списка все элементы,
         которые содержатся в коллекции col, если в результате работы метода исходный
          список изменился - метод возвращает true.
         */
        List<String> list2 = new ArrayList<>();
        list2.add("one");
        list2.add("three");
        list2.removeAll(list2);
        for (String s : list2) {
            System.out.println("Текущий элемент: " + s);
        }
        System.out.println("-----");
        /*
         boolean retainAll(Collection<?> col) – метод также удаляет элементы из списка,
          за исключением тех, которые находятся в коллекции col, если в результате
           работы метода исходный список изменился - метод возвращает true.
         */
        List<String> list4 = new ArrayList<>();
        list4.add("one");
        list4.add("three");
        list4.retainAll(rsl);
        for (String s : list4) {
            System.out.println("Текущий элемент: " + s);
        }
        /*
 default boolean removeIf(Predicate<? super E> filter) – метод удаляет все элементы из коллекции,
  которые удовлетворяют условию определенному в предикате filter(передается в виде лямбда выражения).
   Если в результате работы метода список изменился - метод возвращает true.
         */
        List<String> words = new ArrayList<>();
        words.add("кот");
        words.add("собака");
        words.add("слон");
        words.add("мышь");
        words.add("хомяк");
        words.removeIf(s -> s.length() <= 3);
        System.out.println(words);

    /*
    . boolean contains*(E element) – метод возвращает true, если список содержит
     переданный в метод элемент element.
     */
        List<Integer> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
        numbers.add(4);
        numbers.add(5);
        boolean b = numbers.contains(2);
        System.out.println("Список содержит элемент: " + b);
        System.out.println("------------");
        /*
        int indexOf*(E element) – метод возвращает индекс элемента element при его
         первом вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> strings = new ArrayList<>();
        strings.add("one");
        strings.add("two");
        strings.add("three");
        strings.add("four");
        strings.add("five");
        int i = strings.indexOf("two");
        System.out.println("Индекс элемента в списке: " + i);
        System.out.println("----------");
        /*
        int lastIndexOf*(E element) - метод возвращает индекс элемента element
         при его последнем вхождении в список. Если элемент не найден - метод возвращает -1.
         */
        List<String> str = new ArrayList<>();
        str.add("two");
        str.add("three");
        str.add("one");
        int index = str.lastIndexOf("one");
        System.out.println("ндекс элемента в списке: " + index);
        System.out.println("----");
        /*
         List<E> subList(int fromIndex, int toIndex) - метод возвращает список, который содержит
          все элементы исходного списка начиная с индекса fromIndex(включительно)
           и до toIndex(значение исключается). При этом, если выполняется условие
            fromIndex == toIndex,- метод вернет пустой список.
         */
        List<String> strings2 = new ArrayList<>();
        strings2.add("one");
        strings2.add("two");
        strings2.add("three");
        strings2.add("four");
        strings2.add("five");
        List<String> newlist = strings2.subList(1, 2);
        for (String s : newlist) {
            System.out.println("екущий элемент: " + s);
        }
        System.out.println("----------");
        /*
        . default void sort(Comparator<? super E> comp) – метод осуществляет сортировку
         списка в соответствии с компаратором comp, который мы передаем в метод.
         */
        List<Integer> numbers1 = new ArrayList<>();
        numbers1.add(5);
        numbers1.add(2);
        numbers1.add(8);
        numbers1.add(1);
        numbers1.sort(Comparator.reverseOrder());
        System.out.println(numbers1);

    }
}



    11. Расскажите реализации интерфейса Set?
java.util.Set - классы реализующие этот интерфейс не могут содержать дубликаты элементов. Их также называют множества.
В коллекциях типа java.util.Set нет возможности указать индекс. Так же здесь нет возможности заменить элемент.
Вопрос, а как мы получаем данные из java.util.Set если там нет механизма извлечения данных.

На самом деле все коллекции реализуют шаблон проектирования - итератор. Этот шаблон позволяет получить все элементы из любой коллекции.

Шаблон итератор основан на интерфейсе java.util.Iterable.
Он имеет три основных метода:

boolean hasNext() - проверяет на наличие следующего элемента в списке.
T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент.
void remove() - удаляет элемент из коллекции и переводит указатель назад.

Указатель - это механизм позволяющий извлечь одиночный элемент из коллекции. Например для массива указатель будет индекс элемента.Главной особенностью коллекций java.util.Set является хранение только уникальных элементов.


. Коллекции java.util.Set не будут добавлять дублирующие элементы.
Познакомимся с интерфейсом Set и его реализациями. Он расширяет интерфейс Collection и представляет собой набор уникальных элементов, т.е. в наборе значений не могут находиться одинаковые значения. Равенство элементов определяется методами equals() и hashcode(), которые определены в классе Object. Для реализаций своих моделей данных эти методы необходимо переопределять для более корректной работы.

Set не добавляет никаких методов по сравнению с Collection, только вносит изменения в унаследованные. Например метод add():

boolean add​(E e) - добавляет новый элемент e в коллекцию. метод возвращает true только в том случае, если такого элемента еще нет в коллекции.

int size() - метод возвращает количество элементов в коллекции.







    12. Расскажите реализации интерфейса Map?

    13. Отличие ArrayList от LinkedList?
Основное отличие этих коллекций - это организация вставки и удаления элементов.
У этого метода интересное поведение. Если ячейка уже занята, то элементы сдвигаются вправо, а не заменяются, как в массиве.

    14. Отличие Set от List?
    15. Расскажите про методы Object hashCode и equals?
    16. Расскажите, что такое коллизии в Map? Как с ними бороться?
    17. Расскажите, что такое анализ алгоритма?
 18. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны     отличия?




    19. Расскажите реализации данных очередей и стеков.
Очередь – это структура данных, которая работает по принципу "первым пришел - первым вышел" (FIFO - first in, first out). Элементы добавляются в конец очереди, а извлекаются из начала. Рассмотрим две реализации очередей: на основе массива и на основе связного списка.
Рассмотрим методы этого интерфейса, а потом попробуем их использовать на практике.

1. метод add() – добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)

2. Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди.

3. Метод offer() – предпринимает попытку вставки элемента в конец очереди.

4. Методы peek() и element() – позволяют вернуть элемент из очереди без его удаления.
Реализация очереди на основе связного списка основана на структуре данных, в которой элементы добавляются в конец очереди и удаляются из начала. Каждый элемент представляет собой узел списка, который содержит значение и указатель на следующий узел.
Подведем некоторые итоги:

1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.

2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.

3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

4. Очереди, доступные в пакете java.util, являются неограниченными очередями.

5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.
Deque (Double-Ended Queue, двусторонняя очередь) - это структура данных, где элементы можно добавлять и удалять с обоих концов очереди. Доступны операции addFirst, addLast для добавления элементов в начало и конец очереди, removeFirst, removeLast для удаления элементов из начала и конца очереди, а также операции peekFirst, peekLast, которые позволяют посмотреть на элементы в начале и конце очереди, но не удаляют их.
Удаление элементов. Для удаления доступно несколько различных методов, но логика примерно так же, как было и с добавлением элементов. Методы poll() и remove() мы уже разбирали у очереди – разница в том, что первый вернет null при пустой очереди, а второй – сгенерирует исключение. Обсудим следующие метод:

- pop() – позволяет удалить головной элемент из очереди и вернуть его. Если очередь пуста – будет сгенерировано исключение NoSuchElementException.

- removeFirst() и pollFirst() – методы также позволят удалить первый элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

- removeLast() и pollLast() – методы позволят удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

Таким образом мы делаем вывод – предпочтительнее использовать методы poll(), pollFirst() и pollLast(), поскольку они не генерируют непроверяемых исключений, когда наша очередь пустая.
3. Чтение элементов. К ранее рассмотренным методам element() и peek(), которые позволяют прочитать первый элемент из очереди, для чтения также добавлены методы peekFirst() и peekLast() – методы позволяют соответственно прочитать без удаления первый и последний элемент из очереди.
Небольшие выводы:

1. В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.

2. В Java интерфейс Deque поддерживает все методы интерфейса Queue, Collection, включая вставку, удаление и т.д.

3. Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().

4. Наиболее часто используемой реализацией интерфейса Deque является LinkedList.






С реализацией интерфейса Queue под названием PriorityQueue
 выводы, что нам доступны все методы интерфейсов Iterable, Collection и Queue
Каждый элемент в очереди имеет связанное с ним значение приоритета. Приоритет элементов в PriorityQueue определяет порядок обслуживания элементов (если быть точнее, то их удаления из очереди). Если элементы в очереди имеют одинаковый приоритет, то они обслуживаются в соответствии с их порядком в очереди (FIFO).

Следовательно, все элементы располагаются либо в возрастающем или убывающем порядке.
Например, возьмем строки. Они сортируются по алфавиту, а точнее по ASCII. В соответствии этим самый низкий приоритет будут иметь элементы с максимальным значением по ASCII, и естественно наоборот – элементы в начале алфавита имеют наивысший приоритет. Элементы с более высоким приоритетом обслуживаются в первую очередь.

Каким же образом определяется приоритет элементов в приоритетной очереди? Одно из главных требований, которые предъявляются к очереди, это то, что элементы в ней должны быть сопоставимыми, т.е. реализовывать интерфейс Comparable. В противном случае при попытке добавить в такую очередь объект класса, который не реализует интерфейс Comparable, мы получим ClassCastException. Но для того чтобы это обойти мы можем создать очередь из объектов пользовательских классов без реализации этими классами интерфейса Comparable за счет организации сортировки элементов на основании пользовательского компаратора.

В таком случае, голова приоритетной очереди является наименьшим элементом, который основан на сортировке по возрастанию в соответствии с реализацией интерфейса Comparable (или же на основании компаратора). Таким образом, элемент с наименьшим (в некоторых реализациях – наибольшим) значением всегда находится в начале. При этом элементы из такой очереди извлекаются от начала очереди. Таким образом мы можем сделать вывод, что самым приоритетным является элемент с наименьшим значением, т.е. тот, который находится в начале очереди.
Разберемся на небольшом примере, например, сортировка почты. Каждый раз, когда почтальон отдает нам письмо, мы вкладываем его в стопку непрочитанных писем в соответствии с приоритетом. Если письмо требует немедленного ответа (к примеру, мы просрочили оплату доступа в интернет и нам его вот-вот отключат), то такое письмо кладется наверх, а письма, на которые можно ответить в свободное время (например, от родственника, которого мы даже ни разу не видели), подкладываются под низ стопки. Письма со средним приоритетом размещаются где-то в середине. Чем выше приоритет, тем выше оказывается письмо в стопке. Верх стопки как раз соответствует началу приоритетной очереди.

Если окажется, что при сортировке два элемента имеют одинаковое упорядочивание (т.е. сравнение с помощью compareTo() или compare() вернуло 0), то в таком случае элементы размещаются по принципу FIFO – первый пришел, первый вышел.

Приоритетные очереди бывают двух типов:

1. Приоритетная очередь по возрастанию. Нетрудно догадаться, что в такой очереди элементы располагаются по возрастанию значений (в соответствии реализации метода compareTo() интерфейса Comparable или метода compare() интерфейса Comparator). Таким образом, наименьшие значения в начале очереди будут иметь наивысший приоритет.

Например, с числами – у нас есть очередь со значениями 3, 5, 6, 8, 10, 11. Здесь 3 – это наименьшее число, поэтому оно получит наивысший приоритет в приоритетной очереди и когда мы будем удалять элемент из очереди, то при первом удалении мы как раз и получим эту тройку.

2. Приоритетная очередь по убыванию. В такой очереди элементы отсортированы в обратном порядке (в соответствии реализации метода compare() интерфейса Comparator, хотя с помощью compareTo() интерфейса Comparable такое также возможно, однако приветствуется не всеми, будьте осторожны). В таком случае первым элементом будет максимальное значение, и оно будет иметь наивысший приоритет.
1. PriorityQueue() – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в естественном порядке, следовательно в такую очередь мы можем добавить только объекты классов, которые реализуют интерфейс Comparable.

2. PriorityQueue(Comparator<? super E> comparator) – в этом случае мы создаем очередь с начальной емкостью по умолчанию (11 элементов), элементы будут упорядочены в порядке, который определяет компаратор, который мы передаем в качестве параметра. В такой очереди наши элементы не обязаны реализовывать интерфейс Comparable.

Наши элементы по очереди распределяются в соответствии с результатами их сравнения с помощью наших интерфейсов Comparable и Comparator. Следовательно, очередь с приоритетом не может содержать в себе null элементов, иначе мы получим NullPointerException.
1. Добавление элемента в очередь с приоритетом. Для этого могут быть использованы 2 метод – add() и offer() . Если посмотреть в исходниках, то мы увидим, что метод add() просто вызывает метод offer(). Поэтому будем рассматривать метод offer().
. Удаление элементов. Удалить элемент можно различными способами:

removeIf(Predicate<? super E> filter) – удаление элемента по какому-то условию;

remove() – удаляет элемент из головы очереди, если она пуста, получаем исключение NoSuchElementException;

remove(Object o) – удаляет элемент из очереди, который будет равен по equals() с тем объектом, который мы передали в качестве параметра.

Но особенно важен метод poll(), поскольку в отличие от remove() он не генерирует исключение, а также позволяет получить значение из головы очереди с удалением этого элемента. Как мы помним элемент в голове очереди имеет наивысший приоритет.
Для того чтобы получить элемент из коллекции без удаления можно использовать 2 метода:

element() – возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – будет сгенерировано исключение NoSuchElementException.

peek() - возвращает элемент из головы очереди, т.е. элемент с наивысшим приоритетом. Если очередь пустая – метод вернет null.

Самое главное, что необходимо помнить – эти методы не осуществляют удаления элемента из очереди. Поэтому, если вызывать эти методы несколько подряд, то мы будем получать одно и то же значение.
Небольшие выводы:

1. PriorityQueue является частью Java Collections Framework. PriorityQueue является неограниченной очередью. По умолчанию элементы упорядочены в естественном порядке (обеспечивается сравнением с помощью compareTo()) или же они отсортированы с помощью компаратора;

2. PriorityQueue не позволяет добавлять null элементы, а также те элементы, которые не реализуют интерфейс Comparable (если мы создаем PriorityQueue без компаратора);

3. Размер PriorityQueue не ограничен, но мы можем указать начальный размер очереди в момент ее создания. Когда мы добавляем элементы в PriorityQueue, ее размер увеличивается автоматически.

4. В начале очереди всегда находится элемент с наивысшим приоритетом. При этом в зависимости от типа используемой очереди это может быть элемент или с минимальным значением, или максимальным.





Для реализации очереди на основе связного списка необходимо определить класс узла, который будет содержать данные и ссылку на следующий узел. Также нужно определить класс очереди, который будет содержать указатель на головной и хвостовой узлы, а также методы для добавления и удаления элементов.
 Рассмотрим две реализации очередей: на основе связного списка.и на основе массива
public class Queue {
    private Node head; // указатель на головной элемент очереди
    private Node tail; // указатель на хвостовой элемент очереди

    // вложенный класс Node, представляющий узел очереди
    private static class Node {
        int data; // значение узла
        Node next; // ссылка на следующий узел
        Node(int data) {
            this.data = data;
            this.next = null;
        }
    }

    // конструктор очереди, инициализирует указатели на голову и хвост
    public Queue() {
        this.head = null;
        this.tail = null;
    }

    // Метод для добавления элемента в очередь
    public void enqueue(T data) {
        Node<T> node = new Node<>(data); // создаем новый узел с заданными данными
        if (tail != null) {
            tail.next = node; // если хвост не null, то обновляем ссылку на следующий узел
        }
        tail = node; // обновляем ссылку на последний узел
        if (head == null) {
            head = node; // если голова null, то обновляем ссылку на первый узел
        }
    }

    // метод удаления элемента из начала очереди
    public int dequeue() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        int data = this.head.data; // сохраняем значение головного элемента
        this.head = this.head.next; // переходим на следующий узел
        if (this.head == null) { // если очередь стала пустой, обнуляем указатель на хвост
            this.tail = null;
        }
        return data;
    }

    // метод проверки очереди на пустоту
    public boolean isEmpty() {
        return this.head == null;
    }

    // метод возвращает значение головного элемента очереди без его удаления
    public int peek() {
        if (this.head == null) { // если очередь пуста, возвращаем -1
            return -1;
        }
        return this.head.data;
    }
}
В данной реализации мы используем массив для хранения элементов очереди. При добавлении элемента мы сдвигаем указатель на хвостовой элемент на одну позицию вправо, добавляем элемент в массив и увеличиваем размер очереди. При удалении элемента мы берем значение головного элемента, сдвигаем указатель на головной элемент на одну позицию вправо и уменьшаем размер очереди. Также в классе реализованы методы peek() для получения значения головного элемента без его удаления, isEmpty() для проверки, пуста ли очередь, и isFull() для проверки, заполнена ли очередь.

public class ArrayQueue {
    private int[] queue;
    private int head; // указатель на головной элемент
    private int tail; // указатель на хвостовой элемент
    private int size; // текущий размер очереди

    public ArrayQueue(int capacity) {
        queue = new int[capacity];
        head = 0;
        tail = -1;
        size = 0;
    }

    public void enqueue(int element) {
        if (size == queue.length) {
            throw new IllegalStateException("Queue is full");
        }
        tail = (tail + 1) % queue.length;
        queue[tail] = element;
        size++;
    }

    public int dequeue() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        int element = queue[head];
        head = (head + 1) % queue.length;
        size--;
        return element;
    }

    public int peek() {
        if (size == 0) {
            throw new IllegalStateException("Queue is empty");
        }
        return queue[head];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == queue.length;
    }
}

Стек – это структура данных, которая использует принцип LIFO (Last-In-First-Out), то есть последний добавленный элемент становится первым элементом, который удаляется из стека.

Существуют две основные реализации стека: на основе массива и на основе связного списка.

Реализация стека на основе массива:

В реализации стека на основе массива, элементы стека хранятся в непрерывном блоке памяти. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, значение добавляется в вершину стека, а указатель на вершину сдвигается на одну позицию вверх. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на одну позицию вниз. Если указатель на вершину стека достигает нулевой позиции, значит стек пуст.

Реализация стека на основе связного списка:

В реализации стека на основе связного списка, элементы стека хранятся в узлах списка. Каждый узел списка содержит значение элемента и ссылку на следующий узел. Указатель на вершину стека хранится в переменной. При добавлении элемента в стек, создается новый узел списка, который добавляется в вершину стека, а указатель на вершину обновляется. При удалении элемента из стека, значение удаляется из вершины стека, а указатель на вершину сдвигается на один узел вниз. Если указатель на вершину стека указывает на пустой список, значит стек пуст.
Выбор между использованием очереди и стека зависит от конкретной задачи, которую необходимо решить.

Стек используется в ситуациях, когда необходимо осуществлять операции "последний вошел - первый вышел" (LIFO). Например, стек может использоваться для реализации функции "отмена" в текстовом редакторе, где последнее действие пользователя должно быть отменено первым.

Очередь же используется в ситуациях, когда необходимо осуществлять операции "первый вошел - первый вышел" (FIFO). Например, очередь может использоваться для обработки задач в порядке их поступления, где задачи, поступившие раньше, должны быть выполнены раньше.
Для джуниор джава программиста может быть сложно определить, какую структуру данных использовать в конкретной ситуации. Ниже приведены примеры выбора между стеком и очередью для разных задач:

Обработка элементов в порядке "последний вошел - первый вышел" (LIFO). В таком случае, следует использовать стек. Например, если нужно обработать последовательность действий пользователя на веб-странице (например, нажатие кнопок), стек можно использовать для сохранения и последующей обработки этих действий в обратном порядке.

Обработка элементов в порядке "первый вошел - первый вышел" (FIFO). В таком случае, следует использовать очередь. Например, если нужно обработать запросы клиентов на сервере в порядке их поступления, очередь может быть использована для сохранения и последующей обработки этих запросов в том порядке, в котором они были получены.

Рекурсивная обработка данных. Если задача требует рекурсивной обработки данных (например, обход дерева или графа), стек может быть использован для сохранения состояния при переходе от одного узла к другому. В то же время, очередь может быть использована для обхода элементов в порядке их появления.

Обработка задач в фоновом режиме. Если нужно обработать большое количество задач в фоновом режиме, очередь может быть использована для сохранения этих задач и последующей обработки их по одной. В то же время, стек может быть использован, если нужно обрабатывать задачи в порядке, обратном порядку их добавления.






Stack - можно получить только последний элемент LIFO
Stack - примитивная структура данных. Работу этой структуры можно представить в виде тарелок, поставленных друг на друга.
Новая тарелка всегда оказывается верхней. Если нам нужно достать тарелку из середины стопки, то нужно снять верхние тарелки.

Stack лучше всего реализовать на базе связанного списка. Почему связанный список лучше всего подходит для этого? Связанный список умеет быстро вставлять данные и удалять с начала или конца. Это поведение как раз и нужно при реализации стека.

например в связанном списке public class ForwardLinked<T> implements Iterable<T>  мы обявляем класс   private static class Node<T> {
        T value;
        Node<T> next;  -
( В Java вложенный класс node - это класс, который объявлен внутри другого класса и используется для представления узла в связном списке. Это позволяет связанному списку быть частью более крупной структуры данных и сохранять свойство инкапсуляции.
Узел (Node) в связанном списке (Linked List) - это элемент, который содержит значение и ссылку на следующий элемент в списке. Каждый узел в списке связан с предыдущим и/или следующим узлом при помощи ссылок, что образует последовательную цепочку узлов.

Обычно, узел связанного списка состоит из двух основных частей: поля данных, которые содержат значение элемента списка, и поля ссылки, которое указывает на следующий элемент списка. Первый узел списка называется головным узлом (head), а последний узел списка называется хвостовым узлом (tail). Хвостовой узел содержит ссылку на null, что означает конец списка.

В узле связного списка обычно хранятся два поля: значение элемента списка и ссылка на следующий элемент списка. Вложенный класс node может содержать эти поля, а также методы для доступа к ним.) - public void add(T value). public Iterator<T> iterator()


Стек (Stack) - это абстрактный тип данных, который представляет собой коллекцию элементов, управляемую по принципу "последним пришел - первым ушел" (Last-In-First-Out, LIFO). Это означает, что последний элемент, добавленный в стек, будет первым, который будет удален из стека.

Операции, которые можно выполнять со стеком, включают добавление элемента в стек (push), удаление элемента из стека (pop) и получение значения верхнего элемента в стеке без его удаления (peek).

Стек может быть реализован как массив или связный список. В реализации на основе массива, элементы стека хранятся в непрерывном блоке памяти, а указатель (индекс) на вершину стека обновляется при каждой операции добавления или удаления элемента. В реализации на основе связного списка, каждый узел списка содержит элемент стека и ссылку на предыдущий узел, что позволяет легко добавлять и удалять элементы из начала списка.
В Java класс Stack предоставляет следующие основные методы для работы со стеком:

push(E element): добавляет элемент в вершину стека.
pop(): удаляет элемент из вершины стека и возвращает его значение.
peek(): возвращает значение элемента, находящегося на вершине стека, но не удаляет его.
empty(): возвращает true, если стек пуст, и false в противном случае.
search(Object element): возвращает позицию элемента в стеке, начиная с вершины. Если элемент не найден, возвращает -1.

Queue (одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли. FIFO
Dequeue (двусторонняя очередь) - можно вставлять/получать элементы из начали и конца.
Stack - можно получить только последний элемент LIFO




    20. Расскажите про реализации деревьев.
    21. Что такое loadFactor?
   22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.
    23. Расскажите про операции сдвига. Какие они бывают и что делают?
    24. Как хранится знак числа в Java? Как хранятся отрицательные числа?
